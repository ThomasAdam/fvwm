.\" Formating instructions for the fvwm man page:
.\"
.\" - Do not use \f... formatting instructions.
.\" - Avoid single and double quotes wherever possible.
.\"
.\"  context                                typeface       example
.\"  -------------------------------------- -------------  -----------------
.\"  filenames:                             italics (.I)   .I .fvwm2rc
.\"  command line options of fvwm2 command: bold (.B)      .B \-cmd
.\"  arguments of command line options:     italics (.I)   .BI \-cmd command
.\"  built in commands:                     bold (.B)      .B Move
.\"  references to built in commands:       bold (.B)      .RB See Move
.\"  references to man page section:        bold (.B)      .RB See SYNOPSIS
.\"  built in command options:              italics (.I)   .BI "Move " "0 0"
.\"  environment variables:                 italics (.I)   .I $DISPLAY
.\"  key names:                             small (.SM)    .SM Tab
.\"  style names and strings:               double quotes  "stylename"
.\"  single characters:                     single quotes  '@'
.\"  module names:                          bold (.B)      .B FvwmTheme
.\"  links to web pages:                    bold (.B)      .B http://fvwm.org
.\"  acronyms:                              small (.SM)    .SM ICCCM
.\"
.\" t
.\" @(#)fvwm2.3 8/14/1999
.de EX		\"Begin example
.ne 5
.if n .sp 1
.if t .sp .5
.nf
.in +.5i
..
.de EE
.fi
.in -.5i
.if n .sp 1
.if t .sp .5
..
.ta .3i .6i .9i 1.2i 1.5i 1.8i
.TH FVWM2 1 "7 May 1999"
.UC
.SH NAME
fvwm2 \- F(?) Virtual Window Manager (version 2) for X11
.SH SYNOPSIS
.BI "fvwm2 [\-blackout] [\-clientId " id "] [\-cmd " config_command "] [\-d " displayname "] [\-debug] [\-f " config_file "] [\-h] [\-replace] [\-restore] [\-s] [\-version] [\-visual " "visual class" "] [\-visualId " id "]"

.SH DESCRIPTION
Fvwm is a window manager for X11.  It is a derivative of
twm, redesigned to
.IR "minimize memory consumption" ,
provide a
.I 3-D look
to window frames, and provide a simple
.IR "virtual desktop" .
Version 2 uses only slightly more memory than 1.xx, mostly due to some
global options being able to be window specific now.

Note that there are several window managers around that have 'fvwm'
in their name.  In the past, versions 2.x of fvwm was commonly called fvwm2
to distinguish it from the former version 1.x (fvwm or even fvwm1).
Since version 1.x has been replaced by version 2.x
a long time ago we will simply call version 2.x and all versions
to come fvwm throughout this document, although the executable
program is named fvwm2.  There is a fvwm offspring called fvwm95.
Although it is very similar to older versions of fvwm version 2
it is technically a different window manager that has been developed
by different people.  The main goal of fvwm95 was to supply a
Windows 95 like look and feel.  Since then fvwm has been greatly
enhanced and only very few features of fvwm95 can not be
imitated by fvwm.  No active development has been going on for
fvwm95 for several years now.  Unfortunately Red Hat (a popular
Linux distributor) has a pre-configured fvwm package based on
fvwm version 2.x that is called fvwm95 too.

Fvwm provides both a large virtual desktop and
.I multiple disjoint desktops
which can be used separately or together.  The virtual desktop
allows you to pretend that your video screen is really quite large,
and you can scroll around within the desktop.  The multiple disjoint
desktops allow you to pretend that you really have several screens to
work at, but each screen is completely unrelated to the others.

Fvwm provides
.I keyboard accelerators
which allow you to perform most
window-manager functions, including moving and resizing windows, and
operating the window-manager's menus, using keyboard shortcuts.

Fvwm has also blurred the distinction between configuration commands
and built-in commands that most window-managers make.  Configuration
commands typically set fonts, colors, menu contents, key and mouse
function bindings, while built-in commands typically do things like
raise and lower windows.  Fvwm makes no such distinction, and allows,
to the extent that is practical, anything to be changed at any time.

Other noteworthy differences between Fvwm and other X11 window managers
are the introduction of the
.B SloppyFocus
and per-window focus methods.
SloppyFocus is focus-follows-mouse, but focus is not removed from
windows when the mouse leaves a window and enters the root window.
When sloppy focus is used as the default focus style, it is nice to
make windows in which you do not typically type into (xmag, xman,
xgraph, xclock, xbiff, etc)
.BR "NeverFocus" ,
so that your terminal
window doesn't lose focus unnecessarily.

.SH OPTIONS
These are the command line options that are recognized by fvwm:
.TP
.BI "-blackout"
This option is provided for backward compatibility only.  Blacking out
the screen during startup is not necessary anymore.
.TP
.BI "-clientId " id
This options is used when fvwm is restarted by means of the 'Restart'
command or by the session manager.  This option is ignored if fvwm
was compiled without session management.
.TP
.BI "-cmd " config_command
Causes fvwm to use
.I config_command
instead of
.RB """"Read
.IR .fvwm2rc """ \""
as its initialization command.
(Note that up to 10
.BR \-f " and " \-cmd
parameters can be given, and they are executed in the order specified.)
.TP
.BI "-d " displayname
Manage the display called
.I displayname
instead of the name obtained from the environment variable
.IR "$DISPLAY" .
.TP
.BI "-debug"
Puts X transactions in synchronous mode, which dramatically slows things
down, but guarantees that fvwm's internal error messages are correct.
Also causes fvwm to output debug messages while running.
.TP
.BI "-f " config_file
Causes fvwm to read
.I config_file
instead of
.I .fvwm2rc
as its initialization file.  This is equivalent to
.RB """"-cmd " " Read
.IR config_file """. \""
.
.TP
.BI "-h"
A short usage description is printed.
.TP
.BI "-replace"
Try to take over from a previously running wm. This will not work
unless the other wm is
.SM ICCCM
2.0 compliant.
.TP
.BI "-restore"
This option is used when fvwm is restarted by means of the 'Restart'
command or by the session manager.
.TP
.BI "-s"
On a multi-screen display, run fvwm only on the screen named in
the
.I $DISPLAY
environment variable or provided through the -d
option. Normally, fvwm will attempt to start up on all screens
of a multi-screen display.
.TP
.BI "-version"
Prints the version of fvwm to stderr. Also prints an information about the
compiled in support for readline, rplay, stroke, xpm, imlib, gnome and
session management.
.TP
.BI "-visual " visual_class
Causes fvwm to use
.I visual_class
for the window borders and menus.
.I visual_class
can be StaticGray, GrayScale, StaticColor, PseudoColor,
TrueColor or DirectColor.
.TP
.BI "-visualId " id
Causes fvwm to use
.I id
as the visualID for the window borders
and menus.
.I id
can be specified as N for decimal or 0xN for
hexadecimal.  See xdpyinfo for a list of supported visuals.

.SH ANATOMY OF A WINDOW
Fvwm puts a decorative border around most windows.  This border
consists of a bar on each side and a small L-shaped section on each
corner.  There is an additional top bar called the title-bar which is
used to display the name of the window.  In addition, there are up to
10 title-bar buttons.  The top, side, and bottom bars are collectively
known as the side-bars.  The corner pieces are called the frame.

Unless the standard defaults files are modified, pressing mouse button
1 in the title or side-bars will begin a move operation on the
window.  Pressing button 1 in the corner frame pieces will begin a
resize operation.  Pressing button 2 anywhere in the border brings up
an extensive list of window operations.

Up to ten title-bar buttons may exist.  Their use is completely user
definable.  The default configuration has a title-bar button on each
side of the title-bar.  The one on the left is used to bring up a list
of window options, regardless of which mouse button is used.  The one
on the right is used to iconify the window.  The number of title-bar
buttons used depends on which ones have mouse actions bound to
them.  See the section on the
.B Mouse
command below.


.SH THE VIRTUAL DESKTOP
Fvwm provides multiple virtual desktops for users who wish to
use them.  The screen is a viewport onto a
.I desktop
which may be larger
than the screen.  Several distinct desktops can be accessed (concept:
one desktop for each project, or one desktop for each application,
when view applications are distinct).  Since each desktop can be
larger than the physical screen, divided into m by n
.I pages
which are
each the size of the physical screen, windows which are larger than
the screen or large groups of related windows can easily be viewed.

The (m by n) size (i.e. number of pages) of the virtual desktops can be
changed any time, by using the DeskTopSize built-in command.  All
virtual desktops must be (are) the same size.  The total number of
distinct desktops does not need to be specified, but is limited to
approximately 4 billion total.  All windows on a range of desktops can
be viewed in the Pager, a miniature view of the desktops.  The pager
is an accessory program, called a module, which is not essential for
the window manager to operate.  Windows may also be listed, along with
their geometries, in a window list, accessible as a pop-up menu, or as
a separate window, called the FvwmWinList (another module).

Fvwm keeps the windows on the desktop in a layered stacking order;
a window in a lower layer will never obscure a window in a higher layer.
The layer of a window can be changed by using the
.B Layer
command.
The concept of layers is a generalization of the StaysOnTop flag of older
fvwm versions. The StaysOnTop and StaysPut style options are now implemented
by putting the windows in suitable layers and the previously missing
StaysOnBottom style option has been added.

.B Sticky
windows are windows which transcend the virtual desktop by
"Sticking to the screen's glass".  They always stay put on the screen.
This is convenient for things like clocks and xbiff's, so you only need
to run one such gadget and it always stays with you.  Icons can also be
made to stick to the glass, if desired.

Window geometries are specified relative to the current viewport.  That
is:
.EX
xterm -geometry +0+0
.EE
will always show up in the upper-left hand
corner of the visible portion of the screen.  It is permissible to
specify geometries which place windows on the virtual desktop, but off
the screen.  For example, if the visible screen is 1000 by 1000 pixels,
and the desktop size is 3x3, and the current viewport is at the upper
left hand corner of the desktop, then invoking:
.EX
xterm -geometry +1000+1000
.EE
will place the window just off of the lower right hand corner of the
screen.  It can be found by moving the mouse to the lower right hand
corner of the screen and waiting for it to scroll into view.  A geometry
specified as something like:
.EX
xterm -geometry -5-5
.EE
will generally place the window's lower right hand corner 5 pixels from the
lower right corner of the visible portion of the screen. Not all
applications support window geometries with negative offsets. Some will
place the window's upper right hand corner 5 pixels above and to the left
of the upper left hand corner of the screen; others may do just plain
bizarre things.

There are several ways to cause a window to map onto a desktop or page
other than the currently active one. The geometry technique mentioned above
(specifying x,y coordinates larger than the physical screen size), however,
suffers from the limitation of being interpreted relative to the current
viewport: the window will not consistently appear on a specific page, unless
you always invoke the application from the same page.

A better way to place windows on a different page or desk from the
currently mapped viewport is to use the
.B StartsOnPage
style specification
(the successor to the older
.I StartsOnDesk
style) in the
.I .fvwm2rc
configuration file. The placement is
consistent: it does not depend on your current location on the
virtual desktop.

Some applications that understand standard Xt command line arguments
and X resources, like xterm and xfontsel, allow the user to specify
the start-up desk or page on the command line:
.EX
xterm -xrm "*Desk:1"
.EE
will start an xterm on desk number 1;
.EX
xterm -xrm "*Page:3 2 1"
.EE
will start an xterm two pages to the right and one down from the upper
left hand page of desk number 3. Not all applications understand the use
of these options, however.  You could achieve the same results with
the following lines in your
.I .Xdefaults
file:
.EX
XTerm*Desk: 1
.EE
or
.EX
XTerm*Page: 3 2 1
.EE

.SH INITIALIZATION
During initialization, fvwm will search for a configuration file
which describes key and button bindings, and a few other things.  The
format of these files will be described later.
Fvwm first searches for configurations files using the command
.RB """"Read
.IR .fvwm2rc """. \""
This will look for
.IR "$HOME/.fvwm2rc" " or " "$FVWM_USERHOME/.fvwm2rc" ,
as described in
.B Read
below.  If a configuration file is not found, any mouse button or the
.SM Help
or
.SM F1
keys on the root window will bring up menus and forms that can
create a starting configuration file.

Fvwm will set two environment variables which will be inherited
by its children.  These are
.I $DISPLAY
which describes the display on
which fvwm is running.
.I $DISPLAY
may be
.I unix:0.0
or
.IR ":0.0" ,
which doesn't work too well when passed through rsh to another machine, so
.I $HOSTDISPLAY
will also be set and will use a network-ready description of the display.
.I $HOSTDISPLAY
will always use the TCP/IP transport protocol (even for a local connection) so
.I $DISPLAY
should be used for local connections, as it may use Unix-domain sockets,
which are faster.

If you want to start some applications or modules with fvwm,
you can simply put 'Exec app' or 'Module FvwmXxx' into your
.IR .fvwm2rc ,
but it is not recommended; do this only if you know what you are doing.
It is usually critical to start applications or modules after
.I .fvwm2rc
is read, because it contains styles or module configurations which can affect
window appearance and functionality.

The standard way to start applications or modules on fvwm's start up is to
add them to an initialization function (usually StartFunction or
InitFunction). This way they are only started after fvwm reads
the entire
.IR .fvwm2rc .

Fvwm has three special functions for initialization:
StartFunction, which is executed on startups and restarts; InitFunction
and RestartFunction, which are executed during Initialization and Restarts
(respectively) just after StartFunction.  These may be customized
in a user's
.I .fvwm2rc
file via the AddToFunc facility (described later) to start up
modules, xterms, or whatever you'd like to have started by fvwm.

Fvwm has also a special exit function: ExitFunction, executed
when exiting or restarting before actually quitting.
It could be used to explicitly kill modules, etc.

If fvwm is run under a session manager, functions SessionInitFunction
and SessionRestartFunction are executed instead of InitFunction and
RestartFunction. This helps to define a user's
.I .fvwm2rc
file to be good for both
running under a session manager and without it. Generally it is a bad idea to
start xterms or other applications in Session* functions. Also someone can
decide to start different modules while running under a session manager or not.
For the similar purposes SessionExitFunction is used instead of ExitFunction.

.EX
DestroyFunc StartFunction
AddToFunc StartFunction
 + I ModuleSynchronous FvwmTheme
 + I Module FvwmPager * *
 + I Module FvwmButtons

DestroyFunc InitFunction
AddToFunc InitFunction
 + I Module FvwmBanner
 + I Module FvwmTaskBar
 + I xsetroot -solid cyan
 + I Exec xterm
 + I Exec netscape

DestroyFunc RestartFunction
AddToFunc RestartFunction
 + I Module FvwmTaskBar

DestroyFunc SessionInitFunction
AddToFunc SessionInitFunction
 + I Module FvwmBanner

DestroyFunc SessionRestartFunction
AddToFunc SessionRestartFunction
 + I Nop
.EE

You don't need to define all special functions if some are empty.

.SH COMPILATION OPTIONS
Fvwm has a number of compile-time options to reduce memory usage
by limiting the use of certain features.  If you
have trouble using a certain command or feature, check to see if
support for it was included at compile time.  Optional features are
described in the
.I config.h
file.

.SH ICONS
The basic Fvwm configuration uses monochrome bitmap icons,
similar to twm.  If XPM extensions are compiled in, then color
icons similar to ctwm, MS-Windows, or the Macintosh icons can be used.
In order to use these options you will need the XPM package, as
described in the
.I INSTALL.fvwm
file.

If both the SHAPE and XPM options are compiled in you will get shaped
color icons, which are very spiffy.

.SH MODULES
A module is a separate program which runs as a separate Unix process
but transmits commands to fvwm to execute.  Users can write
their own modules to do any weird or bizarre manipulations without
bloating or affecting the integrity of fvwm itself.

Modules MUST be spawned by fvwm so that it can set up two pipes for
fvwm and the module to communicate with.  The pipes will already be
open for the module when it starts and the file descriptors for the
pipes are provided as command line arguments.

Modules can be spawned during fvwm at any time during the X
session by use of the Module built-in command.  Modules can exist for
the duration of the X session, or can perform a single task and exit.
If the module is still active when fvwm is told to quit, then
fvwm will close the communication pipes and wait to receive a
SIGCHLD from the module, indicating that it has detected the pipe
closure and has exited.  If modules fail to detect the pipe closure
fvwm will exit after approximately 30 seconds anyway.  The
number of simultaneously executing modules is limited by the operating
system's maximum number of simultaneously open files, usually between
60 and 256.

Modules simply transmit text commands to the fvwm built-in
command engine.  Text commands are formatted just as in the case of a
mouse binding in the
.I .fvwm2rc
setup file.  Certain auxiliary
information is also transmitted, as in the sample module FvwmButtons.
The FvwmButtons module is documented in its own man page.

.SH ICCCM COMPLIANCE
Fvwm attempts to be
.SM ICCCM
2.0 compliant.  In addition,
.SM ICCCM
states that it should be possible for applications to receive ANY
keystroke, which is not consistent with the keyboard shortcut approach
used in fvwm and most other window managers. In particular you
cannot have the same keyboard shortcuts working with your fvwm and
another fvwm running within Xnest (a nested X server). The same problem
exists with mouse bindings.

The
.SM ICCCM
states that windows possessing the property
.EX
WM_HINTS(WM_HINTS):
    Client accepts input or input focus: False
.EE
should not be given the keyboard input focus by the window manager.
These windows can take the input focus by themselves, however.  A
number of applications set this property, and yet expect the
window-manager to give them the keyboard focus anyway, so fvwm
provides a window-style, "Lenience", which will allow fvwm to overlook
this
.SM ICCCM
rule.

The differences between
.SM ICCCM
1.1 and 2.0 include the ability to take over from a running
.SM ICCCM
 2.0 compliant window manager; thus
.EX
fvwm2; vi .fvwm2rc; fvwm2 -replace
.EE
will resemble the Restart command. It is not exactly the same as the
Restart command, since killing the previously running wm may terminate
your X session, if the wm was started as the last client in your
.IR .Xclients " or " .Xsession
file.

Further additions are support for client-side colormap installation (see the
.SM ICCCM
for details) and the urgency hint. Clients can set this hint in
the WM_HINTS property of their window and expect the window manager
to attract the users attention to the window. Fvwm has two re-definable
functions for this purpose, UrgencyFunc and UrgencyDoneFunc, which
are executed when the flag is set/cleared.
Their default definitions are:
.EX
AddToFunc UrgencyFunc
 + I Iconify off
 + I FlipFocus
 + I Raise
 + I WarpToWindow 5p 5p
AddToFunc UrgencyDoneFunc
 + I Nop
.EE

.SH GNOME COMPLIANCE
Fvwm attempts to be
.SM GNOME
compliant.  Check
.B http://www.gnome.org
for what that may mean.
.SM GNOME
support is a compile time option.

.SH M4 PREPROCESSING
.PP
M4 pre-processing is handled by a module in fvwm.  To get more
details, try man FvwmM4.  In short, if you want fvwm to parse your
files with m4, then replace the word "Read" with "FvwmM4" in
your
.I .fvwm2rc
file (if it appears at all), and start fvwm with the command
.EX
fvwm2 -cmd "FvwmM4 .fvwm2rc"
.EE

.SH CPP PREPROCESSING
.PP
Cpp is the C-language pre-processor.  fvwm offers cpp processing
which mirrors the m4 pre-processing.  To find out about it, re-read
the M4 section above, but replace "m4" with "cpp".

.SH AUTO-RAISE
.PP
Windows can be automatically raised when it receives focus, or some
number of milliseconds after it receives focus, by using the
auto-raise module, FvwmAuto.

.SH CONFIGURATION FILES
The configuration file is used to describe mouse and button bindings,
colors, the virtual display size, and related items.  The
initialization configuration file is typically called
.IR .fvwm2rc .
By using the
.B Read
built-in, it is easy to read in new configuration files as you go.

Lines beginning with '#' will be ignored by fvwm.  Lines
starting with '*' are expected to contain module configuration
commands (rather than configuration commands for fvwm itself).
Like in shell scripts embedded newlines in a configuration file line
can be quoted by preceding them with a backslash. All lines linked
in this fashion are treated as a single line. The newline itself is
ignored.

Fvwm makes no distinction between configuration commands and built-in
commands, so anything mentioned in the built-in commands section  can
be placed on a line by itself for fvwm to execute as it reads the
configuration file, or it can be placed as an executable command in a
menu or bound to a mouse button or a keyboard key.  It is left as an
exercise for the user to decide which function make sense for
initialization and which ones make sense for run-time.

.SH INTERNATIONALIZATION
Internationalized fvwm enables to display not only LATIN-1 characters
but also multi byte characters such as Japanese, Korean, etc. You should
set up your environment variable
.IR LC_TYPE " or " LANG ,
to enable this feature.  Also, you should specify proper
.I FONTSET
instead of
.IR FONT .
Note that no catalog-file or input-methods are implemented.

.SH BOOLEAN ARGUMENTS
A number of commands take one or several boolean arguments. These
take a few equivalent inputs: 'yes', 'on', 'true', 't' and 'y' all
evaluate to True while 'no', 'off', 'false', 'f' and 'n' evaluate
to False. Some commands allow 'toggle' too which means that the
feature is disabled if it is currently enabled and vice versa.

.SH BUILT IN KEY AND MOUSE BINDINGS
The following commands are built-in to fvwm:
.EX
Key Help R A Popup MenuFvwmRoot
Key F1 R A Popup MenuFvwmRoot
Key Tab A M WindowList Root c c NoDeskSort
Key Escape A MC EscapeFunc
Mouse 1 TS A FuncFvwmRaiseLowerX Move
Mouse 1 F  A FuncFvwmRaiseLowerX Resize
AddToFunc FuncFvwmRaiseLowerX I Raise
+ M $0
+ D Lower
.EE

The "Help" and "F1" keys invoke a built-in menu that fvwm creates.
This is primarily for new users that haven't created their own configuration
file.  Either key on the root (background) window will pop up an menu
which should help you get started.

The tab key pressed anywhere with the "meta" key held down will pop-up
a window list.

Mouse button 1 on the title-bar or side frame can move, raise or lower
a window.

Mouse button 1 on the window corners can resize, raise or lower a window.

You can override or remove these bindings.
To remove the window list binding, use this:
.EX
Key Tab A M -
.EE

.SH BUILT IN COMMANDS

Fvwm supports a set of built-in functions which can be bound to
keyboard or mouse buttons.  If fvwm expects to find a built-in function
in a command, but fails, it will check to see if the specified command
should have been "Function (rest of command)" or "Module (rest of
command)".  This allows complex functions or modules to be invoked in a
manner which is fairly transparent to the configuration file.

Example: the
.I .fvwm2rc
file contains the line "HelpMe".  Fvwm will look
for a built-in command called "HelpMe", and will fail. Next it will
look for a user-defined complex function called "HelpMe".  If no such
user defined function exists, Fvwm will try to execute a module called
"HelpMe".

.SS QUOTING

Quotes are required only when needed to make fvwm consider two or more
words to be a single argument.  Unnecessary quoting is allowed.  If you
want a quote character in your text, you must escape it by using the
backslash character.  For example, if you have a pop-up menu called
Window-Ops, then you don't need quotes: Popup Window-Ops, but if you
replace the dash with a space, then you need quotes: Popup "Window
Ops".  The supported quoting characters are double quotes, single
quotes and reverse single quotes.  All three kinds of quotes are
treated in the same way.  Single characters can be quoted with a
preceding backslash.  Quoting single characters works even inside
other kinds of quotes.

.SS COMMAND LINE PARAMETER EXPANSION

Whenever a fvwm command line is executed, fvwm performs parameter
expansion.  A parameter is a '$' followed by a single letter or
a word enclosed in braces.  If fvwm encounters an unquoted
parameter on the command line it expands it to a string indicated
by the parameter name.  Unknown parameters are left untouched.
Parameter expansion is performed before quoting.  To quote a
'$' use "$$".  Note that module configuration lines (i.e. lines
beginning with '*') are not subject to parameter expansion.  The
parameters known by fvwm are:

.in +.5i
$$
.in +.3i
A literal '$'.
.in -.3i
.in -.5i

.in +.5i
$c
.in +.3i
The window's resource class name or '$c' if no window is
associated with the command.
.in -.3i
.in -.5i

.in +.5i
$d
.in +.3i
The current desk number.
.in -.3i
.in -.5i

.in +.5i
$n
.in +.3i
The window's name or '$n' if no window is
associated with the command.
.in -.3i
.in -.5i

.in +.5i
$r
.in +.3i
The window's resource name or '$r' if no window is
associated with the command.
.in -.3i
.in -.5i

.in +.5i
$v
.in +.3i
The first line printed by the -version command line option.
.in -.3i
.in -.5i

.in +.5i
$w
.in +.3i
The window-id (expressed in hex, e.g. 0x10023c) of the
window the command was called for or '$w' if no window is
associated with the command.
.in -.3i
.in -.5i

.in +.5i
$x
.in +.3i
The x coordinate of the current viewport.
.in -.3i
.in -.5i

.in +.5i
$y
.in +.3i
The y coordinate of the current viewport.
.in -.3i
.in -.5i

.in +.5i
$0 to $9
.in +.3i
The positional parameters given to a complex function
(a function that has been defined with the
.B AddToFunc
command).  $0 is replaced with the first parameter, $1 with the
second parameter and so on.  If the corresponding parameter
is undefined, the '$#' is deleted from the command line.
.in -.3i
.in -.5i

.in +.5i
$[fg.cs<n>]
.in -.5i
.in +.5i
$[bg.cs<n>]
.in -.5i
.in +.5i
$[hilight.cs<n>]
.in -.5i
.in +.5i
$[shadow.cs<n>]
.in +.3i
These class of parameters is replaced with the name of
the foreground (fg), background (bg), hilight (hilight) or
shadow (shadow) color that is defined in colorset <n> (replace
<n> with zero or a positive integer).  For example $[fg.cs3]
is expanded to the name of the foreground color of colorset 3
(in rgb:rrrr/gggg/bbbb form).  Please refer to the man page
of the
.B FvwmTheme
module for details about colorsets.
Note that although other parameters cannot be used in module
configuration lines, is is possible to use this class of
parameters.  They can be used wherever a module expects a
color name.  Since the
.B FvwmTheme
module is not running when
fvwm first passes through its configuration file, you may not
get the desired results if you use this in commands
like 'Style * HilightFore $[fg.cs0], HilightBack $[bg.cs0]'.
.in -.3i
.in -.5i

Some examples can be found in the description of the
.B AddToFunc
command.

.SS THE LIST OF BUILTIN COMMANDS

The commands descriptions below are grouped together in the
following sections.  The sections are hopefully sorted in
order of usefulness to the newcomer.

.EX
- Menu commands
- Miscellaneous commands
- Commands affecting window movement and placement
- Commands for focus and mouse movement
- Commands controlling window state
- Commands for mouse, key and stroke bindings
- The Style command (controlling window styles)
- Other commands controlling window styles
- Commands controlling the virtual desktop
- Commands for user functions and shell commands
- Conditional commands
- Module commands
- Quit, restart and session management commands
- Color gradients
.EE

.SS COMMANDS FOR MENUS

.TP
.BI "AddToMenu " menu-name " [" menu-label " " action "]"
Begins or adds to a menu definition.  Typically a menu definition looks
like this:
.EX
AddToMenu Utilities Utilities Title
 + Xterm           Exec  exec xterm -e tcsh
 + Rxvt            Exec  exec rxvt
 + "Remote Logins" Popup Remote-Logins
 + Top             Exec  exec rxvt -T Top -n \\
                   Top -e top
 + Calculator      Exec  exec xcalc
 + Xman            Exec  exec xman
 + Xmag            Exec  exec xmag
 + emacs           Exec  exec xemacs
 + Mail            MailFunction \\
                   xmh "-font fixed"
 + ""              Nop
 + Modules         Popup Module-Popup
 + ""              Nop
 + Exit Fvwm       Popup Quit-Verify
.EE
The menu could be invoked via
.EX
Mouse 1 R A Menu Utilities Nop
.EE
or
.EX
Mouse 1 R A Popup Utilities
.EE
There is no end-of-menu symbol.  Menus do not have to be defined in a
contiguous region of the
.I .fvwm2rc
file.  The quoted portion in the
above examples is the menu-label, which will appear in the menu when
the user pops it up.  The remaining portion is a built-in command
which should be executed if the user selects that menu item.  An empty
menu-label ("") and the Nop function can be used to insert a separator
into the menu.

The keywords
.IR DynamicPopUpAction " and " DynamicPopDownAction
have a special meaning when used as the name of a menu item. The action
following the keyword is executed whenever the menu is popped up or
down. This way you can implement dynamic menus. It is even possible for
the menu to destroy itself with
.B DestroyMenu
and the rebuild from scratch. When the menu has been destroyed
(unless you used the
.I recreate
option when destroying the menu), do not forget to add the dynamic
action again.

Note: Do not trigger actions that require user interaction. They will
probably fail and may screw up your menus. See
.B Silent
command.

Example (File browser):

.EX
# You will find the shell script
# fvwm_make_browse_menu.sh in the utils
# directory of the distribution.
AddToMenu BrowseMenu
+ DynamicPopupAction Piperead \\
  'fvwm_make_browse_menu.sh BrowseMenu'
.EE

Example (Picture menu):

.EX
# Build a menu of all .jpg files in
# $HOME/Pictures
AddToMenu JpgMenu foo title
+ DynamicPopupAction Function MakeJpgMenu

AddToFunc MakeJpgMenu
+ I DestroyMenu recreate JpgMenu
+ I AddToMenu JpgMenu Pictures Title
+ I PipeRead 'for i in $HOME/Pictures/*.jpg; \\
  do echo AddToMenu JpgMenu "`basename $i`" Exec xv $i; done'
.EE

The keyword
.I MissingSubmenuFunc
has a similar meaning.  It is executed whenever you try to pop up a
sub-menu that does not exist.  With this function you can define and
destroy menus on the fly.  You can use any command after the key
word, but the name of a function defined with
.B AddToFunc
follows it, fvwm executes this command:

.EX
Function <function-name> <menu-name>
.EE

I.e. the name is passed to the function as its first argument and can
be referred to with $0.

Example:

.EX
# There is another shell script
# fvwm_make_directory_menu.sh in the utils
# directory of the distribution. To use it,
# define this function in your configuration
# file:

AddToFunc MakeMissingDirectoryMenu
+ I Exec fvwm_make_directory_menu.sh $0

AddToMenu SomeMenu
+ MissingSumbenuFunc MakeMissing DirectoryMenu
+ "Root directory" Popup /
.EE

This is another implementation of the file browser that uses sub-menus
for subdirectories.

Titles can be used within the menu. If you add the option
.I top
behind the keyword
.IR Title ,
the title will be added to the top of the menu.  If there was a title
already, it is overwritten.

.EX
AddToMenu Utilities Tools Title top
.EE

All text up to the first Tab in the menu label is aligned to the
left side of the menu, all text right of the first Tab is aligned
to the left in a second column and all text thereafter is placed
right aligned in the third column. All other Tabs are replaced by spaces.
Note that you can change this format with the
.B MenuStyle
command
.RI ( ItemFormat )
option.

If the menu-label contains an ampersand ('&'), the next character
is taken as a hot-key for the menu item. Hot-keys are underlined in
the label. To get a literal '&', insert '&&'.  Pressing the hot-key
move through the list of menu items with this hot-key or selects
an item that is the only one with this hot-key.

If the menu-label contains a sub-string which is set off by stars,
then the text between the stars is expected to be the name of an
xpm-icon or bitmap-file to insert in the menu.  To get a literal '*',
insert '**'.For example
.EX
 + Calculator*xcalc.xpm* Exec exec xcalc
.EE
inserts a menu item labeled "calculator" with a picture of a
calculator above it.  The following:
.EX
 + *xcalc.xpm*           Exec exec xcalc
.EE
Omits the "Calculator" label, but leaves the picture.

If the menu-label contains a sub-string which is set off by percent signs,
then the text between the percent signs is expected to be the name of an
xpm-icon or bitmap-file (a so called 'mini icon' to insert to the left
of the menu label. A second mini icon that is drawn at the right side of
the menu can be given in the same way. To get a literal '%', insert '%%'.
For example
.EX
 + Calculator%xcalc.xpm% Exec exec xcalc
.EE
inserts a menu item labeled "calculator" with a picture of a
calculator to the left.  The following:
.EX
 + %xcalc.xpm%           Exec exec xcalc
.EE
Omits the "Calculator" label, but leaves the picture.  The pictures
used with this feature should be small (perhaps 16x16).

If the menu-name (not the label) contains a sub-string which is set
off by at signs ("@"), then the text between them is expected to be
the name of an xpm or bitmap file to draw along the left side of the
menu (a "side pixmap"). You will probably want to use the SidePic
option of the
.B MenuStyle
command instead.  To get a literal '@', insert '@@'.  For example
.EX
AddToMenu StartMenu@linux-menu.xpm@
.EE
creates a menu with a picture in its bottom left corner.

If the menu-name contains also a sub-string set of by '^'s, then the
text between '^'s is expected to be the name a of X11 color and the
column containing the side picture will be colorized with that
color. You can set this color for a menu style using the SideColor
option of the
.B MenuStyle
command.  To get a literal '^', insert '^^'.  Example:
.EX
AddToMenu StartMenu@linux-menu.xpm@^blue^
.EE
creates a menu with a picture in its bottom left corner and colorizes
with blue the region of the menu containing the picture.

In all the above cases, the name of the resulting menu is name specified,
stripped of the substrings between the various delimiters.

.TP
.BI "ChangeMenuStyle " "menustyle menu ..."
Changes the menu style of
.IR menu " to " menustyle .
You may specified more than one menu in each call of
.BR ChangeMenuStyle .
.EX
ChangeMenuStyle pixmap1 \\
  ScreenSaverMenu ScreenLockMenu
.EE

.TP
.BI "DestroyMenu [" recreate "] " menu
Deletes a menu, so that subsequent references to it are no longer
valid.  You can use this to change the contents of a menu during an
fvwm session.  The menu can be rebuilt using AddToMenu.  The optional
parameter
.I recreate
tells fvwm not to throw away the menu completely
but to throw away all the menu items (including the title).
.EX
DestroyMenu Utilities
.EE

.TP
.BI "DestroyMenuStyle " menustyle
Deletes the menu style named
.I menustyle
and changes all menus using this style to the default style, you
cannot destroy the default menu.
.EX
DestroyMenuStyle pixamp1
.EE

.TP
.BI "Menu " menu-name " [" position "] [" double-click-action ]
Causes a previously defined menu to be popped up in a sticky manner.
That is, if the user invokes the menu with a click action instead of a
drag action, the menu will stay up.  The command
.B double-click-action
will be invoked if the user double-clicks a button (or hits the key
rapidly twice if the menu is bound to a key) when bringing up
the menu.  If the double click action is not specified, double clicking
on the menu does nothing.  However, if the menu begins with a menu
item (i.e. not with a title or a separator) and the double click action
is not given, double clicking will invoke the first item of the menu
(but only if the pointer really was over the item).

Several other commands affect menu operation.  See
.BR MenuStyle " and " SetAnimation .
When in a menu, keyboard shortcuts work as expected.  Cursor
keystrokes are also allowed.
Specifically, Tab, Meta-Tab, Cursor-Down, Ctrl-N, or Ctrl-J move
to the next item;
Shift-Tab, Shift-Meta-Tab, Cursor-Up, Ctrl-P, or Ctrl-K move to
the prior item;
Cursor-Left or Ctrl-B returns to the prior menu;
Cursor-Right or Ctrl-F pop up the next menu;
Ctrl-Cursor-Up, Shift-Ctrl-Meta-Tab and Page-Up move up five items;
Ctrl-Cursor-Down, Ctrl-Meta-Tab and Page-Down move down five items,
respectively;
Home, Shift-Cursor-Up or End, Shift-Cursor-Down move to the first or last item,
respectively;
Meta-Cursor-Up or Meta-Cursor-Down move just behind the next or
previous separator;
Shift-Crtl-Tab or Ctrl-Tab work exactly the same;
Enter, Return, or Space executes the current item;
Insert opens the 'More...' sub-menu is any;
Escape and Delete exit the current sequence of menus.

The pointer will be warped to where it was when the menu was invoked if
it was both invoked and terminated with a keystroke.

The
.I position
arguments allow to place the menu somewhere on the
screen, for example centered on the visible screen or above a title
bar.  Basically it works like this: you specify a
.I context-rectangle
and an offset to this rectangle by which the upper left corner of the menu
is moved from the upper left corner of the rectangle.  The
.I position
arguments consist of several parts:
.EX
. BI "[[context-rectangle] " "x y" " [" special-options "]"
.EE
The
.I context-rectangle
can be one of:

.in +.5i
Root
.in +.3i
the root window.
.in -.3i
Mouse
.in +.3i
a 1x1 rectangle at the mouse position.
.in -.3i
Window
.in +.3i
the window with the focus.
.in -.3i
Interior
.in +.3i
the inside of the focused window.
.in -.3i
Title
.in +.3i
the title of the focused window or icon.
.in -.3i
Button<n>
.in +.3i
button #n of the focused window.
.in -.3i
Icon
.in +.3i
the focused icon.
.in -.3i
Menu
.in +.3i
the current menu.
.in -.3i
Item
.in +.3i
the current menu item.
.in -.3i
Context
.in +.3i
the current window, menu or icon.
.in -.3i
This
.in +.3i
whatever widget the pointer is on (e.g. a corner of a window or the root window).
.in -.3i
Rectangle <geometry>
.in +.3i
the rectangle defined by
.RI < geometry >
in X geometry format.  Width and height default to 1 if omitted.
.in -.3i
.in -.5i

If the context-rectangle is omitted or illegal (e.g. "item" on a window),
"Mouse" is the default. Note that not all of these make sense under all
circumstances (e.g. "Icon" if the pointer is on a menu).

The offset values
.I x
and
.I y
specify how far the menu is
moved from it's default position. By default, the numeric value given
is interpreted as a percentage of the context rectangle's width (height),
but with a trailing 'm' the menu's width (height) is used instead.
Furthermore a trailing
.RI ' p '
changes the interpretation to mean "pixels".

Instead of a single value you can use a list of values. All additional
numbers after the first one are separated from their predecessor by
their sign. Do not use any other separators.

If x or y are prefixed with 'o<number>' where <number> is an integer, the
menu and the rectangle will be moved to overlap at the specified position
before any other offsets are applied. The menu and the rectangle will be
placed so that the pixel at <number> percent of the rectangle's width/height
is right over the pixel at <number> percent of the menu's width/height.
So 'o0' means that the top/left borders of the menu and the rectangle
overlap, with 'o100' it's the bottom/right borders and if you use 'o50'
they are centered upon each other (try it and you will see it is much
simpler than this description). The default is 'o0'. The prefix
'o<number>' is an abbreviation for '+<number>-<number>m'.

A prefix of 'c' is equivalent of 'o50'.  Examples:

.EX
# window list in the middle of the screen
WindowList Root c c

# menu to the left of a window
Menu name window -100m c+0

# popup menu 8 pixels above the mouse pointer
Popup name mouse c -100m-8p

# somewhere on the screen
Menu name rectangle 512x384+1+1 +0 +0

# centered vertically around a menu item
AddToMenu foobar-menu
 + "first item" Nop
 + "special item" Popup "another menu" item \\
                  +100 c
 + "last item" Nop

# above the first menu item
AddToMenu foobar-menu
 + "first item" Popup "another menu" item \\
                +0 -100m
.EE
Note that you can put a sub-menu far off the current menu so you could
not reach it with the mouse without leaving the menu. If the pointer
leaves the current menu in the general direction of the sub-menu the
menu will stay up.

The
.IR special-options :

.in +.5i
The
.IR animated " and " Mwm " or " Win
menu styles may move a menu somewhere else on the screen.  If you do
not want this you can add
.I Fixed
as an option. This might happen for example if you want the menu always
in the top right corner of the screen.

Where do you want a sub-menu to appear when you click on it's menu item?
The default is to place the title under the cursor, but if you want it
where the position arguments say, use the
.I SelectInPlace
option.  If you want the pointer on the title of the menu, use
.I SelectWarp
too. Note that these options apply only if the
.I PopupAsRootMenu
.B MenuStyle
option is used.

The pointer is warped to the title of a sub-menu whenever the pointer
would be on an item when the sub-menu is popped up
.RI ( fvwm
menu style) or never warped to the title at all
.RI ( Mwm " or " Win
menu styles). You can force (forbid) warping whenever the
sub-menu is opened with the
.IR WarpTitle " (" NoWarp ") option."

Note that the
.I special-options
do work with a normal menu that has no other position arguments.
.in -.5i

.TP
.BI "MenuStyle " "stylename options"
Sets a new menu style or changes a previously defined style.
The
.I stylename
is the style name; if it contains spaces or tabs it
has to be quoted. The name "*" is reserved for the default menu style.
The default menu style is used for every menu-like object (e.g. the
window created by the
.B WindowList
command) that had not be assigned a style using the
.BR ChangeMenuStyle .
See also
.BR DestroyMenuStyle .
When using monochrome color options are ignored.

.I options
is a comma separated list containing some of the
keywords Fvwm / Mwm / Win,
BorderWidth,
Foreground,
Background,
Greyed,
HilightBack / HilightBackOff,
ActiveFore / ActiveForeOff,
MenuColorset,
ActiveColorset,
GreyedColorset,
Hilight3DThick / Hilight3DThin / Hilight3DOff,
Hilight3DThickness,
Animation / AnimationOff,
Font,
MenuFace,
PopupDelay,
PopupOffset,
TitleWarp / TitleWarpOff,
TitleUnderlines0 / TitleUnderlines1 / TitleUnderlines2,
SeparatorsLong / SeparatorsShort,
TrianglesSolid / TrianglesRelief,
PopupImmediately / PopupDelayed,
DoubleClickTime,
SidePic,
SideColor,
PopupAsRootMenu / PopupAsSubmenu,
RemoveSubmenus / HoldSubmenus,
SubmenusRight / SubmenusLeft,
SelectOnRelease,
ItemFormat,
VerticalItemSpacing,
VerticalTitleSpacing,
AutomaticHotkeys / AutomaticHotkeysOff.

In the above list some options are listed as option pairs or triples
with a / in between. These options exclude each other.

.IR Fvwm ", " Mwm ", " Win
reset all options to the style with
the same name in former versions of fvwm.  The default for new menu
styles is
.I Fvwm
style. These options override all others except
.IR Foreground ", " Background ", " Greyed ", " HilightBack ", "
.IR HilightFore " and " PopupDelay ,
so they should be used only as the first option specified for a
menu style or to reset the style to defined behavior.  The same
effect can be created by setting all the other options one by one.

.IR Mwm " and " Win
style menus popup sub-menus automatically.
.I Win
menus indicate the current menu item by changing the
background to dark.
.I Fvwm
sub-menus overlap the parent menu,
.IR Mwm " and " Win
style menus never overlap the parent menu.

.I Fvwm
style is equivalent to HilightBackOff, Hilight3DThin,
ActiveForeOff, AnimationOff, Font, MenuFace, PopupOffset 0 67, TitleWarp,
TitleUnderlines1, SeparatorsShort, TrianglesRelief, PopupDelayed,
PopupAsSubmenu, HoldSubmenus, SubmenusRight, BorderWidth 2,
AutomaticHotkeysOff.

.I Mwm
style is equivalent to HilightBackOff, Hilight3DThick,
ActiveForeOff, AnimationOff, Font, MenuFace, PopupOffset -3 100,
TitleWarpOff, TitleUnderlines2, SeparatorsLong, TrianglesRelief,
PopupImmediately, PopupAsSubmenu, HoldSubmenus, SubmenusRight,
BorderWidth 2, AutomaticHotkeysOff.

.I Win
style is equivalent to HilightBack, Hilight3DOff,
ActiveForeOff, AnimationOff, Font, MenuFace, PopupOffset -5 100,
TitleWarpOff, TitleUnderlines1, SeparatorsShort, TrianglesSolid,
PopupImmediately, PopupAsSubmenu, RemoveSubmenus, SubmenusRight,
BorderWidth 2, AutomaticHotkeysOff.

.I BorderWidth
takes the thickness of the border around the menus
in pixels. It may be zero to 50 pixels. The default is 2. Using an
illegal value reverts the border width to the default.

.IR Foreground " and " Background
may have a color name as an argument.  This color is used for
menu text or the menu's background.  You can omit the color name
to reset these colors to the built in default.

.I Greyed
may have a color name as an argument. This color is the
one used to draw a menu-selection which is prohibited (or not
recommended) by the mwm-hints which an application has specified.
If the color is omitted the color of greyed menu entries is based
on the background color of the menu.

.IR HilightBack " and " HilightBackOff
switch hilighting the background of the selected menu item on
and off. A specific background color may be used by providing
the color name as an argument to
.IR HilightBack .
If you use this option without an argument the color is based on
the menu's background color.

.I ActiveFore " and " ActiveForeOff
switch hilighting the foreground of the selected menu item on
and off. A specific foreground color may be used by providing
the color name as an argument to
.IR ActiveFore .
Omitting the color name has the same effect as using
.IR ActiveForeOff .

.I MenuColorset
controls if a colorset is used instead of the
.IR Foreground ", " Background " and " MenuFace
menu styles.  If the
.I MenuColorset
keyword is followed by a number equal to zero or greater, this
number is taken as the number of the colorset to use.  If the
number is omitted, the colorset is switched off and the regular
menu styles are used again.  The foreground and background
colors of the menu items are replaced by the colors from the
colorset.  If the colorset has a pixmap defined, this pixmap is
used as the background of the menu.  Note that the MenuFace
menu style has been optimized for memory consumption and may use
less memory than the background from a colorset.  The shape mask
from the colorset is used to shape the menu.  Please refer to the
description of the
.B Colorset
command and the documentation of the
.B FvwmTheme
module for details about colorsets.

.I ActiveColorset
works exactly like
.IR MenuColorset ,
but the foreground from the colorset replaces the color given with the
.I ActiveFore
menu style and the colorset's background color replaces the color
given with the
.B HilightBack
command.  The pixmap and shape mask from the colorset are not used.

.I GreyedColorset
works exactly like
.IR MenuColorset ,
but the foreground from the colorset replaces the color given with the
.I Greyed
menu style.  No other parts of the colorset are used.

.IR Hilight3DThick ", " Hilight3DThin " and " Hilight3DOff
determine if the selected menu item is hilighted with a 3D relief.
Thick reliefs are two pixels wide, thin reliefs are one pixel wide.
.I Hilight3DThickness
takes one numeric argument that may be between zero and 50 pixels.
The above three commands are equivalent to a thickness of 2, 1 and 0.

.IR Animation " and " AnimationOff
turn menu animation on or off.  When animation is on, sub-menus
that don't fit on the screen cause the parent menu to be shifted
to the left so the sub-menu can be seen.

.I Font
takes a font name as an argument.  If a font by this name
exists it is used for the text of all menu items.  If it does not
exist or if the name is left blank the built in default is used.

.I MenuFace
enforces a fancy background upon the menus.  You can use the same
options for
.I MenuFace
as for the
.BR ButtonStyle .
See description of
.B ButtonStyle
command and the
.B COLOR GRADIENTS
sections for more information.  If you use
.I MenuFace
without arguments the style is reverted back to normal.

Some examples of MenuFaces are:

.EX
MenuFace DGradient 128 2 lightgrey 50 blue 50 \\
  white
MenuFace TiledPixmap texture10.xpm
MenuFace HGradient 128 2 Red 40 Maroon 60 \\
  White
MenuFace Solid Maroon
.EE

Note: The gradient styles H, V, B and D are optimized for high
speed and low memory consumption in menus.  This is not the case
for all the other gradient styles.  They may be slow and consume
huge amounts of memory, so if you encounter performance problems
with them you may be better off by not using them. To improve
performance you can try one or all of the following:

Turn Hilighting of the active menu item other than foreground color
off:

.EX
MenuStyle <style> Hilight3DOff, HilightBackOff
MenuStyle <style> ActiveFore <preferred color>
.EE

Make sure sub-menus do not overlap the parent menu. This can prevent
menus being redrawn every time a sub-menu pops up or down.

.EX
MenuStyle <style> PopupOffset 1 100
.EE

Run you X server with backing storage. If your Xserver is started
with the -bs option, turn it off. If not try the -wm option.

.EX
startx -- -wm
.EE

You may have to adapt this example to your system (e.g. if you
use xinit to start X).

.I PopupDelay
requires one numeric argument. This value is the
delay in milliseconds before a sub-menu is popped up when the
pointer moves over a menu item that has a sub-menu. If the value
is zero no automatic pop up is done. If the argument is omitted
the built in default is used. Note that the popup delay has no
effect if the
.I PopupImmediately
option is used since sub-menus pop up immediately then. The
.I PopupDelay
option should only be applied to the default style ("*") since
it is a global setting and affects all menus.

.I PopupImmediately
makes menu items with sub-menus pop up it up as soon as the
pointer enters the item.  The
.I PopupDelay option
is ignored then.  If
.I PopupDelayed
is used fvwm looks at the
.I PopupDelay
option if or when this automatic popup happens.

.I PopupOffset
requires two integer arguments.  Both values affect
where sub-menus are placed relative to the parent menu. If both
values are zero, the left edge of the sub-menu overlaps the left edge
of the parent menu. If the first value is non-zero the sub-menu is
shifted that many pixels to the right (or left if negative).  If the
second value is non-zero the menu is moved by that many percent of
the parent menu's width to the right or left.

.IR TitleWarp " and " TitleWarpOff
affect if the pointer warps to the menu title when a sub-menu
is opened or not. Note that regardless of this setting the
pointer will not be warped if the menu does not pop up under
the pointer.

.IR TitleUnderlines0 ", " TitleUnderlines1 " and " TitleUnderlines2
specify how many lines are drawn below a menu title.

.IR SeparatorsLong " and " SeparatorsShort
set the length of menu separators.  Long separators run from
the left edge all the way to the right edge. Short separators
leave a few pixels to the edges of the menu.

.IR TrianglesSolid " and " TrianglesRelief
affect how the small triangles for sub-menus is drawn. Solid
triangles are filled with a color while relief triangles are hollow.

.I DoubleClickTime
requires one numeric argument.  This value is the
time in milliseconds between two mouse clicks in a menu to be
considered as a double click.  The default is 450 milliseconds.
If the argument is omitted the double click time is reset to this
default.  The
.I DoubleClickTime
option should only be applied to the default style ('*') since it
is a global setting and affects all menus.

.I SidePic
takes the name of an xpm or bitmap file as an argument.
The picture is drawn along the left side of the menu.  The
.I SidePic
option can be overridden by a menu specific side pixmap (see
.BR AddToMenu ).
If the file name is omitted an existing side pixmap is remove
from the menu style.

.I SideColor
takes the name of an X11 color as an argument. This
color is used to colorize the column containing the side picture
(see above). The SideColor option can be overridden by a menu
specific side color (see
.BR AddToMenu ).
If the color name is omitted the side color option is switched off.

.IR PopupAsRootMenu " and " PopupAsSubmenu
change the behavior when you click on a menu item that opens a
sub-menu. With
.I PopupAsRootMenu
the original menu is closed before the sub-menu appears, with
.I PopupAsSubmenu
it is not, so you can navigate back into the
parent menu.  Furthermore, with
.I PopupAsSubmenu
the sub-menu is held open ("posted") regardless of where you move
the mouse.  Depending on your menu style this may simplify
navigating through the menu. Any keystroke while a menu is posted
reverts the menu back to the normal behavior.
.I PopupAsSubmenu
is the default.

.I RemoveSubmenus
instructs fvwm to remove submenus when you move back
into the parent menu. With
.I HoldSubmenus
the sub-menu remains visible.  You will probably want to use
.I HoldSubmenus
if you are using the
.I PopupDelayed
style.

.I SelectOnRelease
takes an optional key name as an argument.  If the given key is
release in a menu using this style, the current menu item is
selected.  This is intended for
.SM Alt-Tab
.B WindowList
navigation.
The key name is a standard X11 key name as defined in
.IR /usr/include/X11/keysymdef.h ,
with the leading "XK_" omitted.  To disable this behaviour, omit the
key name.

Note: Some X servers do not support KeyRelease events.
.I SelectOnRelease
does not work on such a machine.

.I ItemFormat
takes a special string as its argument that determines the layout
of the menu items.  Think of the format string as if it were a
menu item.  All you have to do is tell fvwm where to place the different
parts of the menu item (i.e. the labels, the triangle denoting a sub
menu, the mini icons and the side pic) in the blank area.  The string
consists of spaces, tabs and formatting directives beginning with '%'.
Any illegal characters and formatting directives are silently ignored:

.in +.5i
.BR %l ", " %c " and " %r
.in +.3i
Insert the next item label.  Up to three labels can be used.
The item column will be left-aligned
.RB ( %l ),
centered
.RB ( %c )
or right-aligned
.RB ( %r ).
.in -.3i
.B %i
.in +.3i
Inserts the mini icon.
.in -.3i
.BR %> " and " %<
.in +.3i
Insert the sub-menu triangle pointing either to the right
.RB ( %> )
or to the left
.RB ( %< )
.in -.3i
.B %|
.in +.3i
The first
.B %|
denotes the beginning of the area that will be highlighted either
with a background color or a relief (or both).  The second
.B %|
marks the end of this area.
.B %|
can be used up to twice in the string.  If you don't add one
or both of them, fvwm will set the margins to the margins of
the whole item (not counting the side picture).
.in -.3i
.B %s
.in +.3i
Places the side picture either at the beginning or the end of the menu.
This directive may be used only once and only as the first or last
in the format string. If the '%s' is not at the beginning of the
string, all characters to the right of it are silently ignored.
.in -.3i
.BR space " and " tab
.in +.3i
Add a gap as large as a space or tab is with the font you use in the
menu items.  Don't forget to put the whole string in double quotes if
you use spaces or tabs.
.in -.3i
.B %p
.in +.3i
Like space and tab
.B %p
inserts an empty area into the item, but with better control of
its size (see below).
.in -.3i
.in -.5i

You can define an additional space before and after each of the objects
like this:
.EX
.BI % left . right p
.EE

This means: if the object is defined in the menu (e.g. if its
.B %s and you use a side picture or
.B %l
for the third column and there are items defined that actually
have a third column), then add
.I left
pixels before the object and
.I right
pixels after it.  You may leave out the
.I left
or the
.I .right
parts if you don't need them.  All values between zero (not
very useful) and your screen width are allowed.

Note: Only items defined in the format string are visible in the menus.
I.e. if you don't put a
.B %s
in there you will not see a side picture, even if you use one.

Note: The
.I SubmenusLeft
style changes the default
.I ItemFormat
string, but if you set one manually it is not modified.

Examples:

.EX
MenuStyle * ItemFormat \\
  "%.4s%.1|%.5i%.5l%.5l%.5r%.5i%2.3>%1|"
.EE
Is the default string used by fvwm: (side picture + 4 pixels gap)
(begin of the hilighted area + 1 pixel gap) (mini icon + 5p)
(first column left aligned + 5p) (second column left aligned + 5p)
(third column right aligned) (second mini icon + 5p)
(2p + sub-menu triangle + 3p) (1p + end of hilighted area).
.EX
MenuStyle * ItemFormat \\
  "%.1|%3.2<%5i%5l%5l%5r%5i%1|%4s"
.EE
Is used by fvwm with the
.I SubmenusLeft
option below.

.IR VerticalItemSpacing " and " VerticalTitleSpacing
control the vertical spacing of menu items and titles like
.I ItemFormat
controls the horizontal spacing.  Both take two numeric arguments
that may range from -5 to +100.  The first is the gap in pixels
above a normal menu item (or a menu title), the second is the gap
in pixels below it.  Negative numbers do not make much sense and may
screw up your menu completely.  If no arguments are given or the
given arguments are invalid, the built in defaults are used: one pixel
above the item or title and two below.

.I SubmenusLeft
mirrors the menu layout and behavior. sub-menus pop up
to the left, the sub-menu triangle is drawn left and the mini icon and
side picture are drawn at the right side of the menu. The default is
.IR SubmenusRight .
The position hints of a menu are also affected by this setting, i.e.
position hints using
.IR item " or " menu
as context rectangle and position hints using
.I m
offsets.

.IR AutomaticHotkeys " and " AutomaticHotkeysOff
control the menu's ability to automatically provide hot-keys
on the first character of each menu item's label.  This behavior
is always overridden if an explicit hot-key is assigned in the
.B AddToMenu
command.

Examples:

.EX
MenuStyle * Mwm
MenuStyle * Foreground Black, Background gray40
MenuStyle * Greyed gray70, ActiveFore White
MenuStyle * HilightBackOff, Hilight3DOff
MenuStyle * Font lucidasanstypewriter-14
MenuStyle * MenuFace DGradient 64 darkgray \\
  MidnightBlue

MenuStyle red Mwm
MenuStyle red Foreground Yellow
MenuStyle red Background Maroon
MenuStyle red Greyed Red, ActiveFore Red
MenuStyle red HilightBackOff, Hilight3DOff
MenuStyle red Font lucidasanstypewriter-12
MenuStyle red MenuFace DGradient 64 Red Black
.EE

Note that all style options could be placed on a single line for each
style name.

.TP
.BI "MenuStyle " "forecolor backcolor shadecolor font style" " [" anim "]"
This is the old syntax of the
.B MenuStyle
command. It is obsolete and may be removed in the future.  Please
use the new syntax as described above.

Sets the menu style.  When using monochrome the colors are ignored.
The
.I shadecolor
is the one used to draw a menu-selection which is
prohibited (or not recommended) by the mwm-hints which an application
has specified.  The style option is either
.IR Fvwm ", " Mwm " or " Win ,
which changes the appearance and operation of the menus.

.IR Mwm " and " Win
style menus popup sub-menus automatically.
.I win
menus indicate the current menu item by changing the background to black.
.I fvwm
sub-menus overlap the parent menu,
.IR Mwm " and " win
style menus never overlap the parent menu.

When the
.I anim
option is given, sub-menus that don't fit on the screen cause
the parent menu to be shifted to the left so the sub-menu can be seen.
See also
.B SetAnimation
command.

.TP
.BI "Popup " PopupName " [" position "] [" default-action "]"
This built-in has two purposes: to bind a menu to a key or mouse
button, and to bind a sub-menu into a menu.  The formats for the two
purposes differ slightly.  The
.I position
arguments are the same
as for
.BR Menu .
The command
.I default-action
will be invoked if the user clicks a button to invoke the menu
and releases it immediately again (or hits the key rapidly twice
if the menu is bound to a key).  If the default action is not
specified, double clicking on the menu does nothing.  However,
if the menu begins with a menu item (i.e. not with a title or a
separator) and the default action is not given, double clicking
will invoke the first item of the menu (but only if the pointer
really was over the item).

To bind a previously defined pop-up menu to a key or mouse button:
.sp
.in +.25i
The following example binds mouse buttons 2 and 3 to a pop-up called
"Window Ops".  The menu will pop up if the buttons 2 or 3 are pressed
in the window frame, side-bar, or title-bar, with no modifiers (none
of shift, control, or meta).
.EX
Mouse 2 FST N Popup "Window Ops"
Mouse 3 FST N Popup "Window Ops"
.EE
Pop-ups can be bound to keys through the use of the
.B Key
built-in.  Pop-ups can be operated without using the mouse by
binding to keys and operating via the up arrow, down arrow,
and enter keys.
.in -.25i
.sp
To bind a previously defined pop-up menu to another menu, for use as a
sub-menu:
.sp
.in +.25i
The following example defines a sub-menu "Quit-Verify" and binds it
into a main menu, called "RootMenu":
.EX
AddToMenu Quit-Verify
 + "Really Quit Fvwm?" Title
 + "Yes, Really Quit"  Quit
 + "Restart Fvwm"      Restart
 + "Restart Fvwm 1.xx" Restart fvwm -s
 + ""                  Nop
 + "No, Don't Quit"    Nop

AddToMenu RootMenu "Root Menu" Title
 + "Open XTerm Window" Popup NewWindowMenu
 + "Login as Root"     Exec exec xterm \\
                         -fg green -T Root \\
                         -n Root -e su -
 + "Login as Anyone"   Popup AnyoneMenu
 + "Remote Hosts"      Popup HostMenu
 + ""                  Nop
 + "X utilities"       Popup Xutils
 + ""                  Nop
 + "Fvwm Modules"      Popup Module-Popup
 + "Fvwm Window Ops"   Popup Window-Ops
 + ""                  Nop
 + "Previous Focus"    Prev (*) Focus
 + "Next Focus"        Next (*) Focus
 + ""                  Nop
 + "Refresh screen"    Refresh
 + "Recapture screen"  Recapture
 + ""                  Nop
 + "Reset X defaults"  Exec xrdb -load \\
                       $HOME/.Xdefaults
 + ""                  Nop
 + ""                  Nop
 + Quit                Popup Quit-Verify
.EE
.in -.25i
.sp
.B Popup
differs from
.B Menu
in that pop-ups do not stay up if the user simply clicks.  These
are twm style popup-menus, which are a little hard on the wrist.
Menu provides Motif or Microsoft-Windows style menus which will
stay up on a click action.  See
.B Menu
command for an explanation of the interactive behavior of menus.
Note that a menu can be open only once, so a menu may not use
itself or any of its predecessors as a sub-menu.

.TP
.B "Title"
Does nothing.  This is used to insert a title line in a popup or menu.


.SH KEYBOARD SHORTCUTS
Almost all window manager operations can be performed from the
keyboard so mouse-less operation should be possible.  In addition to
scrolling around the virtual desktop by binding the
.B Scroll
built-in to appropriate keys,
.BR Popup ", " Move ", " Resize ", "
and most other built-ins can be bound to keys.  Once a built in
function is started the pointer is moved by using the up, down,
left, and right arrows, and the action is terminated by pressing
return.  Holding down the
.SM shift
key will cause the pointer movement to go in larger steps and
holding down the
.SM control
key will cause the cursor movement to go in smaller steps.
Standard emacs and vi cursor movement controls (^n, ^p, ^f, ^b, and
^j, ^k, ^h, ^l) can be used instead of the arrow keys.


.SH SUPPLIED CONFIGURATION
A sample configuration file,
.IR .fvwm2rc ,
is supplied with the fvwm distribution.  It is well commented and can
be used as a source of examples for fvwm configuration.


.SH USE ON MULTI-SCREEN DISPLAYS
If the
.B -s
command line argument is not given, fvwm will automatically
start up on every screen on the specified display.  After fvwm
starts each screen is treated independently.  Restarts of fvwm
need to be performed separately on each screen.  The use of
.B "EdgeScroll 0 0"
is strongly recommended for multi-screen displays.  You may need
to quit on each screen to quit from the X session completely.

.SH SESSION MANAGEMENT
Fvwm supports session management according to the X Session Management
Protocol.  It saves and restores window position, size, stacking order,
desk, stickiness, shadedness, maximizedness, iconifiedness for all windows.
Furthermore, some global state is saved.

Fvwm doesn't save any information regarding styles, decors,
functions or menus.  If you change any on these resources during
a session (e.g. by issuing
.B Style
commands or by using various modules), these changes will be lost
after saving and restarting the session.  To become permanent, such
changes have to be added to the configuration file.

Note further that the current implementation has the following
anomaly when used on a multi-screen display: Starting fvwm
for the first time, it will manage all screens by forking a copy
of itself for each screen.  Every copy knows its parent and issuing a
.B Quit
command to any instance of fvwm will kill the master and
thus all copies of fvwm.  When you save and restart the session,
the session manager brings up a copy of fvwm on each screen, but
this time they are started as individual instances managing one
screen only.  Thus a
.B Quit
will now kill only the copy it was sent to.  This is probably not
a very serious problem, since with session management, you are
supposed to quit a session through the session manager anyway. If
it is really needed,
.B "Exec exec killall fvwm2"
will still kill all copies of fvwm.  Your system must have the
.B killall
command though.


.SS MISCELLANEOUS COMMANDS

.TP
.BI "BugOpts [" option " [" bool "]], " ...
This command controls several workarounds for bugs in third party
programs.  The individual options are separated by commas.  The
optional argument
.I bool
is a boolean argument and controls if the bug workaround is
enabled or not.  It can either be
"True" or "False" to turn the option on or off, or "toggle" to
switch is back and forth.  If
.I bool
is omitted, the default setting is restored.

.I FlickeringMoveWorkaround
disables so called "ConfigurNotify" events that are usually sent
to an application while it is moved.  If some windows flicker
annoyingly while being moved, this option may help you.  Note
that if this problem occurs its not a fvwm bug, it is the fault
of the application.

.I MixedVisualWorkaround
makes fvwm install the root colormap before it does some operations
using the root window visuals.  This is only useful when the
.B -visual
option is used to start fvwm and then only with some configurations
of some servers (e.g. Exceed 6.0 with an 8 bit PseudoColor root and
fvwm using a 24 bit TrueColor visual).

The
.I ModalityIsEvil
option controls if motif applications have the ability to have modal
dialogs (dialogs that force you to close them first before you can
do anything else).  The default is to not allow applications to have
modal dialogs.  Use this option with care.

.I RaiseOverNativeWindows
makes fvwm try to raise the windows it manages over native windows
of the X servers host system.  This is needed for some X servers
running under Windows or Windows NT.  Fvwm tries to detect
if it is running under such an X server and initializes the flag
accordingly.  This is the same option as the one listed under the
.B GlobalOpts
command.

.I RaiseOverUnmanaged makes fvwm try to raise the windows it manages
over override_redirect windows.  This is used to cope with ill-mannered
applications that use long-lived windows of this sort, contrary to
.SM ICCCM
conventions.

.TP
.BI "BusyCursor [" "Option bool" "], " ...
This command controls the cursor during the execution of certain
commands.
.I Option
can be
.IR DynamicMenu ", " ModuleSynchronous ", " Read ", " Recapture ,
.IR Wait ", " * .
An option must be followed by a boolean argument
.IR bool .
You can use commas to separate individual options.  If you set an
option to "True", then when the corresponding command is run, fvwm
displays the cursor of the
.I WAIT
context of the
.B CursorStyle
command.  "False" forces to not display the cursor.  The default is:
DynamicMenu False, ModuleSynchronous False, Read False,
Recapture True, Wait False.

The option
.I *
refers to all available options.

The
.I Read
option also controls the
.B PipeRead
command.

The
.I DynamicMenu
option affects the
.I DynamicPopupAction
and
.I MissingSubmenuFunc
options of the
.B AddToMenu
command.  If this option is set to "False", then the busy cursor is
not displayed during a dynamic menu command even if this
command is a
.IR Read " or " PipeRead
command and the
.I Read
option is set to "True".

The
.I Wait
option affects only the root cursor.  During a wait pause the root cursor
is replaced by the busy cursor and fvwm is still fully functional (you can
escape from the pause, see the
.B EscapeFunc
command).  If you want to use this option and if you do not use the
default root cursor, you must set your root cursor with the
.B CursorStyle
command.

.TP
.BI "ClickTime [" delay "]"
Specifies the maximum delay in milliseconds between a button press
and a button release for the
.B Function
built-in to consider the action a mouse click.  The default delay
is 150 milliseconds.  Omitting the delay value resets the
.B ClickTime
to the default.

.TP
.BI "ColorLimit " limit
Specifies a limit  on the colors used in  pixmaps used  by fvwm.
Zero (the default) sets no limit.  Fvwm uses pixmaps for icons,
mini-icons, and pixmap borders, menu backgrounds and titles.
This command limits pixmap colors to a set of colors that starts
out with common colors.  The current list contains about 60 colors
and starts with white, black, grey, green, blue, red, cyan, yellow,
and magenta.  The command
.EX
ColorLimit 9
.EE
would limit pixmaps to these 9 colors.

It makes the most sense to put this command at the front of the
.I .fvwm2rc
file.  This command should occur before any menu definitions
that contain mini-icons.

Solid frame and title colors (including shadows and gradients) are not
controlled by this command.

This command only makes sense on screens that display a limited
number of colors at once.  If your  display can display more
than 2 million colors at once, this command is ignored.  Screens
that only display 256 colors at once are known as 8 bit displays.
The 2 million color cutoff point corresponds to 21 bit color,
the most common screen that exceeds this limit would be 24 bit.

On 8 bit displays, the default color limit is set to the size of
the built in table (about 60).  We recommend that you start with the
default value, and not include this command in your
.IR .fvwm2rc .

.TP
.BI "ColormapFocus " FollowsMouse | FollowsFocus
By default, fvwm installs the colormap of the window that the cursor
is in.  If you use
.B ColormapFocus
.IR FollowsFocus ,
then the installed colormap will be the one for the window that
currently has the keyboard focus.

.TP
.BI "CursorStyle " context " [" number | name | xpm | None | Tiny " [" "fore back" "]]"
Defines a new cursor for the specified context.  The various contexts
are:

.in +.5i
.BR POSITION (top_left_corner)
.in +.3i
used when initially placing windows
.in -.3i

.BR TITLE (top_left_arrow)
.in +.3i
used in a window title-bar
.in -.3i

.BR DEFAULT (top_left_arrow)
.in +.3i
used in windows that don't set their cursor
.in -.3i

.BR SYS (hand2)
.in +.3i
used in one of the title-bar buttons
.in -.3i

.BR MOVE (fleur)
.in +.3i
used when moving or resizing windows
.in -.3i

.BR RESIZE (sizing)
.in +.3i
used when moving or resizing windows
.in -.3i

.BR WAIT (watch)
.in +.3i
used during certain fvwm commands (see BusyCursor for details).
.in -.3i

.BR MENU (top_left_arrow)
.in +.3i
used in menus
.in -.3i

.BR SELECT (crosshair)
.in +.3i
used when the user is required to select a window
.in -.3i

.BR DESTROY (pirate)
.in +.3i
used for DESTROY, CLOSE, and DELETE built-ins
.in -.3i

.BR TOP (top_side)
.in +.3i
used in the top side-bar of a window
.in -.3i

.BR RIGHT (right_side)
.in +.3i
used in the right side-bar of a window
.in -.3i

.BR BOTTOM (bottom_side)
.in +.3i
used in the bottom side-bar of a window
.in -.3i

.BR LEFT (left_side)
.in +.3i
used in the left side-bar of a window
.in -.3i

.BR TOP_LEFT (top_left_corner)
.in +.3i
used in the top left corner of a window
.in -.3i

.BR TOP_RIGHT (top_right_corner)
.in +.3i
used in the top right corner of a window
.in -.3i

.BR BOTTOM_LEFT (bottom_left_corner)
.in +.3i
used in the bottom left corner of a window
.in -.3i

.BR BOTTOM_RIGHT (bottom_right_corner)
.in +.3i
used in the bottom right corner of a window
.in -.3i

.BR TOP_EDGE (top_side)
.in +.3i
used at the top edge of the screen.
.in -.3i

.BR RIGHT_EDGE (right_side)
.in +.3i
used at the right edge of the screen.
.in -.3i

.BR BOTTOM_EDGE (bottom_side)
.in +.3i
used at the bottom edge of the screen.
.in -.3i

.BR LEFT_EDGE (left_side)
.in +.3i
used at the left edge of the screen.
.in -.3i

.BR ROOT (left_ptr)
.in +.3i
used as the root cursor.
.in -.3i

.BR STROKE (plus)
.in +.3i
used during a StrokeFunc command.
.in -.3i
.in -.5i

The defaults are shown in parentheses above.  Is you ever want to
restore the default cursor for a specific context you can omit the
second argument.

The second is either the numeric value of the cursor as defined in
the include file
.I X11/cursorfont.h
or its name (without the XC_ prefix) or the name of an xpm file
containing a pixmap of depth 1 with a mask and an optional hot-spot
(if no hot-spot is defined, the hot-spot is placed in the center of
the image).  Furthermore the name can be "None" (no cursor) or "Tiny"
(a single pixel as the cursor).  For example:
.EX
# make the kill cursor be XC_gumby (both forms work):
CursorStyle DESTROY 56
CursorStyle DESTROY gumby

CursorStyle TOP_LEFT topl.xpm
CursorStyle ROOT hand1 yellow black
.EE

The optional
.IR fg " and " bg
arguments specify the foreground and background colors for the
cursor, defaulting to black and white.

.TP
.BI "DefaultColors [" "foreground background" "]"
.B DefaultColors
sets the default foreground and background
colors used in miscellaneous windows created by fvwm, for example
in the geometry feedback windows during a move or resize operation.
If you don't want to change one color or the other, use - as its
color name.  To revert to the builtin default colors omit both
color names.  Note that the default colors are not used in menus,
window titles or icon titles.

.TP
.BI "DefaultColorset [" num "]"
.B DefaultColorset
sets the colorset used by the windows controlled by the
.B DefaultColors command.  To revert back to the
.B DefaultColors colors use
.EX
.EE DefaultColorset -1
or any variant of the
.B DefaultColors
command.

.TP
.BI "DefaultFont [" fontname "]"
.B DefaultFont
sets the default font to font
.IR fontname .
The default font is used by fvwm whenever no other font has been
specified.  To reset the default font to the built in default, omit
the argument.  The default font is used for menus, window titles,
icon titles as well as the geometry feedback windows during a move
or resize operation.  To override the default font in a specific
context, use the
.BR "Style * Font" ", " "Style * IconFont" ", or " MenuStyle commands.

.TP
.BI "DefaultIcon " filename
sets the default icon which is used if a window has neither an
client-supplied icon nor an icon supplied via the
.I Icon
option of the
.B Style
command.

.TP
.BI "DefaultLayers " "bottom put top"
changes the layers that are used for the
.IR StaysOnBottom ", " StaysPut ", " StaysOnTop
.B Style
options.  Initially, the layers 2, 4 and 6 are used.

.TP
.BI "Emulate " Fvwm | Mwm | Win
This command affects how miscellaneous things are done by fvwm.
For example where the move/resize feedback window appears depends
on this command.  To have more Mwm- or Win-like behavior you can call
Emulate with
.IR Mwm " or " Win
as its argument.  With
.I Mwm
resize and move feedback windows are in the center of the
screen, instead of the upper left corner.

.TP
.BI "EscapeFunc"
By default the key sequence
.SM Ctrl-Alt-Escape
allows to escape from a
.B Wait
pause and from a locked
.B ModuleSynchronous
command.  The
.B EscapeFunc
command used with the
.B Key
command allows to configure this key sequence.  An example:
.EX
Key Escape A MC -
Key Escape A  S EscapeFunc
.EE
replaces the
.SM Ctrl-Alt-Escape
key sequence with
.SM Shift-Escape
for aborting a
.B Wait
pause and
.B ModuleSynchronous
command.
.B EscapeFunc
used outside the
.I Key
command does nothing.

.TP
.BI "GlobalOpts [" options "]"
As announced in the past, this command has been removed.  Please replace
the global options in your configuration file according to thie
following table:

.EX
WindowShadeShrinks
  --> Style * WindowShadeShrinks
WindowShadeScrolls
  --> Style * WindowShadeScrolls
SmartPlacementIsReallySmart
  --> Style * CleverPlacement
SmartPlacementIsNormal
  --> Style * SmartPlacement
ClickToFocusDoesntPassClick
  --> Style * ClickToFocusPassesClickOff
ClickToFocusPassesClick
  --> Style * ClickToFocusPassesClick
ClickToFocusDoesntRaise
  --> Style * ClickToFocusRaisesOff
ClickToFocusRaises
  --> Style * ClickToFocusRaises
MouseFocusClickDoesntRaise
  --> Style * MouseFocusClickRaisesOff
MouseFocusClickRaises
  --> Style * MouseFocusClickRaises
NoStipledTitles
  --> Style * StipledTitleOff
StipledTitles
  --> Style * StipledTitle
CaptureHonorsStartsOnPage
  --> Style * CaptureHonorsStartsOnPage
CaptureIgnoresStartsOnPage
  --> Style * CaptureIgnoresStartsOnPage
RecaptureHonorsStartsOnPage
  --> Style * RecaptureHonorsStartsOnPage
RecaptureIgnoresStartsOnPage
  --> Style * RecaptureIgnoresStartsOnPage
ActivePlacementHonorsStartsOnPage
  --> Style * ActivePlacementHonorsStartsOnPage
ActivePlacementIgnoresStartsOnPage
  --> Style * ActivePlacementIgnoresStartsOnPage
RaiseOverNativeWindows
  --> BugOpts RaiseOverNativeWindows on
IgnoreNativeWindows
  --> BugOpts RaiseOverNativeWindows off
.EE

.TP
.BI "HilightColor " "textcolor backgroundcolor"
This command is obsoleted by the
.B Style options
.IR HilightFore " and " HilightBack .
Please use
.EX
Style * HilightFore textcolor, \\
        HilightBack backgroundcolor
.EE
instead.

.TP
.BI "HilightColorset [" num "]"
This command is obsoleted by the
.B Style
option
.IR HilightColorset .
Please use
.EX
Style * HilightColorset num
.EE
instead.

.TP
.BI "IconFont [" fontname "]"
This command is obsoleted by the
.B Style
option
.IR IconFont .
Please use
.EX
Style * IconFont fontname
.EE
instead.

.TP
.BI "IconPath " path
This command is obsolete.  Please use
.B ImagePath
instead.

.TP
.BI "ImagePath " path
Specifies a colon separated list of directories in which to search
for images (both monochrome and pixmap).  To find an image given by
a relative pathname, fvwm looks into each directory listed in turn,
and uses the first file found.

The
.I path
may contain environment variables such as
.IR $HOME " (or " ${HOME} ).
Further, a '+' in the
.I path
is expanded to the previous value of the path, allowing appending
or prepending to the path easily.

For example:
.EX
ImagePath $HOME/icons:+:/usr/include/X11/bitmaps
.EE

Note: if the
.B FvwmM4
module is used to parse your
.I .fvwm2rc
files, then
.B m4
may want to mangle the word "include" which will frequently show up in the
.B ImagePath
command.  To fix this one may add
.EX
undefine(`include')
.EE
prior to the
.B ImagePath
command, or better: use the
.I -m4-prefix
option to force all
.B m4
directives to have a prefix of "m4_" (see the
.B FvwmM4
man page).

.TP
.BI "PixmapPath " path
This command is obsolete. Please use
.B ImagePath
instead.

.TP
.BI "WindowFont [" fontname "]"
This command is obsoleted by the
.B Style
option
.IR Font .  Please use
.EX
Style * Font fontname
.EE
instead.

.TP
.BI "WindowList [(" conditions ")] [" position "] [" options "] [" double-click-action "]"
Generates a pop-up menu (and pops it up) in which the title and
geometry of each of the windows currently on the desktop are shown.
The format of the geometry part is:
. IR desk ( layer "): " "x-geometry sticky" ,
where
.IR desk " and " layer
are the corresponding numbers and
.I sticky
is empty or a capital S.  The geometry of iconified windows is
shown in parenthesis.  Selecting an item from the window list
pop-up menu will by default cause the interpreted function
"WindowListFunc" to be run with the window id of that window passed
in as $0.  By default the "WindowListFunc" looks like this:
.EX
AddToFunc WindowListFunc
 + I WindowId $0 Iconify off
 + I WindowId $0 FlipFocus
 + I WindowId $0 Raise
 + I WindowId $0 WarpToWindow 5p 5p
.EE
You can destroy the builtin "WindowListFunc" and create your own if
these defaults do not suit you.

The window list menu uses the "WindowList" menu style if it is
defined (see
.B MenuStyle
command).  Otherwise the default menu style is used.  To switch back
to the default menu style, issue the command
.BR "DestroyMenuStyle WindowList" .
Example:

.EX
MenuStyle WindowList SelectOnRelease Meta_L
.EE

The
.I conditions
can be used to exclude certain windows from the window list.
Please refer to the
.B Current
command for details.  Only windows that match the given conditions
are displayed in the window list.  The
.I options
below work vice versa: windows that would otherwise not be included
in the window list can be selected with them.  The
.I conditions
always override the
.IR options .


The
.I position
arguments are the same as for
.BR Menu .
The command
.I double-click-action
will be invoked if the user double-clicks (or hits the key rapidly
twice if the menu is bound to a key) when bringing the window list.  The
.I double-click-action
must be quoted if it consists of more than one word.

The
.I double-click-action
is useful to define a default window if you have bound the window
list to a key (or button) like this:
.EX
Key Tab A M WindowList "Prev FlipFocus"
.EE
Hitting
.SM Alt-Tab
once it brings up the window list, if you hit it twice the focus
is flipped between the current and the last focused window.  With
the proper
.I SelectOnRelease
menu style (see example above) a window is selected as soon as you
release the
.SM Alt
key.

The
.I options
passed to WindowList can be
.IR NoGeometry ,
.IR NoGeometryWithInfo ,
.IR Function funcname ,
.IR Desk desknum ,
.IR CurrentDesk ,
.IR NoIcons " / " Icons " / " OnlyIcons ,
.IR NoNormal " / " Normal " / " OnlyNormal ,
.IR NoSticky " / " Sticky " / " OnlySticky ,
.IR NoOnTop " / " OnTop " / " OnlyOnTop ,
.IR NoOnBottom " / " OnBottom " / " OnlyOnBottom ,
.IR "Layer m [n]" ,
.IR UseListSkip " / " OnlyListSkip ,
.IR NoDeskSort ,
.IR UseIconName ,
.IR Alphabetic " / " NotAlphabetic ,
.IR NoHotkeys .

(Note - normal means not iconic, sticky, or on top)

If you pass in a function via
.IR "Function funcname" ,
$0 is the window id:
.EX
AddToFunc IFunc I WindowId $0 Iconify toggle
WindowList Function IFunc, NoSticky, \\
  CurrentDesk, NoIcons
.EE

If you use the
.I Layer m [n]
option, only windows in layers between m and n are displayed.
n defaults to m.

If you wanted to use the
.B WindowList
as an icon manager, you could invoke the following:
.EX
WindowList OnlyIcons, Sticky, OnTop, Geometry
.EE
(Note - the
.I Only
options essentially wipe out all other ones... but the
.I OnlyListSkip
option which just causes
.B WindowList to only consider the windows with
.I WindowListSkip
style.)

.TP
.BI "+"
Used to continue adding to the last specified decor, function or menu.
See the discussion for
.BR AddToDecor ", " AddToFunc ", and " AddToMenu .


.SS COMMANDS AFFECTING WINDOW MOVEMENT AND PLACEMENT

.TP
.BI "AnimatedMove " x y " [" Warp "]"
Move a window in an animated fashion.  Similar to
.B Move command below.
The options are the same, except they are required, since it doesn't make
sense to have a user move the window interactively and animatedly.  If
the optional argument
.I Warp
is specified the pointer is warped with the window.

.TP
.BI "HideGeometryWindow [" Never | Move | Resize "]"
Hides the position or size window that is usually shown when a window
is moved or resized interactively.  To switch it off only for move
respectively resize operations the optional parameters
.IR Move " and " Resize
can be used.  To switch both on again use the
.I Never
option.

.TP
.BI "Layer [" "arg1 arg2" "] | [" default "]"
Puts the current window in a new layer.  If
.I arg1
is non zero then the next layer will be the current layer
number plus
.IR arg1 .  If
.I arg1
is zero then the new layer will be
.IR arg2 .

As a special case,
.I default
puts the window in its default layer, i.e. the layer it was
initially in.  The same happens if no or invalid arguments
are specified.

.TP
.BI "Lower"
Allows the user to lower a window.  Note that this lowers a window
only in its layer.  To bring a window to the absolute bottom, use
.EX
AddToFunc lower-to-bottom
 + I Layer 0 0
 + I Lower
.EE

.TP
.BI "Move [[" w | m ] x " [" w | m ] y " [" Warp "]] | [" pointer "]"
Allows the user to move a window.  If called from somewhere in a
window or its border, then that window will be moved.  If called from
the root window then the user will be allowed to select the target
window.  If the optional argument
.I Warp
is specified the pointer is warped with the window.  If the single
argument
.I pointer
is given, the top left corner of the window window is moved to the
pointer position before starting the operation; this is mainly
intended for internal use by modules like
.BR FvwmPager .

The operation can be aborted with Escape or by pressing any mouse button
(except button 1 which confirms the move).

If the optional arguments
.IR x " and " y
are provided, then the window will be moved immediately without
user interaction.  Each argument can specify an absolute or
relative position from either the left/top or right/bottom of the
screen.  By default, the numeric value given is interpreted as a
percentage of the screen width/height, but a trailing
.RI ' p '
changes the interpretation to mean pixels.  To move the window relative to
its current position, add the
.RI ' w '
(for "window") prefix before the
. IR x " and/or " y
value.  To move the window to a position relative to the
current location of the pointer, add the
.RI ' m '
(for "mouse") prefix.

Simple Examples:
.EX
# Interactive move
Mouse 1 T A Move
# Move window so top left is at (10%,10%)
Mouse 2 T A Move 10 10
# Move top left to (10pixels,10pixels)
Mouse 3 T A Move 10p 10p
.EE

More complex examples (these can be bound as actions to keystrokes,
etc.; only the command is shown, though):
.EX
# Move window so bottom right is at bottom
# right of screen
Move -0 -0

# Move window 5% to the right, and to the
# middle vertically
Move w+5 50

# Move window up 10 pixels, and so left edge
# is at x=40 pixels
Move 40p w-10p

# Move window to the mouse pointer location
#
Move m+0 m+0
.EE

See also the
.B AnimatedMove
command above.

.TP
.BI "MoveToDesk " arg1 " [" arg2 "] [" "min max" "]"
Moves the selected window to another desktop.  The arguments are the
same as for the
.B Desk
command.
.B MoveToDesk
is a replacement for the old
.B WindowsDesk
command, which can no longer be used.

.TP
.BI "MoveSmoothness [" value "]"
When you move an opaque window with the mouse it has to be redrawn
quite often.  Too much drawing may slow down your machine and the
window will lag behind the mouse, but if the window is drawn too
infrequently the movement looks jerky.  The
.I value
given determines how often the window is drawn.  With a value of 1,
every update is made on the screen, with 2, 3, ... the window
is updated every second, third, ... time.  On a fast machine you can
safely use one, on slower machines use higher values.  With 0,
windows are redrawn only if the X Server does not generate mouse
movement events for a moment (which is equivalent to a very high
positive number).  The default
.I value
is 10.  To reset the
.B MoveSmoothness
to the default value you can omit the parameter.

.TP
.BI "MoveThreshold [" pixels "]"
When the user presses a mouse button upon an object fvwm
waits to see if the action is a click or a drag.  If the mouse
moves by more than
.I pixels
pixels it is assumed to be a drag.

Previous versions of fvwm hardwired
.I pixels
to 3, which is now the default value.  If
.I pixels
is negative or omitted the default value (which might be increased
when 16000x9000 pixel displays become affordable) is restored.

.TP
.BI "MoveToPage [" x "[" p "] " y "[" p "]] | [" prev "]"
Moves the selected window to another page (x,y).  The upper left page is
(0,0), the upper right is (M,0), where M is one less than the current
number of horizontal pages specified in the
.B DeskTopSize
command.  Similarly the lower left page is (0,N), and the lower right page
is (M,N).  Negative page numbers refer to pages from the rightmost/lowest
page.  If
.IR x " and " y
are not given, the window is moved to the current page (a window that
has the focus but is off-screen can be retrieved with this).  Moving
windows to a page relative to the current one can be achieved by
adding a trailing
.RI ' p '
after any or both numerical arguments.  To move a window to the
previous page use
.I prev
as the single argument.  Using MoveToPage on a sticky window
makes the window non-sticky (see
.B Stick
command).

Examples:
.EX
# Move window to page (2,3)
MoveToPage 2 3

# Move window to lowest and rightmost page
MoveToPage -1 -1

# Move window to last page visited
MoveToPage prev

# Move window two pages to the right and one
# page up
MoveToPage +2p -1p
.EE

.TP
.BI "OpaqueMoveSize [" percentage "]"
Tells fvwm the maximum size window with which opaque window
movement should be used.  The percentage is percent of the total
screen area.  With
.EX OpaqueMoveSize 0
all windows will be moved using the traditional rubber-band outline.
With
.EX
OpaqueMoveSize 100
.EE
all windows will be moved as solid windows.  The default is
.EX
OpaqueMoveSize 5
.EE
which allows small windows to be moved in an opaque manner but large
windows are moved as rubber-bands.  If
.I percentage
is omitted or invalid the default value is set.  To resize windows
in an opaque manner you can use the
.I ResizeOpaque
style.  See
.B Style
command.

.TP
.BI "PlaceAgain [" Anim "]"
Causes the current window's position to be re-computed using the initial
window placement logic.  The window is moved to where it would have
been if it were a new window that had just appeared.  Most useful with
.IR Smart " or " Clever ( ReallySmart )
placement.  If the optional argument
.I Anim
is specified, an animated move is used to place the window in its new position.

.TP
.BI "Raise"
Allows the user to raise a window. Note that this raises a window
only in its layer. To bring a window to the absolute top, use
.EX
AddToFunc raise-to-top
 + I Layer 0 ontop
 + I Raise
.EE
where ontop is the highest layer used in your setup.

.TP
.BI "RaiseLower"
Alternately raises and lowers a window.  The window is raised
if it is obscured by any window (except for its own transients
when
.I RaiseTransient
style is used; see
.B Style
command) otherwise it is lowered.

.TP
.BI "Resize [" x [ p | c "] " y [ p | c "]]"
Allows to resize a window.  If called from somewhere in a window
or its border, then that window will be resized.  If called from
the root window then the user will be allowed to select the target
window.

The operation can be aborted with Escape or by pressing any mouse button
(except button 1 which confirms it).

If the optional arguments
.IR x " and " y
are provided, then the window will be resized so that its dimensions are
.IR x " by " y .
The units of x and y are percent-of-screen, unless a letter
.RI ' p '
is appended to one or both coordinates, in which case the location is
specified in pixels.  With a
.RI ' c '
suffix the unit defined by the client application (hence the
c) is used. So you can say

.EX
Resize 80c 24c
.EE

to make a terminal window just big enough for 80x24 characters.

.TP
.BI "SetAnimation " milliseconds-delay " [" fractions-to-move-list "]"
Sets the time between frames and the list of fractional offsets to
customize the animated moves of the
.B AnimatedMove command and the animation of menus (if the menu
style is set to animated; see
.B MenuStyle
command).  If the
.I fractions-to-move-list
is omitted, only the time between frames is altered.  The
.I fractions-to-move-list
specifies how far the window should be offset at each successive frame
as a fraction of the difference between the starting location and the
ending location.  e.g.:
.EX
SetAnimation 10 -.01 0 .01 .03 .08 .18 .3 \\
  .45 .6 .75 .85 .90 .94 .97 .99 1.0
.EE

Sets the delay between frames to 10 milliseconds, and sets the positions
of the 16 frames of the animation motion.  Negative values are allowed,
and in particular can be used to make the motion appear more cartoonish, by
briefly moving slightly in the opposite direction of the main motion.  The
above settings are the default.

.TP
.BI "SnapAttraction [" proximity " [" behavior "] [" Screen "]]"
If during an interactive move the window or icon comes within
.I proximity
pixels of another the window or icon, it will be moved to make the borders
adjoin.  The default of -1 means that no snapping will happen.  A setting of
0 does indeed snap when the distance is zero pixels.  This is relevant when
the
.B SnapGrid
command is used.  Calling this command without arguments reinstates
the default settings.

The
.I behavior
argument is optional and may be set to one of the four following values:

With
.I All
both icons and windows snap to other windows and other icons.
.I SameType
lets snap windows only to other windows and icons only to other icons.
With
.I Windows
windows snap only to other windows.  Icons do not snap.
Similarly with
.I Icons
icons snap to only other icons and windows do not snap.

If the
.I Screen
option is present windows and or icons are snapped to the screen edges too.

The default
.B SnapAttraction
setting for behavior is
.IR All .

.TP
.BI "SnapGrid [" "x-grid-size y-grid-size" "]"
During an interactive move a window or icon will be positioned such that
its location (top left corner) will be coincident with the nearest grid point.
The default
.IR x-grid-size " and " y-grid-size
setting are both 1, which is effectively no grid all.  An
interactive move with both
.BR SnapGrid " and " SnapAttraction
in effect will result in the window being moved to be adjacent to
the nearest window border (if within snap proximity) or grid
position.  In other words, the window will move the shortest distance possible
to satisfy both
.BR SnapGrid " and " SnapAttraction .
Note that the x and y coordinates are not coupled.  For example,
a window may snap to another window on the x axis while snapping
to a grid point on the y axis.  Calling this command without
arguments reinstates the default settings.

.TP
.BI "WindowsDesk " arg1 " [" arg2 "]"
Moves the selected window to another desktop.

This command has been removed and must be replaced by
.BR MoveToDesk ,
the arguments for which are the same as for the
.B Desk
command.
.B Important note:
You cannot simply change the name of the command: the
syntax has changed.  If you used
.EX
WindowsDesk n
.EE
to move a window to desk n, you will have to change
it to
.EX
MoveToDesk 0 n
.EE

.TP
.BI "XorPixmap [" pixmap "]"
Selects the pixmap with which bits are XOR'ed when doing rubber-band
window moving or resizing.  This has a better chance of making the
rubber-band visible if
.B XORvalue
does not give good results.  An example pixmap
.I resize.rainbow.xpm
is provided with the icon distribution.  To turn the
.B XorPixmap
off again use the
.B XorValue command or omit the
.I pixmap
argument.

.TP
.BI "XORvalue [" number "]"
Changes the value with which bits are XOR'ed when doing rubber-band
window moving or resizing.  Setting this value is a trial-and-error
process.  The default value is 0.  It is set if the given
.I number
is omitted or invalid.


.SS COMMANDS FOR FOCUS AND MOUSE MOVEMENT

.TP
.BI "CursorMove " horizontal "[" p "] " vertical "[" p "]"
Moves the mouse pointer by
.I horizontal
pages in the X direction and
.I vertical
pages in the Y direction.  Either or both entries may be negative.
Both horizontal and vertical values are expressed in percent of
pages, so

.EX
CursorMove 100 100
.EE
means to move down and right by one full page.

.EX
CursorMove 50 25
.EE
means to move right half a page and down a quarter of a page.
Alternatively, the distance can be specified in pixels by
appending a
.RI ' p '
to the horizontal and/or vertical specification.  For example

.EX
CursorMove -10p -10p
.EE
means move ten pixels up and ten pixels left.  The CursorMove
function should not be called from pop-up menus.

.TP
.BI "FlipFocus  [" NoWarp "]"
Executes a
.B Focus
command as if the user had used the pointer to select the window.
This command alters the order of the WindowList in the same way
as clicking in a window to focus, i.e. the target window is removed
from the
.B WindowList
and placed at the start. This command is recommended for use with the
.B Direction
command and in the function invoked from
.BR WindowList .

.TP
.BI "Focus  [" NoWarp "]"
Sets the keyboard focus to the selected window.  If the
.I NoWarp
argument is given, this is all it does.  Otherwise it also moves the
viewport or window as needed to make the selected window visible and
raises the window if needed to make it visible.  Does not warp the pointer
into the selected window (see
.B WarpToWindow
function).  Does not de-iconify.  This command does not alter the
order of the
.BR WindowList ,
it rotates the
.B WindowList
around so that the target window is at the start.

When the
.I NoWarp
argument is given, Focus cannot transfer the keyboard focus to
windows on other desks.

.TP
.BI "WarpToWindow " x "[" p "] " y "[" p "]"
Warps the cursor to the associated window.  The parameters
.IR x " and " y
default to percentage of window down and in from the upper left hand
corner (or number of pixels down and in if
.RI ' p '
is appended to the numbers).


.SS COMMANDS CONTROLLING WINDOW STATE

.TP
.BI "Close"
If the window accepts the delete window protocol a message is sent to
the window asking it to gracefully remove itself.  If the window does
not understand the delete window protocol then the window is
destroyed as with the
.B Destroy
command.

.TP
.BI "Delete"
Sends a message to a window asking that it remove itself, frequently
causing the application to exit.

.TP
.BI "Destroy"
Destroys an application window, which usually causes the application
to crash and burn.

.TP
.BI "Iconify [" bool "]"
Iconifies a window if it is not already iconified or de-iconifies it
if it is already iconified.  The optional argument
.I bool
is a boolean argument.  "True" means only iconification will be
allowed, while "False" forces de-iconification.  Using "toggle"
switches between iconified and de-iconified states.

There are a number of
.B Style
options which influence the appearance and behavior of icons
(e.g.
.IR StickyIcon ", " NoIcon ).

For backwards compatibility, the optional argument may also be a
positive number instead of "True", or a negative number instead of
"False".  Note that this syntax is obsolete, and will be removed
in the future.

.TP
.BI "Maximize  [" bool "] [" horizontal "[" p "] " vertical "[" p "]]"
Without its optional arguments (or if the
.I bool
bit has the value "toggle")
.B Maximize
causes the window to alternately switch from a full-screen size to
its normal size.  To force a window into maximized (normal) state
you can use a "True" or "False" value for the
.I bool
argument.

With the optional arguments
.IR horizontal " and " vertical ,
which are expressed as percentage of a full screen, the user can
control the new size of the window.  An optional suffix
.RI ' p '
can be used to indicate pixels instead of percents of the screen
size.  If horizontal is greater than 0 then the horizontal
dimension of the window will be set to
.IR horizontal *screen_width/100.
If the value is smaller than 0 the size is subtracted from the
screen width, i.e. -25 is the same as 75.  If
.I horizontal
is "grow", it will maximize to current available space until
finding any obstacle.  The vertical resizing is similar.  If both
horizontal and vertical values are "grow", it will expand
vertically first, then horizontally to find space.  For example, the
following will add a title-bar button to switch a window to the full
vertical size of the screen:
.EX
Mouse 0 4 A Maximize 0 100
.EE
The following causes windows to be stretched to the full width:
.EX
Mouse 0 4 A Maximize 100 0
.EE
This makes a window that is half the screen size in each direction:
.EX
Mouse 0 4 A Maximize 50 50
.EE
To expand a window horizontally until any other window is found:
.EX
Mouse 0 4 A Maximize 0 grow
.EE
To expand a window but leave the lower 60 pixels of the screen
unoccupied
.EX
Mouse 0 4 A Maximize 100 -60p
.EE

Values larger than 100 can be used with caution.

.TP
.BI "Recapture"
Causes fvwm to recapture all of its windows.  This ensures that the
latest style parameters will be used.  The recapture operation is
visually disturbing.

Since fvwm version 2.4 only very few
.B Style
options need a
.B Recapture
to take effect (e.g.
.IR UseStyle).
The
.B Recapture
command will become obsolete soon.

.TP
.BI "RecaptureWindow"
Causes fvwm to recapture the chosen window.  See
.B Recapture
commadn above.

.TP
.BI "Refresh"
Causes all windows on the screen to redraw themselves.

.TP
.BI "RefreshWindow"
Causes the chosen window to redraw itself.

.TP
.B "Stick [" bool "]"
If the
.I bool
argument is empty or "toggle", the
.B Stick
command makes a window sticky if it is not already sticky, or
non-sticky if it is already sticky.  To make a window sticky
regardless of its current state the
.I bool
argument must be "True".  To make it non-sticky use "False".

.TP
.BI "WindowShade [" bool "]"
Toggles the window shade feature for titled windows.  Windows in the
shaded state only display a title-bar.  If
.I bool
is not given or "toggle", the window shade state is toggled.  If
.I bool
is "True", the window is forced to the shaded state. If
.I bool
is "False", then the window is forced to the non-shaded state.
Windows without titles can be shaded too.  See also
.I WindowShadeSteps
option of the
.B Style
command.

For backwards compatibility, the optional argument may also be 1
to signify "on", and 2 to signify "off". Note that this syntax
is obsolete, and will be removed in the future.

.TP
.BI "WindowShadeAnimate  [" steps "[" p "]]"
This command is obsolete.  Please use the
.I WindowShadeSteps
option of the
.B Style
command instead.


.SS COMMANDS FOR MOUSE, KEY AND STROKE BINDINGS

.TP
.BI "IgnoreModifiers [" Modifiers "]"
Tells fvwm which modifiers to ignore when matching Mouse or Key
bindings.
.B IgnoreModifiers
affects the ClickToFocus style too.  This command belongs into your
.IR .fvwm2rc .
If you issue it when your fvwm session is already up and running
the results are unpredictable.  The should appear before any
applications or modules are started in your
.I .fvwm2rc
file (e.g. with the
.B Exec
command).

.I Modifiers
has the same syntax as in the
.BR Mouse " or " Key
bindings, with the addition of 'L' meaning the
.SM caps lock
key.  The default is "L".
.I Modifiers
can be omitted, meaning no modifiers are ignored.  This command
comes in handy if the
.SM num-lock
and
.SM scroll-lock
keys interfere with your shortcuts.  With XFree86 '2' usually is the
.SM num-lock
modifier and '5' refers to the
.SM scroll-lock
key. To turn all these pesky modifiers off you can use this command:

.EX
IgnoreModifiers L25
.EE

.I Important Note:
This command creates a lot of extra network traffic, depending on
your CPU, network connection, the number of
.BR Key " or " Mouse
commands in you configuration file and the number of modifiers
you want to ignore.  If you do not have a lightning fast machine
or very few bindings you should not ignore more than two modifiers.
I.e. do not ignore
.SM scroll-lock
if you have no problem with it.  In the
.B FAQ
you will find a better solution of this problem.

.TP
.BI "GnomeButton"
Used in conjunction with
.B Mouse
to pass mouse button presses on the root window to a
.SM GNOME
program (such as GMC).  The following example passes
presses of mouse buttons 1 and 3 to such a program.

.EX
Mouse 1 R A GnomeButton
Mouse 3 R A GnomeButton
.EE

.TP
.BI "Key " "Keyname Context Modifiers Function"
Binds a keyboard key to a specified fvwm built-in function, or
removes the binding if
.I Function
is '-'.  The syntax is the same as for a
.B Mouse
binding except that the mouse button number is replaced with a
.IR Keyname .
The
.I Keyname
is one of the entries from
.IR /usr/include/X11/keysymdef.h ,
with the leading XK_ omitted.  The
.IR Context " and " Modifiers
fields are defined as in the Mouse binding.  However, when you
press a key the context window is the window that has the keyboard
focus.  That is not necessarily the same as the window the pointer
is over (with
.IR SloppyFocus " or " ClickToFocus ).
Note that key bindings with the 'R' (root window) context do not
work properly with
.IR SloppyFocus " and " ClickToFocus .
If you encounter problems, use the
.B PointerKey
command instead.  If you want to bind keys to a window with
.IR SloppyFocus " or " ClickToFocus
that are supposed to work when the pointer is not over the
window, fvwm assumes the pointer is over the client window
(i.e. you have to use the 'W' modifier).

The following example binds the built in window list to pop up when
.SM Alt-Ctrl-Shift-F11
is hit, no matter where the mouse pointer is:
.EX
Key F11 A SCM WindowList
.EE

Binding a key to a title-bar button will cause that button to
appear.  Please refer to the
.B Mouse
command for details.

.TP
.BI "Mouse " "Button Context Modifiers Function"
Defines a mouse binding, or removes the binding if
.I Function
is '-'.
.I Button
is the mouse button number.  If
.I Button
is zero then any button will perform the specified function.
.I Context
describes where the binding applies.  Valid contexts are 'R' for
the root window, 'W' for an application window, 'T' for a window
title-bar, 'S' for a window side, top, or bottom bar, 'F' for a window
frame (the corners), 'I' for an Icon window, or '0' through '9' for
title-bar buttons, or any combination of these letters.  'A' is for any
context except for title-bar buttons.  For instance, a context of "FST"
will apply when the mouse is anywhere in a window's border except the
title-bar buttons.  Only 'S' and 'W' are valid for an undecorated window.

.I Modifiers
is any combination of 'N' for no modifiers, 'C' for control, 'S' for
shift, 'M' for Meta, 'L' for Caps-Lock or 'A' for any modifier.
For example, a modifier of "SM" will apply when both the
.SM Meta
and
.SM Shift
keys are down.  X11 modifiers mod1 through mod5 are represented as the
digits '1' through '5'.  The modifier 'L' is ignored by default.  To turn
it on, use the
.B IgnoreModifiers
command.

.I Function
is one of fvwm's built-in functions.

The title-bar buttons are numbered with odd numbered buttons on the
left side of the title-bar and even numbers on the right.
Smaller-numbered buttons are displayed toward the outside of the
window while larger-numbered buttons appear toward the middle of the
window (0 is short for 10).  In summary, the buttons are numbered:
.EX
1 3 5 7 9    0 8 6 4 2
.EE
The highest odd numbered button which has an action bound to it
determines the number of buttons drawn on the left side of the title
bar.  The highest even number determines the number or right side
buttons which are drawn.  Actions can be bound to either mouse buttons
or keyboard keys.

.TP
.BI "PointerKey " "Keyname Context Modifiers Function"
This command works exactly like the
.B Key
command.  The only difference is that the binding operates on
the window under the pointer.  Normal key bindings operate on
the focused window instead.  The
.B PointerKey
command can for example be used to bind keys to the root window
if you are using
.IR SloppyFocus " or " ClickToFocus .

Example:
.EX
Style * SloppyFocus
PointerKey f1 a m Menu MainMenu
.EE

.TP
.BI "Stroke " "Sequence Button Context Modifiers Function"
Binds a mouse stroke sequence to a specified fvwm built-in function,
or removes the binding if
.I Function
is '-'.  The syntax is the same as for a
.B Mouse
binding except that
.I Sequence
is inserted in front of the button number and a value of 0 for
.I Button
concerns the
.B StrokeFunc
command.  The
.IR Context " and " Modifiers
fields are defined as in the
.B mouse
binding.  However, only the 'R' Context really works (if you want
to use other contexts you need to use the
.B StrokeFunc
below).

Strokes sequences are defined in a telephone grid like this:
.EX
 1  2  3

 4  5  6

 7  8  9
.EE
or in a numeric pad grid like this:
.EX
 7  8  9

 4  5  6

 1  2  3
.EE
The telephone grid is used by default, to use the numeric pad grid
you should begin the sequence with a 'N'.  Note that a complex motion
may gives several different sequences (see the "netscape" example
below to handle such motion).  Moreover, sequence are limited to
20 elements (with the present version of
.BR libstroke ),
however, in practice it is preferable to use sequence with less than 12
elements.

Because of the default button menu in fvwm, you may need to remove
a mouse button binding (using an empty action) before using the stroke
.EX
Mouse 3 R N
.EE
Also, you can still use the stroke "sequence 0" to simulate a click:
.EX
Stroke 0 3 R N Menu WindowList Nop
.EE
The following example starts xterm when the mouse drags an 'I' on
the root window with button 3 pressed down:
.EX
Stroke 258  3  R  N  Exec exec xterm
.EE
An example for Netscape:
.EX
Stroke 7415963    3  R  N  Exec exec netscape
Stroke 74148963   3  R  N  Exec exec netscape
Stroke 74158963   3  R  N  Exec exec netscape
Stroke 7418963    3  R  N  Exec exec netscape
Stroke 415963     3  R  N  Exec exec netscape
.EE
You may prefer to use the numeric pad grid since you have such
a grid on your machine. Here an example:
.EX
Stroke N78963314   3  R  N  FvwmForm FormFvwmQuitVerify.
Stroke N789633147  3  R  N  FvwmForm FormFvwmQuitVerify.
.EE
This example will start the "QuitVerify" form if you draw a box
that begin in the top left corner.

Note: You need
.B libstroke
installed and fvwm compiled with stroke support.
.B libstroke
can be obtained via anonymous ftp at
.EX
.B http://www.etla.net/~willey/projects/libstroke/
.EE

.TP
.BI "StrokeFunc [" Options "]"
Causes fvwm to record a mouse stroke sequence and to execute the
corresponding action as defined in a
.B Stroke
command.  The cursor is modified to the
.I STROKE
context of the
.B CursorStyle
command during recording.  When the stroke is finished
.B StrokeFunc looks for a stroke binding of the form
.EX
Stroke sequence 0 Context Modifiers action
.EE
and executes the corresponding action (Note the 0).  Normal use of this
function is via a
.BR Mouse " or " Key
command.  Examples:
.EX
Mouse 3 A M StrokeFunc
Key x R N StrokeFunc
.EE
If you press mouse button 3 and
.SM Alt
anywhere (respectively, press the key x when the cursor is on
the root window), then fvwm will record the mouse motions until
the mouse button 3 (respectively, the x key) is released and then
check if the recorded
.I sequence
corresponds to a stroke binding of the form
.EX
.RI """Stroke " sequence " 0 A M " action """ \""
.RI """Stroke " sequence " 0 R N " action """ \""
.EE
Note that the
.IR Context " and " Modifiers
are taken at the beginning of the execution of the
.B StrokeFunc
command (so you can release the modifiers before the end of the
stroke recording in the case of a mouse binding and if you used,
say, a title-bar context the mouse motion can go through an
application window).  The keys
.SM Escape
and
.SM Delete
allow you to abort the command.

The
.B StrokeFunc
command has four options:
.IR NotStayPressed ", " EchoSequence ", " DrawMotion " and " FeedBack .
These options are disabled by default.
.I EchoSequence
causes fvwm to Echo the recorded stroke sequence.
.I DrawMotion
causes fvwm to draw the mouse motion on the screen.
.I FeedBack
causes fvwm to display during a fraction of second the cursor of the
.I WAIT
context of the
.B CursorStyle
command if the recorded stroke sequence corresponds to a stroke binding.

.I NotStayPressed
works only if
.B StrokeFunc
is used via a
.BR Mouse
or a
.B Key
command.  This option removes the need to have a button or the
key pressed during the stroke, but you have to do a mouse click
or press the
.SM Return
or
.SM Space
key to finish the mouse motion recording (these keys also work
without the
.I NotStayPressed
option).

You can use the
.B StrokeFunc
"alone".  In this case it will work as above with the
.I NotStayPressed
option enabled.  However,
.I Modifiers
will, in general, not work as expected (i.e., in this case use
'A' or 'N' as
.I Modifiers
in the stroke bindings).

Note that some computers do not support key release events.
If that is the case the
.B StrokeFunc
used via a
.B Key
command will work as if the
.I NotStayPressed
option is enabled.


.SS THE STYLE COMMAND (CONTROLLING WINDOW STYLES)

.TP
.B "Style " "stylename options"
This command is intended to replace the old fvwm 1.xx global commands
NoBorder, NoTitle, StartsOnDesk, Sticky, StaysOnTop, Icon,
WindowListSkip, CirculateSkip, SuppressIcons, BoundaryWidth,
NoBoundaryWidth, StdForeColor, and StdBackColor with a single flexible
and comprehensive window specific command.  This command is used to
set attributes of a window to values other than the default or to set
the window manager default styles.

.I stylename
can be a window's name, class, or resource string.  It may contain
the wildcards '*' and '?', which are matched in the usual Unix
filename manner.  They are searched in the reverse order stated,
so that
.B Style
commands based on the name override or augment those based on the
class, which override or augment those based on the resource string.
When two conflicting styles apply to the same window, the style
that was changed las wins.

Note: windows that have no name (WM_NAME) are given a name of
"Untitled", and windows that don't have a class (WM_CLASS, res_class)
are given class "NoClass" and those that don't have a resource
(WM_CLASS, res_name) are given resource "NoResource".

.I options
is a comma separated list containing one or more of the keywords
.IR BorderWidth ", " HandleWidth ,
.IR NoIcon " / " Icon ", " MiniIcon ,
.IR IconBox ", " IconGrid ", " IconFill ,
.IR NoTitle " / " Title ,
.IR TitleAtBottom " / " TitleAtTop ,
.IR StipledTitle " / " StipledTitleOff ,
.IR NoHandles " / " Handles ,
.IR WindowListSkip " / " WindowListHit ,
.IR CirculateSkip " / " CirculateHit ,
.IR CirculateSkipShaded " / " CirculateHitShaded ,
.IR Layer ,
.IR StaysOnTop " / " StaysOnBottom " / " StaysPut ,
.IR Sticky " / " Slippery ,
.IR StartIconic " / " StartNormal ,
.IR Color ", " ForeColor ", " BackColor ", " Colorset ,
.IR HilightFore ", " HilightBack ", " HilightColorset ,
.IR Font ,
.IR IconFont ,
.IR StartsOnDesk " / " StartsOnPage " / " StartsAnyWhere ,
.IR ActivePlacementHonorsStartsOnPage " / " ActivePlacementIgnoresStartsOnPage ,
.IR CaptureHonorsStartsOnPage " / " CaptureIgnoresStartsOnPage ,
.IR RecaptureHonorsStartsOnPage " / " RecaptureIgnoresStartsOnPage ,
.IR StartsOnPageIncludesTransients " / " StartsOnPageIgnoresTransients ,
.IR IconTitle " / " NoIconTitle ,
.IR MwmButtons " / " FvwmButtons ,
.IR MwmBorder " / " FvwmBorder ,
.IR MwmDecor " / " NoDecorHint ,
.IR MwmFunctions " / " NoFuncHint ,
.IR HintOverride " / " NoOverride ,
.IR NoButton " / " Button ,
.IR ResizeHintOverride " / " NoResizeOverride ,
.IR OLDecor " / " NoOLDecor ,
.IR StickyIcon " / " SlipperyIcon ,
.IR SmartPlacement " / " CleverPlacement " / " DumbPlacement ,
.IR RandomPlacement " / " ActivePlacement ,
.IR DecorateTransient " / " NakedTransient ,
.IR RaiseTransient " / " DontRaiseTransient ,
.IR LowerTransient " / " DontLowerTransient ,
.IR FlipTransient " / " DontFlipTransient ,
.IR StackTransientParent " / " DontStackTransientParent ,
.IR SkipMapping " / " ShowMapping ,
.IR UseDecor ,
.IR UseStyle ,
.IR NoPPosition " / " UsePPosition ,
.IR Lenience " / " NoLenience ,
.IR ClickToFocus " / " SloppyFocus " /"
.IR MouseFocus | FocusFollowsMouse " / " NeverFocus ,
.IR ClickToFocusPassesClickOff " / " ClickToFocusPassesClick ,
.IR ClickToFocusRaisesOff " / " ClickToFocusRaises ,
.IR MouseFocusClickRaises " / " MouseFocusClickRaisesOff ,
.IR StartsLowered " / " StartsRaised ,
.IR GrabFocus " / " GrabFocusOff ,
.IR GrabFocusTransient " / " GrabFocusTransientOff ,
.IR IgnoreRestack " / " AllowRestack ,
.IR FixedPosition " / " VariablePosition ,
.IR IconOverride " / " NoIconOverride " / " NoActiveIconOverride ,
.IR DepressableBorder " / " FirmBorder ,
.IR MaxWindowSize ,
.IR ResizeOpaque " / " ResizeOutline ,
.IR BackingStore " / " BackingStoreOff ,
.IR SaveUnder " / " SaveUnderOff ,
.IR WindowShadeShrinks " / " WindowShadeScrolls ,
.IR WindowShadeSteps.

In the above list some options are listed as
style-option/opposite-style-option.  The opposite-style-option for
entries that have them describes the fvwm default behavior and
can be used if you want to change the fvwm default behavior.

The
.IR Title " and " NoTitle
options determine if the window has a title-bar or not.  By default
all windows have a title-bar.

Windows with the \fITitleAtBottom\fP style will have a title-bar
below the window instead of above as usual. The \fITitleAtTop\fP
style restores the default placement. Even if the window has the
\fINoTitle\fP style set, this affects the \fIWindowShade\fP command.

With the
.I StipledTitle
style, are drawn with the same effect that is usually reserved for
windows with the
.I Sticky
style.
.I StipledTitleOff
reverts back to normal titles.

\fIDecorateTransient\fP causes transient windows, which are normally
left undecorated, to be given the usual fvwm decorations (title
bar, buttons, etc.). Note that some pop-up windows, such as the xterm
menus, are not managed by the window manager and still do not receive
decorations. \fINakedTransient\fP (the default) causes transient windows
not to be given the standard decorations. You can only bind keys or mouse
buttons to the sides and the client window of an undecorated window
('S' and 'W' contexts in bindings, see \fIMouse\fP and \fIKey\fP commands).

A window with the \fIRaiseTransient\fP style that has transient windows
will raise all its transients when it is raised.
The \fIDontRaiseTransient\fP style disables this behavior.  All windows
are then treated as if they had no transients.

A window with the \fILowerTransient\fP style that has transient windows
will lower all its transients when it is lowered.  The
\fIDontLowerTransient\fP style disables this behavior.  All windows
are then treated as if they had no transients.

The \fIFlipTransient\fP style augments \fIRaiseTransient\fP and
\fILowerTransient\fP styles so that repeated raising or repeated lowering
of the main window makes the transients flip above and below the main.
Note that flipping only occurs at the top or bottom of the layer,
and so a second raise or lower may be necessary to actually flip when the
first has simply moved the window's position.
The \fIDontFlipTransient\fP style disables this behavior so that the
main window is always below its transients.
\fI(Dont)FlipTransient\fP has no effect if \fIRaiseTransient\fP and
\fILowerTransient\fP are not used.

The \fIStackTransientParent\fP style augments \fIRaiseTransient\fP and
\fILowerTransient\fP styles.  Raising a window with
\fIStackTransientParent\fP style transfers the raise action to the
main window if the window being raised is a transient and its main
window has \fIRaiseTransient\fP style; this effect makes raise on a
transient act just like raise on its main - the whole group is raised.
Similar behavior holds for lowering a whole group of transients when
the main has \fILowerTransient\fP style. \fIDontStackTransientParent\fP
turns this behavior off. \fI(Dont)StackTransientParent\fP has no
effect if \fIRaiseTransient\fP and \fILowerTransient\fP are not used.

A reasonable emulation of Motif raise/lower on transients is possible like this
.EX
Style * RaiseTransient
Style * LowerTransient
Style * StackTransientParent
Style * DontFlipTransient
.EE

\fIIcon\fP takes an (optional) unquoted string argument which is the icon
bitmap or pixmap to use. Icons specified this way override pixmap icons, but
not icon windows, provided by the client in the WM_HINTS property. The
IconOverride style changes the behavior to override any client-provided
icons; the NoIconOverride style changes the behavior to not override
any client-provided icons; the default overriding behavior can be
activated with the NoActiveIconOverride style.

There is one exception to these rules, namely
.EX
Style * Icon unknown.xpm
.EE
doesn't force the unknown.xpm icon on every window, it just sets the
default icon like the DefaultIcon command. If you really want all
windows to have the same icon, you can use
.EX
Style ** Icon unknown.xpm
.EE

\fIIconBox\fP takes four numeric arguments or an X11 geometry string:
.EX
IconBox l t r b
.EE
or
.EX
IconBox geometry
.EE

Where l is the left coordinate, t is the top, r is right and b is
bottom. Negative coordinates indicate distance from the right or
bottom of the screen.
Perhaps easier to use is an X11 Geometry string:
.EX
IconBox -80x200-1-1
.EE
Which would place an 80 by 240 pixel icon box in the lower right hand
corner of the screen.
The icon box is a region of the screen where fvwm
attempts to put icons for any matching window, as long as they do not
overlap other icons.
Multiple icon boxes can be defined as overflow areas.  When the first
icon box is filled, the second one is filled.  All the icon boxes for
one style must be defined in one command.  For example:
.EX
Style * IconBox -80x200-1-1, \\
        IconBox 1000x70-1-1
.EE
If you never define an icon box, or you fill all the icon boxes, fvwm
has a default icon box that covers the screen, it filled top to bottom,
then left to right, and has an 80x80 pixel grid.  To disable all but
the default icon box you can use IconBox without arguments in a
separate Style command.

Hint: You can auto arrange your icons in the icon box with a simple
fvwm function. Put the DeiconifyAndRearrange function below in your
configuration file:

.EX
AddToFunc DeiconifyAndRearrange
 + C Iconify off
 + C All (CurrentPage Iconic) RecaptureWindow
.EE

And then replace all places where you call the Iconify
builtin function to de-iconify an icon with a call to the new
function. For example replace

.EX
AddToFunc IconFunc
 + C Iconify off
 + M Raise
 + M Move
 + D Iconify off
.EE

with

.EX
AddToFunc IconFunc
 + C DeiconifyAndRearrange
 + M Raise
 + M Move
 + D DeiconifyAndRearrange
.EE

and

.EX
Mouse 1 I A Iconify off
.EE

with

.EX
Mouse 1 I A DeiconifyAndRearrange
.EE

\fIIconGrid\fP takes 2 numeric arguments greater than zero.
.EX
IconGrid x y
.EE
Icons are placed in an icon box by stepping thru the icon box using
the x and y values for the icon grid, looking for a free space.
The default grid is 3 by 3 pixels which gives a tightly packed appearance.
To get a more regular appearance use a grid larger than your largest icon.
Currently there is no way to clip an icon to a maximum size.
An IconGrid definition must follow the IconBox definition that it
applies to:
.EX
Style * IconBox -80x240-1-1, IconGrid 90 90
.EE

\fIIconFill\fP takes 2 arguments.
.EX
IconFill Bottom Right
.EE
Icons are placed in an icon box by stepping thru the icon box using
these arguments to control the direction the box is filled in.
By default the direction is left to right, then top to bottom.
This would be expressed as:
.EX
IconFill left top
.EE
To fill an icon box in columns instead of rows, specify the
vertical direction (top or bottom) first.
The directions can be abbreviated or spelled out as follows: "t", "top",
"b", "bot", "bottom", "l", "lft", "left", "r", "rgt", "right".
An IconFill definition must follow the IconBox definition that it
applies to:
.EX
Style * IconBox -80x240-1-1, IconFill b r
.EE

\fIMiniIcon\fP specifies a pixmap to use as the miniature icon for the
window.  This miniature icon can be drawn in a title-bar button (see
ButtonStyle), and can be used by various fvwm modules (FvwmWinList,
FvwmIconMan, and FvwmTaskBar). It takes the name of a pixmap as an
argument.

\fIStartsOnDesk\fP takes a numeric argument which is the desktop number on
which the window should be initially placed.  Note that standard Xt
programs can also specify this via a resource (e.g. "-xrm '*Desk: 1'").

\fIStartsOnPage\fP takes 1, 2, or 3 numeric arguments. If one or three
arguments are given, the first (or only) argument is the desktop number.  If
three arguments are given, the 2nd and 3rd arguments identify the x,y page
position on the virtual window. If two arguments are given, they specify the
page position, and indicate no desk preference. If only one argument is given,
StartsOnPage functions exactly like StartsOnDesk. For those standard Xt
programs which understand this usage, the starting desk/page can also be
specified via a resource (e.g., "-xrm 'Fvwm.Page: 1 0 2'").

StartsOnPage in conjunction with SkipMapping is a useful technique when you
want to start an app on some other page and continue with what you were
doing, rather than waiting for it to appear.

\fIStartsOnPageIncludesTransients\fP will cause the StartsOnPage style to
be applied even for transient windows. This is not usually useful, since
transients are usually pop ups that you want to appear in your visible
viewport; but occasionally an application will use a transient for something
like a startup window that needs to be coerced into place.

\fIActivePlacementIgnoresStartsOnPage\fP suppresses StartsOnPage or
StartsOnDesk placement in the event that both ActivePlacement and SkipMapping
are in effect when a window is created. This prevents you from interactively
placing a window and then wondering where it disappeared to, because it got
placed on a different desk or page. ActivePlacementHonorsStartsOnPage
allows this to happen anyway. The option has no effect if SkipMapping is
not in effect, because fvwm will switch to the proper desk/page to perform
interactive placement. The default is ActivePlacementIgnoresStartsOnPage;
ActivePlacementHonorsStartsOnPage matches the way the old StartsOnDesk style
used to handle the situation.

\fICaptureHonorsStartsOnPage\fP causes the initial capture (of an already
existing window) at startup to place the window according to the
StartsOnPage desk and page specification. CaptureIgnoresStartsOnPage
causes fvwm to ignore these settings (including StartsOnDesk) on
initial capture. The default is CaptureHonorsStartsOnPage.

\fIRecaptureHonorsStartsOnPage\fP causes a window to be placed according to,
or revert to, the StartsOnPage desk and page specification on Restart or
Recapture. RecaptureIgnoresStartsOnPage causes fvwm to respect the current
window position on Restart or Recapture. The default is
RecaptureIgnoresStartsOnPage.

\fILayer\fP accepts one a argument: a non-negative integer. This is
the layer the window is put in.

\fIStaysOnTop\fP puts the window in the top layer. This layer can
be changed by the built-in command DefaultLayers; the default is 6.

\fIStaysPut\fP puts the window in the put layer. This layer can
be changed by the built-in command DefaultLayers; the default is 4.

\fIStaysOnBottom\fP puts the window in the bottom layer. This layer can
be changed by the built-in command DefaultLayers; the default is 2.

\fIBorderWidth\fP takes a numeric argument which is the width of the border
to place the window if it does not have resize-handles.

\fIHandleWidth\fP takes a numeric argument which is the width of the border
to place the window if it does have resize-handles.

\fIMaxWindowSize\fP [\fIwidth\fP \fIheight\fP]
Tells fvwm the maximum width and height of a window when it is
initially created.  The values are the percentage of the total screen
area.  If the letter 'p' is appended to wither of the values, the
numbers are interpreted as pixels. This command is useful to force
large application windows to be fully visible.  Neither \fIheight\fP
nor \fIwidth\fP may be less than 100 pixels.  If you omit the
parameters or their values are invalid, both limits are set to 32767
pixels (which is the default).

\fIResizeOpaque\fP instructs fvwm to resize the corresponding windows
opaque instead of using an outline.  Since this causes the application
to redraw frequently it can be quite slow and make the window flicker
excessively, depending on the amount of graphics the application
has to redraw.  The \fIResizeOutline\fP style (default) negates the
\fIResizeOpaque\fP style.  Many applications do not like their windows
being resized opaque, e.g. XEmacs, Netscape or terminals with a pixmap
background.  If you do not like the result, don't use the
\fIResizeOpaque\fP style for these windows.  To exempt certain windows
from opaque resizing you could use these lines in your configuration
file:

.EX
Style * ResizeOpaque
Style rxvt ResizeOutline
Style emacs ResizeOutline
.EE

\fIButton\fP and \fINoButton\fP take a numeric argument which is the
number of the title-bar button which is to be included/omitted.

\fISticky\fP makes the window sticky, i.e. it will always be visible
on each page and each desk.  \fISlippery\fP reverst back to the
default.

\fIStickyIcon\fP makes the window sticky when its iconified.  It will
de-iconify on top the active desktop.

\fIMwmButtons\fP makes the Maximize button look pressed-in when the window
is maximized.  See the MwmButton flag in ButtonStyle for more
information.

\fIMwmBorder\fP makes the 3-D bevel more closely match mwm's.

\fIMwmDecor\fP makes fvwm attempt to recognize and respect the mwm
decoration hints that applications occasionally use.

\fIMwmFunctions\fP makes fvwm attempt to recognize and respect the mwm
prohibited operations hints that applications occasionally use.
HintOverride makes fvwm shade out operations that mwm would prohibit,
but it lets you perform the operation anyway.

\fIResizeHintOverride\fP instructs fvwm to ignore the program supplied
minimum and maximum size. This can be handy for broken applications that
refuse to be resized. Don't use it if you don't need it.

\fIOLDecor\fP makes fvwm attempt to recognize and respect the olwm and olvwm
hints that many older XView and OLIT applications use.

\fIColor\fP takes two arguments.  The first is the window-label text color
and the second is the window decoration's normal background color.
The two colors are separated with a slash.  If the use of a slash
causes problems then the separate \fIForeColor\fP and \fIBackColor\fP
options can be used.

\fIColorset\fP takes the colorset number as its sole argument and
overrides the colors set by \fIColors\fP.  Instead, the
corresponding colors from the given colorset are used.  Note that all
other features of a colorset are unsupported yet.

The \fIHilightFore\fP, \fIHilightBack\fP and \fIHilightColorset\fP
styles work exactly like \fIForeColor\fP, \fIBackColor\fP and
\fIColorset\fP but are used only if the window has the focus.
These styles replace the old commands HilightColor and HilightColorset.

The \fIFont\fP and \fIIconFont\fP options take the name of a font
as their sole argument.  This font is used in the window or icon title.
By default the font given in the \fIDefaultFont\fP command is used.
To revert back to the default, use the style without the name argument.
These styles replace the older WindowFont and IconFont commands.

\fIUseDecor\fP accepts one argument: the name of a decor created with
AddToDecor.  If UseDecor is not specified, the "Default" decor is
used.  Windows do not actually contain decors, but are always assigned
to one.  If the decor is later modified with AddToDecor, the changes
will be visible for all windows which are assigned to it.  The decor
for a window can be reassigned with ChangeDecor.

\fIUseStyle\fP takes one arg, which is the name of another style.  That way
you can have unrelated window names easily inherit similar traits
without retyping.  For example: 'Style "rxvt" UseStyle "XTerm"'.
Warning: If a style is built from one or more parent styles and the
parent styles are changed, the derived style is not modified. To achieve
this you have to issue the 'UseStyle' line again.

.I SkipMapping
tells fvwm not to switch to the desk the window is on when
it gets mapped initially (useful with
.IR StartsOnDesk " or " StartsOnPage ).

.I Lenience
instructs fvwm to ignore the convention in the
.SM ICCCM
which states that if an application sets the input field of the wm_hints
structure to False, then it never wants the window manager to give it
the input focus.  The only application that we know of which needs this
is sxpm, and that is a silly bug with a trivial fix and has no overall
effect on the program anyway.  Rumor is that some older applications
have problems too.

\fIClickToFocus\fP instructs fvwm to give the focus to the window when it is
clicked in.  The default \fIMouseFocus\fP (or its alias
\fIFocusFollowsMouse\fP) tells fvwm to give the window the focus as soon as
the pointer enters the window, and take it away when the pointer leaves the
window. \fISloppyFocus\fP is similar, but doesn't give up the focus if the
pointer leaves the window to pass over the root window or a ClickToFocus
window (unless you click on it, that is), which makes it possible to
move the mouse out of the way without losing focus. A window with the
style \fINeverFocus\fP never receives the focus. This is useful for
FvwmButtons, for example.

The focus model can be augmented with severa additional options.
.IR ClickToFocusPassesClickOff " and " ClickToFocusPassesClick
controls if a mouse click to focus a window using the
.I ClickToFocus
model is sent to the application or not.  Similarly,
.IR ClickToFocusRaisesOff " and " ClickToFocusRaises
control if the window is raised, while
.IR MouseFocusClickRaises " and " MouseFocusClickRaisesOff
are equivalent but apply only to windows using
.IR SloppyFocus " or " MouseFocus .
The defaults are
.IR ClickToFocusPassesClick ,
.IR ClickToFocusRaises and MouseFocusClickRaisesOff .

.I NoPPosition
instructs fvwm to ignore the PPosition field when adding
new windows.  Adherence to the PPosition field is required for some
applications, but if you don't have one of those its a real headache.

.I RandomPlacement
causes windows which would normally require user
placement to be automatically placed in ever-so-slightly random
locations.  For the best of all possible worlds use both
.IR RandomPlacement " and " SmartPlacement .

.I SmartPlacement
causes windows which would normally require user
placement to be automatically placed in a smart location - a location
in which they do not overlap any other windows on the screen.  If no
such position can be found user placement or random placement (if
specified) will be used as a fall-back method.  For the best of all
possible worlds use both
.IR RandomPlacement " and " SmartPlacement .

.I CleverPlacement
augments the
.I SmartPlacement
style so that it tries to avoid overlapping icons, sticky windows
and windows on higher layers.  If
.I SmartPlacement
is not used,
.I CleverPlacement
has no effect.  To switch this style off again, use the
.I CleverPlacementOff
style.
.I CleverPlacement
must be specified after
.I SmartPlacment
to take effect.

\fIStartsLowered\fP instructs fvwm to put the window initially at the
bottom of its layer rather than the default \fIStartsRaised\fP.

\fIGrabFocus\fP causes a newly mapped window to grab the focus, wile
\fIGrabFocusOff\fP turns this off. \fIGrabFocus\fP is the default
for ClickToFocus windows and \fIGrabFocusOff\fP is the default for
MouseFocus and SloppyFocus windows. Note that this option is switched
back to the default every time you change the focus policy. You
have to use it after the initial ClickToFocus/MouseFocus/SloppyFocus.
This style does not apply to transient windows. The
\fIGrabFocusTransient\fP and \fIGrabFocusTransientOff\fP styles
are responsible for this behavior. By default, \fIGrabFocusTransient\fP
is turned on.

\fIIgnoreRestack\fP makes fvwm ignore attempts of clients to raise
or lower their own windows.

\fIFixedPosition\fP makes fvwm ignore attempts of the user to move
the window.

\fIDepressableBorder\fP makes the border parts of the window decoration
look sunken in when a button is pressed over them.

An example:
.EX
# Change default fvwm behavior to no title-
# bars on windows! Also define a default icon.
Style *             NoTitle,               \\
                    Icon unknown1.xpm,     \\
                    BorderWidth 4,         \\
                    HandleWidth 5

# now, window specific changes:
Style Fvwm*       NoHandles, Sticky,       \\
                  WindowListSkip,          \\
                  BorderWidth 0
Style FvwmPager   StaysOnTop, BorderWidth 0
Style *lock       NoHandles, Sticky,       \\
                  StaysOnTop, WindowListSkip
Style xbiff       Sticky, WindowListSkip
Style FvwmButtons NoHandles, Sticky,       \\
                  WindowListSkip
Style sxpm        NoHandles

# Put title-bars back on xterms only!
Style xterm     Title, Color black/grey

Style rxvt        Icon term.xpm
Style xterm       Icon rterm.xpm
Style xcalc       Icon xcalc.xpm
Style xbiff       Icon mail1.xpm
Style xmh         Icon mail1.xpm,         \\
                    StartsOnDesk 2
Style xman        Icon xman.xpm
Style matlab      Icon math4.xpm,         \\
                    StartsOnDesk 3
Style xmag        Icon magnifying_glass2.xpm
Style xgraph      Icon graphs.xpm
Style FvwmButtons Icon toolbox.xpm
Style Maker       StartsOnDesk 1
Style signal      StartsOnDesk 3

# Fire up Netscape on the second desk, in the
# middle of my 3x3 virtual desktop, and don't
# bother me with it...
Style Netscape* SkipMapping,              \\
                StartsOnPage 1 1 1
.EE
Note that all properties for a window will be OR'ed together.  In the
above example "FvwmPager" gets the property StaysOnTop via an exact
window name match but also gets NoHandles, Sticky, and WindowListSkip
by a match to "Fvwm*".  It will get NoTitle by virtue of a match to
"*".  If conflicting styles are specified for a window, then the last
style specified will be used.

If the NoIcon attribute is set then the specified window will simply
disappear when it is iconified.  The window can be recovered through
the window-list.  If Icon is set without an argument then the NoIcon
attribute is cleared but no icon is specified.  An example which
allows only the FvwmPager module icon to exist:
.EX
Style * NoIcon
Style FvwmPager Icon
.EE

The \fIBackingStore\fP and \fISaveUnder\fP styles enable the corresponding
window attributes in the X server.  BackingStore means that the X server
tries to keep the obscured parts of a window in memory while windows
with SaveUnder store the graphics below them.  Either option can speed
up fvwm if the connection to the X server is slow (e.g. over a modem
link).  By default both styles are turned off.  To switch them off
explicitly you can use the \fIBackingStoreOff\fP and \fISaveUnderOff\fP
styles.

.IR WindowShadeShrinks " and " WindowShadeScrolls
control if the contents of a window that is being shaded with the
.B WindowShade
command are scrolled (default) or if they stay in place.

The
.I WindowShadeSteps
option elects the number of steps for animation when shading a window with
.BR WindowShade .
It takes one number as its argument.  If the number has a trailing
.I ' p '
it sets the number of pixels to use as the step size instead of
a fixed number of steps.  0 disables the animation.  This happens
too if the argument is omitted or invalid.


.SS OTHER COMMANDS CONTROLLING WINDOW STYLES

.TP
.B "AddButtonStyle" "\fIbutton\fP [\fIstate\fP] [\fIstyle\fP] [-- \fI[!]flag ...\fP]"
Adds a button style to \fIbutton\fP.  \fIbutton\fP can be a button
number, or one of "All," "Left," or "Right."  \fIstate\fP can be
"ActiveUp," "ActiveDown", "Inactive",
"ToggledActiveUp," "ToggledActiveDown" or "ToggledInactive".
If \fIstate\fP is omitted, then the style is added to every state.  If the
button style and flags are enclosed in parentheses, then multiple state
definitions can be placed on a single line.  Flags for additional button
styles cannot be changed after definition.

Buttons are drawn in the order of definition, beginning with the most
recent button style, followed by those added with AddButtonStyle.  To
clear the button style stack, change style flags, or for descriptions
of available styles and flags, see the ButtonStyle command.  Examples:
.EX
ButtonStyle 1 Pixmap led.xpm -- Top Left
ButtonStyle 1 ActiveDown HGradient 8 grey \\
  black
ButtonStyle All --  UseTitleStyle
AddButtonStyle 1 ActiveUp (Pixmap a.xpm)  \\
  ActiveDown (Pixmap b.xpm -- Top)
AddButtonStyle 1 Vector 4 50x30@1 70x70@0 \\
  30x70@0 50x30@1
.EE
Initially for this example all button states are set to a pixmap.  The
second line replaces the ActiveDown state with a gradient (it
overrides the pixmap assigned to it in the line before, which assigned
the same style to every state).  Then, the UseTitleStyle flag is set
for all buttons, which causes fvwm to draw any styles set with
TitleStyle before drawing the buttons.  Finally, AddButtonStyle is
used to place additional pixmaps for both ActiveUp and ActiveDown
states and a Vector button style is drawn on top of all state.

.TP
.B "AddButtonStyle" "\fIbutton\fP [\fIstate\fP] [\fIstyle\fP] [-- \fI[!]flag ...\fP]"
Adds a button style to \fIbutton\fP.  \fIbutton\fP can be a button
number, or one of "All," "Left," or "Right."  \fIstate\fP can be

.TP
.B "AddTitleStyle" "[\fIstate\fP] [\fIstyle\fP] [-- \fI[!]flag ...\fP]"
Adds a title style to the title-bar.  \fIstate\fP should be one of
"ActiveUp," "ActiveDown", "Inactive",
"ToggledActiveUp," "ToggledActiveDown" or "ToggledInactive."
If \fIstate\fP is omitted,
then the style is added to every state.  If the style and flags are
enclosed in parentheses, then multiple state definitions can be placed
on a single line.  This command is quite similar to the AddButtonStyle
command (see above).

title-bars are drawn in the order of definition, beginning with the
most recent TitleStyle, followed by those added with AddTitleStyle.
To clear the title style stack, change style flags, or for the
descriptions of available styles and flags, see the TitleStyle and
ButtonStyle commands.

.TP
.B "AddToDecor" "\fIdecor\fP"
Add or divert commands to the decor named \fIdecor\fP.  A decor is a
name given to the set of commands which affect button styles,
title-bar styles, border styles and window fonts.  If
\fIdecor\fP does not exist it is created; otherwise the existing
\fIdecor\fP is modified.
Note: Earlier versions allowed to use the HilightColor,
HilightColorset and WindowFont commands in decors.  This is no
longer possible.  Please use the \fIStyle\fP command with the
Hilight... and Font options.

Created decors start out exactly like the default fvwm decor without
any style definitions.  A given decor may be applied to a set of
windows with the UseDecor option of the Style command.  Modifying an
existing decor will affect windows which are currently assigned to it.

AddToDecor is similar in usage to the AddToMenu and AddToFunc
commands, except that menus and functions are replaced by ButtonStyle,
AddButtonStyle, TitleStyle, AddTitleStyle and BorderStyle commands.
Decors created with AddToDecor can be manipulated with ChangeDecor,
DestroyDecor, UpdateDecor, and the UseDecor Style option.

The following example creates a decor 'FlatDecor' and style
'FlatStyle'.  They are distinct entities:
.EX
AddToDecor FlatDecor
 + ButtonStyle All ActiveUp (-- flat) \\
   Inactive (-- flat)
 + TitleStyle -- flat
 + BorderStyle -- HiddenHandles NoInset
 + Style FlatStyle UseDecor FlatDecor, \\
     Color white/grey40,HandleWidth 4

Style xterm UseStyle FlatStyle
.EE
An existing window's decor may be reassigned with ChangeDecor, or a
Style command followed by a Recapture.  The decorations of all windows
or of a specific decor can be updated with UpdateDecor (useful after
decorations are modified.  A decor can be destroyed with DestroyDecor.
If you change styles in the decor you must re-apply the style to
all windows that are supposed to do it followed by a Recapture:

.EX
AddToDecor FlatDecor
 + Style FlatStyle UseDecor FlatDecor, \\
     Color white/grey40,HandleWidth 4
.EE

and now apply the style again:

.EX
Style xterm UseStyle FlatStyle
.EE

A different way to achieve this to add the 'UseStyle' style
to the decor itself:

.EX
AddToDecor FlatDecor
 + Style xterm UseStyle FlatStyle
.EE

Although this is not obvious, decors can partially be nested
with the UseDecor style:

.EX
AddToDecor CommonDecor
 + Style * Forecolor black, Backcolor darkseagreen

AddToDecor FlatDecor
 + Style * UseDecor CommonDecor
...

AddToDecor RaisedDecor
 + Style * UseDecor CommonDecor
...
.EE

This works only with the 'Style' command.

.TP
.B "BorderStyle" "[\fIstate\fP] [\fIstyle\fP] [-- \fI[!]flag ...\fP]"
Defines a border style for windows.  \fIstate\fP can be either
"Active" or "Inactive."  If \fIstate\fP is omitted, then the style is
set for both states.  If the style and flags are enclosed in
parentheses, then multiple state definitions can be specified per
line.

\fIstyle\fP is a subset of the available button styles, and can only be
TiledPixmap (uniform pixmaps which match the bevel colors work best
this way).  If an "!"  is prefixed to any flag, flag behavior is
negated.  If \fIstyle\fP is not specified, then one can change flags
without resetting the style.

The \fIHiddenHandles\fP flag hides the corner handle dividing lines on
windows with handles (this option has no effect for NoHandle windows).
By default, HiddenHandles is disabled.

The \fINoInset\fP flag supplements HiddenHandles.  If given, the inner
bevel around the window frame is not drawn.  If HiddenHandles is not
specified, the frame will look a little strange.

The \fIRaised\fP causes a raised relief pattern to be drawn (default).
The \fISunk\fP causes a sunken relief pattern to be drawn.
The \fIFlat\fP inhibits the relief pattern from being drawn.

To decorate the active and inactive window borders with a textured
pixmap, one might specify:
.EX
BorderStyle Active TiledPixmap marble.xpm
BorderStyle Inactive TiledPixmap granite.xpm
BorderStyle Active -- HiddenHandles NoInset
.EE
To clear the style for both states:
.EX
BorderStyle Simple
.EE
To clear for a single state:
.EX
BorderStyle Active Simple
.EE
To unset a flag for a given state:
.EX
BorderStyle Inactive -- !NoInset
.EE
title-bar buttons can inherit the border style with the UseBorderStyle
flag (see ButtonStyle).

.TP
.B "ButtonState" "[\fIActiveDown\fP \fIbool\fP] [\fIinactive\fP \fIbool\fP]"
The \fIButtonState\fP command controls which states of the window
titles and title buttons are used.  The default is to use all three
states: ActiveUp, ActiveDown and Inactive (see \fIButtonStyle\fP and
\fITitleStyle\fP commands).  The \fIbool\fP argument after the key
word controls if the designated state is used ('True') or not
('False'). The ActiveUp state cannot be deactivated. If no arguments
are provided or the given arguments are illegal, the default is
restored.

The \fIActiveDown\fP state allows different button styles for pressed
down buttons and titles on active windows.  Otherwise the
"ActiveUp" state is used instead.  The \fIInactive\fP state allows
different button and title styles for inactive windows.  Otherwise
the "ActiveUp" state is used instead.

.TP
.B "ButtonStyle" "\fIbutton\fP [\fIstate\fP] [\fIstyle\fP] [-- \fI[!]flag ...\fP]"
Sets the button style for a title-bar button.  \fIbutton\fP is the
title-bar button number between 0 and 9, or one of "All," "Left,"
"Right," or "Reset."  Button numbering is described in the Mouse
section (see below).  If the style and flags are enclosed in
parentheses, then multiple state definitions can be specified per
line.

\fIstate\fP refers to which button state should be set.  Button states
are defined as follows: "ActiveUp" and "ActiveDown" refer to the
un-pressed and pressed states for buttons on active windows; while the
"Inactive" state denotes buttons on inactive windows. The "ToggledActiveUp",
"ToggledActiveDown" and "ToggledInactive" states are used instead for buttons
which have one of the MwmDecorMaximize, MwmDecorShade or MwmDecorStick
hints, if the window is maximized, shaded or sticky, respectively.
.EX
AddToDecor Default
 + ButtonStyle 6 All               \\
   Vector 4 50x25@1 85x75@0 15x75@0 50x25@1
 + ButtonStyle 6 ToggledActiveUp   \\
   Vector 4 50x75@0 85x25@1 15x25@0 50x75@0
 + ButtonStyle 6 ToggledActiveDown \\
   Vector 4 50x75@0 85x25@1 15x25@0 50x75@0
 + ButtonStyle 6 ToggledInactive   \\
   Vector 4 50x75@0 85x25@1 15x25@0 50x75@0
 + ButtonStyle 6 - MwmDecorShade
Mouse 0 6 N WindowShade
.EE
If \fIstate\fP is ActiveUp, ActiveDown, Inactive, or a toggled variant,
that particular button state is set.  If \fIstate\fP is omitted, every state
is set. Specifying a style destroys the current style (use AddButtonStyle to
avoid this).

If \fIstyle\fP is omitted, then state-dependent flags can be set for
the primary button style without destroying the current style.
Examples (each line should be considered independent):
.EX
ButtonStyle Left -- flat
ButtonStyle All ActiveUp (-- flat) \\
  Inactive (-- flat)
.EE
The first line sets every state of the left buttons to flat, while the
second sets only the ActiveUp and Inactive states of every button to
flat (only flags are changed; the buttons' individual styles are not
changed).

If you want to reset all buttons to their defaults:
.EX
ButtonStyle Reset
.EE
To reset the ActiveUp button state of button 1 to the default:
.EX
ButtonStyle 1 ActiveUp Default
.EE
To reset all button states of button 1 to the default of
button number 2:
.EX
ButtonStyle 1 Default 2
.EE

For any given button, multiple state definitions can be given on one
line by enclosing the style and flags in parentheses.  If only one
definition per line is given the parentheses can be omitted.

\fIflags\fP affect the specified \fIstate\fP.  If an "!" is prefixed
to any \fIflag\fP, its behavior is negated.  The available
state-dependent flags for all styles are described here (the next
ButtonStyle entry deals with state-independent flags).

"Raised" causes a raised relief pattern to be drawn.

"Sunk" causes a sunken relief pattern to be drawn.

"Flat" inhibits the relief pattern from being drawn.

"UseTitleStyle" causes the given button state to render the current
title style before rendering the button's own styles.  The Raised,
Flat, and Sunk TitleStyle flags are ignored since they are redundant
in this context.

"UseBorderStyle" causes the button to inherit the decorated
BorderStyle options.

Raised, Sunk, and Flat are mutually exclusive, and can be specified
for the initial ButtonStyle only.  UseTitleStyle and UseBorderStyle
are also mutually exclusive (both can be off however).  The default is
Raised with both UseBorderStyle and UseTitleStyle left unset.

There is an \fBimportant note\fP for the ActiveDown state.  When a
button is pressed, the relief is inverted.  Because of this, to obtain
a sunken ActiveDown state you must specify the opposite of the desired
relief (i.e. to obtain a pressed-in look which is raised, specify Sunk
for ActiveDown).  This behavior is consistent, but may seem confusing
at first.  The same applies to the toggled states.

Button styles are classified as non-destructive, partially destructive,
or fully destructive.  Non-destructive styles do not affect the image.
Partially destructive styles can obscure some or all parts of the
underlying image (i.e. Pixmap).  Fully destructive styles obscure the
entire underlying image (i.e. Solid or one of the gradient styles).
Thus, if stacking styles with AddButtonStyle (or AddTitleStyle for
title-bars), use care in sequencing styles to minimize redraw.

The available styles and their arguments now follow (depending on
compilation options, some button styles may be unavailable).

The "Simple" style does nothing.  There are no arguments, and this
style is an example of a non-destructive button style.

The "Default" style conditionally accepts one argument: a number which
specifies the default button number to load.  If the style command
given is ButtonStyle or AddButtonStyle, the argument is optional (if
given, will override the current button).  If a command other than
ButtonStyle or AddButtonStyle is used, the number must be specified.

The "Solid" style fills the button with a solid color.  The relief
border color is not affected.  The color should be specified as a
single argument.  This style is fully destructive.

The "Vector" style draws a line pattern.  Since this is a standard
button style, the keyword "Vector" is optional.  The specification is
a little cumbersome:
.EX
ButtonStyle 2 Vector 4 50x30@1 70x70@0 \\
  30x70@0 50x30@1
.EE
then the button 2 decoration will use a 4-point pattern consisting of
a line from (x=50,y=30) to (70,70) in the shadow color (@0), and then
to (30,70) in the shadow color, and finally to (50,30) in the
highlight color (@1).  Is that too confusing? See the fvwm web pages
for a few examples.  You can use up to 32 points in a line pattern.
This style is partially destructive.

The "?Gradient" styles denote color gradients.  Fill in the question
mark with any one of the defined gradient types.  Please refer to
the \fICOLOR GRADIENTS\fP section below for a description of the
gradient syntax.

The gradient styles are fully destructive.

The "Pixmap" style displays a pixmap.  A pixmap should be specified as
an argument.  For example, the following would give button 2 the same
pixmap for both states, and button 4 different pixmaps for the up,
down and inactive states.
.EX
ButtonStyle 2 Pixmap my_pixmap.xpm
ButtonStyle 4 ActiveUp (Pixmap up.xpm) \\
  ActiveDown (Pixmap down.xpm)
ButtonStyle 4 Inactive Pixmap inactive.xpm
.EE
The pixmap specification can be given as an absolute or relative
pathname (see \fIImagePath\fP).  If the pixmap cannot be found, the button
style reverts to Simple.  Flags specific to the Pixmap style are
"Left," "Right," "Top," and "Bottom."  These can be used to justify
the pixmap (default is centered for both directions).  Pixmap
transparency is used for the color "None."  This style is partially
destructive.

The "MiniIcon" style draws the window's miniature icon in the button,
which is specified with the MiniIcon option of the Style command. This
button style accepts no arguments.  Example:
.EX
Style *     MiniIcon mini-bx2.xpm
Style xterm MiniIcon mini-term.xpm
Style Emacs MiniIcon mini-doc.xpm

ButtonStyle 1 MiniIcon
.EE

The "TiledPixmap" style accepts a pixmap to be tiled as the button
background.  One pixmap is specified as an argument.  Pixmap
transparency is not used.  This style is fully destructive.

.TP
.B "ButtonStyle" "\fIbutton\fP - \fI[!]flag ...\fP"
Sets state-independent flags for the specified \fIbutton\fP.
State-independent flags affect button behavior.  Each flag is
separated by a space.  If an "!" is prefixed to the flag then the flag
behavior is negated.  The special flag "Clear" clears any existing
flags.

The following flags are usually used to tell fvwm which buttons should
be affected by Mwm function hints.  This is not done automatically
since you might have buttons bound to complex functions, for instance.

"MwmDecorMenu" should be assigned to title-bar buttons which display a
menu.  The default assignment is the leftmost button.  When a window
with the MwmFunctions Style option requests not to show this button,
it will be hidden.

"MwmDecorMin" should be assigned to title-bar buttons which minimize
or iconify the window.  The default assignment is the second button
over from the rightmost button.  When a window with the MwmFunctions
Style option requests not to show this button, it will be hidden.

"MwmDecorMax" should be assigned to title-bar buttons which maximize
the window.  The default assignment is the rightmost button.  When a
window with the MwmFunctions Style option requests not to show this
button, it will be hidden.  When the window is maximized, the vector
pattern on the button looks pressed in.

"MwmDecorShade" should be assigned to title-bar buttons which shade
the window (see \fIWindowShade\fP command).  When a window with the
MwmFunctions Style option requests not to show the minimize button,
this button will be hidden.  When the window is shaded, the vector
pattern on the button looks pressed in.

"MwmDecorStick" should be assigned to title-bar buttons which make
the window sticky.  When the window is sticky, the vector pattern on
the button looks pressed in.

.TP
.B "ChangeDecor" "\fIdecor\fP"
Changes the decor of a window to \fIdecor\fP.  \fIdecor\fP is
"Default" or the name of a decor defined with AddToDecor.  If
\fIdecor\fP is invalid, nothing occurs.  If called from somewhere in a
window or its border, then that window is affected.  If called from
the root window the user will be allowed to select the target window.
ChangeDecor only affects attributes which can be set using the
AddToDecor command.
.EX
ChangeDecor CustomDecor1
.EE

.TP
.B "DestroyDecor" "\fIdecor\fP"
Deletes the \fIdecor\fP defined with AddToDecor, so that subsequent
references to it are no longer valid.  Windows using this \fIdecor\fP
revert to the default fvwm decor.  The decor named "Default" cannot be
destroyed.
.EX
DestroyDecor CustomDecor1
.EE

.TP
.B "DestroyStyle" "\fIstyle\fP"
Deletes the style named "\fIstyle\fP". This will not affect currently visible
windows (they each have a copy of their styles, which will remain unaffected).
Note that \fPstyle\fP is not a wild-carded search string, but rather a
case-sensitive string that should exactly match the original \fBStyle\fP
command.

Destroying style \fI*\fP can be done, but isn't really to be recommended!
For example:
.EX
DestroyStyle Application*
.EE

This will remove all settings for the style named "\fIApplication*\fP", NOT all
styles starting with "Application".

.TP
.B "TitleStyle" "[\fIjustification\fP] [\fIheight\fP [\fInum\fP]]"
Sets attributes for the title-bar.  Justifications can be "Centered",
"RightJustified," or "LeftJustified."  \fIheight\fP sets the title
bar's height to an amount in pixels.  Defaults are Centered and
window's font height.  To reset the font height to the default value,
omit the \fInum\fP argument after the 'height' keyword.  Example:
.EX
TitleStyle LeftJustified Height 24
.EE

.TP
.B "TitleStyle" "[\fIstate\fP] [\fIstyle\fP] [-- \fI[!]flag ...\fP]"
Sets the style for the title-bar.  \fIstate\fP can be one of
"ActiveUp," "ActiveDown," or "Inactive."  If \fIstate\fP is omitted,
then the style is added to every state.  If parentheses are placed
around the style and flags, then multiple state definitions can be
given per line.  \fIstyle\fP can be omitted so that flags can be set
while not destroying the current style.

If an "!" is prefixed to any \fIflag\fP, its behavior is negated.
Valid flags for each state include "Raised," "Flat," and "Sunk" (these
are mutually exclusive).  The default is Raised.  See the note in
ButtonStyle regarding the ActiveDown state.  Examples:
.EX
TitleStyle ActiveUp HGradient 16 navy black
TitleStyle ActiveDown (Solid red -- flat) \\
  Inactive (TiledPixmap wood.xpm)
TitleStyle ActiveUp (-- Flat) ActiveDown  \\
  (-- Raised) Inactive (-- Flat)
.EE
This sets the ActiveUp state to a horizontal gradient, the ActiveDown
state to solid red, and the Inactive state to a tiled wood pixmap.
Finally, ActiveUp is set to look flat, while ActiveDown set to be sunk
(the Raised flag for the ActiveDown state causes it to appear Sunk due
to relief inversion), and Inactive is set to flat as well.  An example
which sets flags for all states:
.EX
TitleStyle -- flat
.EE
For a flattened look:
.EX
TitleStyle -- flat
ButtonStyle All ActiveUp (-- flat) Inactive \\
  (-- flat)
.EE

.TP
.B "UpdateDecor" "[\fIdecor\fP]"
Updates window decorations.  \fIdecor\fP is an optional argument which
specifies the \fIdecor\fP to update.  If given, only windows which are
assigned to that particular \fIdecor\fP will be updated.  This command
is useful, for instance, after a ButtonStyle, TitleStyle or
BorderStyle (possibly used in conjunction with AddToDecor).
Specifying an invalid decor results in all windows being updated.
This command is less disturbing than Recapture, but does not affect
window style options as Recapture does.


.SS COMMANDS CONTROLLING THE VIRTUAL DESKTOP

.TP
.B "Desk" "\fIarg1\fP [\fIarg2\fP] [\fImin max\fP]"
This command has been renamed. Please see \fIGotoDesk\fP command.

.TP
.B "DeskTopSize" "\fIHorizontal\fPx\fIVertical\fP"
Defines the virtual desktop size in units of the physical screen size.

.TP
.B "EdgeResistance" "\fIscrolling moving\fP"
Tells how hard it should be to change the desktop viewport by moving
the mouse over the edge of the screen and how hard it should be to
move a window over the edge of the screen.

The first parameter tells how many milliseconds the pointer must spend on
the screen edge before fvwm will move the viewport.  This is
intended for people who use "EdgeScroll 100 100" but find themselves
accidentally flipping pages when they don't want to.

The second parameter tells how many pixels over the edge of the screen
a window's edge must move before it actually moves partially off the
screen. By default the viewport is moved a full page in the requested
direction, but if you used \fIEdgeScroll\fP and set any values other
than zero they will be used instead.

Note that, with "EdgeScroll 0 0", it is still possible to move or
resize windows across the edge of the current screen.  By making the
first parameter to EdgeResistance 10000 this type of motion is
impossible.  With EdgeResistance less than 10000 but greater than 0
moving over pages becomes difficult but not impossible.
See also, EdgeThickness.

.TP
.B "EdgeScroll" "\fIhorizontal vertical\fP"
Specifies the percentage of a page to scroll when the cursor hits the
edge of a page.  A trailing 'p' changes the interpretation to mean "pixels".
If you don't want any paging or scrolling when you hit the edge of a
page include "EdgeScroll 0 0" in your
.I .fvwm2rc
file, or possibly better, set the EdgeThickness to zero.
See the EdgeThickness command. If you want whole
pages, use "EdgeScroll 100 100".  Both horizontal and vertical should
be positive numbers.

If the horizontal and vertical percentages are multiplied by 1000 then
scrolling will wrap around at the edge of the desktop.  If "EdgeScroll
100000 100000" is used fvwm will scroll by whole pages, wrapping
around at the edge of the desktop.

.TP
.B "EdgeThickness" "\fI0\fP|\fI1\fP|\fI2\fP"
This is the width or height of the invisible window that fvwm creates
on the edges of the screen that are used for the edge scrolling feature.

A value of  zero completely disables  mouse edge scrolling, even while
dragging a window.

1 gives the  smallest pan frames,  which seem to  work best  except on
some servers.

2 is the default.

Pan frames of 1 or 2 pixels can sometimes be confusing, for example,
if you drag a window over the edge of the screen, so that it straddles
a pan frame, clicks on the window, near the edge of the screen are
treated as clicks on the root window.

.TP
.B "GotoDesk" "\fIarg1\fP [\fIarg2\fP] [\fImin max\fP]"
Switches the current viewport to another desktop (workspace, room).

The command takes 1, 2, 3, or 4 arguments. A single argument is
interpreted as a relative desk number. Two arguments are understood
as a relative and an absolute desk number. Three arguments specify
a relative desk and the minimum and maximum of the allowable range.
Four arguments specify the relative, absolute, minimum and maximum
values. (Desktop numbers can be negative.)

If \fIarg1\fP is non zero then the next desktop number will be the
current desktop number plus \fIarg1\fP.

If \fIarg1\fP is zero then the new desktop number will be \fIarg2\fP.
(If \fIarg2\fP is not present, then the command has no effect.)

If \fImin\fP and \fImax\fP are given, the new desktop number will
be no smaller than min and no bigger than max. Values out of this
range are truncated (if you gave an absolute desk number) or wrapped
around (if you gave a relative desk number).

The syntax is the same as for \fIMoveToDesk\fP, which moves a window
to a different desktop.

The number of active desktops is determined dynamically.  Only
desktops which contain windows or are currently being displayed are
active.  Desktop numbers must be between 2147483647 and -2147483648
(is that enough?).

.TP
.B "GotoPage" "\fIx y\fP"
Moves the desktop viewport to page (x,y).  The upper left page is
(0,0), the upper right is (M,0), where M is one less than the current
number of horizontal pages specified in the DeskTopSize command.  The
lower left page is (0,N), and the lower right page is (M,N), where N
is the desktop's vertical size as specified in the DeskTopSize
command.  To switch to a page relative to the current one add a
trailing 'p' after any or both numerical arguments.  To go to
last visited page use \fIprev\fP as the first argument.  The GotoPage
function should not be used in a pop-up menu.

Examples:
.EX
# Go to page (2,3)
GotoPage 2 3

# Go to lowest and rightmost page
GotoPage -1 -1

# Go to last page visited
GotoPage prev

# Go two pages to the right and one page up
GotoPage +2p -1p
.EE

.TP
.B "Scroll" "\fIhorizonal vertical\fP"
Scrolls the virtual desktop's viewport by \fIhorizontal\fP pages in
the x-direction and \fIvertical\fP pages in the y-direction.  Either
or both entries may be negative.  Both horizontal and vertical values
are expressed in percent of pages, so "Scroll 100 100" means to scroll
down and left by one full page.  "Scroll 50 25" means to scroll left
half a page and down a quarter of a page.  The scroll function should
not be called from pop-up menus. Normally, scrolling stops at the edge
of the desktop.

If the horizontal and vertical percentages are multiplied by 1000 then
scrolling will wrap around at the edge of the desktop.  If "Scroll
100000 0" is executed over and over fvwm will move to the next
desktop page on each execution and will wrap around at the edge of the
desktop, so that every page is hit in turn.

If the letter 'p' is appended to each coordinate (horizontal and/or
vertical), then the scroll amount will be measured in pixels.


.SS COMMANDS FOR USER FUNCTIONS AND SHELL COMMANDS

.TP
.B "AddToFunc" "[\fIname\fP [\fItrigger\fP \fIaction\fP]]"
Begins or add to a function definition.  Here's an example:
.EX
AddToFunc Move-or-Raise I Raise
 + M Move
 + D Lower
.EE
The function name is Move-or-Raise, and could be invoked from a menu
or a mouse binding or key binding:
.EX
Mouse 1 TS A Move-or-Raise
.EE
The quoted portion of the function tells what kind of action will
trigger the command which follows it.  'I' stands for Immediate, and is
executed as soon as the function is invoked.  'M' stands for Motion, i.e.
if the user starts moving the mouse.  'C' stands for Click, i.e., if the
user presses and releases the mouse.  'H' stands for Hold, i.e. if the
user presses a mouse button and holds it down for more that ClickTime
milliseconds.  'D' stands for double-click. The action 'I' will cause
an action to be performed on the button-press, if the function is
invoked with prior knowledge of which window to act on.

There is a number of predefined symbols that are replaced by
certain values if they appear on the command line.  Please
refer to the \fICOMMAND LINE PARAMETER EXPANSION\fP section for details.

Examples:

If you call
.EX
Key F10 R A Function MailFunction \\
  xmh "-font fixed"
.EE
and MailFunction is

.EX
AddToFunc MailFunction
 + I Next ($0) Iconify off
 + I Next ($0) focus
 + I None ($0) Exec exec $0 $1
.EE
Then the last line of the function becomes
.EX
 + I None (xmh) Exec exec xmh -font fixed
.EE
The expansion is performed as the function is executed, so you can use the
same function with all sorts of different arguments.  You could use
.EX
Key F11 R A Function MailFunction \\
  zmail "-bg pink"
.EE
in the same
.IR .fvwm2rc ,
if you wanted.  An example of using $w is:
.EX
AddToFunc PrintFunction
 + I Raise
 + I Exec xdpr -id $w
.EE
Note that $$ is expanded to $.

Another example: bind right mouse button within the window button number 6
(this is a minimize button for the win95 theme) to iconify all windows of
the same resource:
.EX
AddToFunc FuncIconifySameResource "I" \\
  All ($r) Iconify on
Mouse 3 6 A FuncIconifySameResource
.EE

.TP
.B "Beep"
As might be expected, this makes the terminal beep.

.TP
.B "DestroyFunc" "\fIfunction\fP"
Deletes a function, so that subsequent references to it are no longer
valid.  You can use this to change the contents of a function during an
fvwm session.  The function can be rebuilt using AddToFunc.
.EX
DestroyFunc PrintFunction
.EE

.TP
.B "Echo" "\fIstring\fP"
Prints a message to stderr.  Potentially useful for debugging things
in your
.IR .fvwm2rc .
.EX
Echo Beginning style definitions...
.EE

.TP
.B "Exec" "\fIcommand\fP"
Executes \fIcommand\fP.  You should not use an ampersand ``&'' at the
end of the command.  You probably want to use an additional ``exec'' at
the beginning of \fIcommand\fP.  Without that, the shell that fvwm
invokes to run your command will stay until the command exits.  In
effect, you'll have twice as many processes running as you need.
Note that some shells are smart enough to avoid this, but it never hurts
to include the ``exec'' anyway.

The following example binds function key F1 in the root window, with
no modifiers, to the exec function.  The program rxvt will be started
with an assortment of options.
.EX
Key F1 R N Exec exec rxvt -fg yellow -bg blue \\
  -e /bin/tcsh
.EE

Note that this function doesn't wait for \fIcommand\fP to complete, so
things like:
.EX
Exec "echo AddToMenu ... > /tmp/file"
Read /tmp/file
.EE
won't work reliably.

.TP
.B "ExecUseShell" "[\fIshell\fP]"
Makes the Exec command use the specified shell, or the value of the
$SHELL environment variable if no shell is specified, instead of the
default Bourne shell (/bin/sh).
.EX
ExecUseShell
ExecUseShell /usr/local/bin/tcsh
.EE

.TP
.B "Function" "\fIFunctionName\fP"
Used to bind a previously defined function to a key or mouse button.

The following example binds mouse button 1 to a function called
"Move-or-Raise", whose definition was provided as an example earlier
in this man page.  After performing this binding fvwm will
execute to move-or-raise function whenever button 1 is pressed in a
window title-bar.
.EX
Mouse 1 T A Function Move-or-Raise
.EE
The keyword "Function" may be omitted if "FunctionName" does not
coincide with an fvwm built-in function name

.TP
.B "Nop"
Does nothing.  This is used to insert a blank line or separator in a
menu.  If the menu item specification is Nop " ", then a blank line is
inserted.  If it looks like Nop "", then a separator line is inserted.
Can also be used as the double-click action for Menu.

.TP
.B "PipeRead" "\fIcommand\fP [\fI quiet \fP]"
Causes fvwm to read commands from the output of the \fIcommand\fP.
This command is executed by /bin/sh as if you typed it on the command
line.  If the command consists of more than one word it must be quoted.
Useful for building up dynamic menu entries based on a
directories contents, for example.  If the keyword "Quiet" follows the
command no message is produced if the command is not found.

Example:
.EX
AddToMenu HomeDirMenu
PipeRead 'for i in $HOME;
  do echo "+ $i Exec vi $i"; done'
.EE

.TP
.B "Read" "\fIfilename\fP [\fI quiet \fP]"
Causes fvwm to read commands from the file named \fIfilename\fP.
If the keyword "Quiet" follows the command no message is produced
if the file is not found.  If the file name does not begin with a
slash, fvwm looks in the users configuration directory, then the
system configuration directory.

The users configuration directory is $HOME.  $HOME can be overridden
by exporting FVWM_USERHOME set to a directory.

.TP
.B "SetEnv" "\fIvarname stringvalue\fP"
Set an environment variable to a new value, similar to shell's export
or setenv command.  The variable and its value are inherited by processes
started directly by fvwm.  This can be especially useful in conjunction
with the FvwmM4 module; e.g.  "SetEnv height HEIGHT" will make the FvwmM4-set
variable "HEIGHT" usable by processes started by fvwm as the environment
variable "$height".  If \fIstringvalue\fP includes whitespace, you should
enclose it in quotes.

.TP
.B "Silent" "\fIcommand\fP"
A number of builtin functions require a window to operate on. If no
window was selected when such a function is invoked the user is asked
to select a window. Sometimes this behavior is unwanted, for example
if the function was called by a module and the window that was
selected at first does not exist anymore. You can prevent this by
putting \fISilent\fP in front of the \fIcommand\fP. If a function that needs
a window is called with \fISilent\fP without a window selected, it simply
returns without doing anything. If \fISilent\fP is used on a user defined
function it affects all function and sub function calls until the
original function exits.

Examples:
.EX
Silent Move 0 0
Silent User_defined_function
.EE

.TP
.B "Wait" "\fIname\fP"
This built-in is intended to be used in fvwm functions only.  It
causes execution of a function to pause until a new window name
\fIname\fP appears. Fvwm remains fully functional during a wait.
This is particularly useful in the InitFunction if you are trying to
start windows on specific desktops:
.EX
AddToFunc InitFunction
 + I exec xterm -geometry 80x64+0+0
 + I Wait xterm
 + I Desk 0 2
 + I Exec exec xmh -font fixed -geometry \\
       507x750+0+0
 + I Wait xmh
 + I Desk 0 0
.EE
The above function starts an xterm on the current desk, waits for it
to map itself, then switches to desk 2 and starts an xmh.  After the
xmh window appears control moves to desk 0.

You can escape from a Wait pause by using Ctrl-Alt-Escape (where Alt is
the first modifier). To redefine this key sequence see the \fIEscapeFunc\fP
command.


.SS CONDITIONAL COMMANDS

.TP
.B "All" "[ (\fIconditions\fP) ] \fIcommand\fP"
Execute \fIcommand\fP on all windows meeting the conditions.
Conditions are used exactly as with the Current command.

.TP
.B "Current" "[ (\fIconditions\fP) ] \fIcommand\fP"
Performs \fIcommand\fP on the current window if it satisfies all
\fIconditions\fP.  Conditions include "Iconic", "!Iconic", "Visible",
"!Visible", "Raised", "!Raised", "Layer [n]", "Sticky", "!Sticky",
"Maximized", "!Maximized", "Shaded", "!Shaded", "Transient", "!Transient",
"CurrentDesk", "CurrentPage", and "CurrentPageAnyDesk".
In addition, the condition may include one window name to match to.
The window name may include
the wildcards * and ?.  The window name, icon name, class, and
resource will be considered when attempting to find a match.  The
window name can begin with ! which will prevent \fIcommand\fP if any
of the window name, icon name, class or resource match.

The argument of the "Layer" condition defaults to the layer of the
focus window.

Note that earlier versions of fvwm required the conditions to be
enclosed in brackets instead of parentheses (this is still supported
for backwards compatibility).

.TP
.B "Direction" "\fIdirection\fP [ (\fIconditions\fP) ] \fIcommand\fP"
Performs \fIcommand\fP (typically Focus) on a window in the given
direction which satisfies all \fIconditions\fP.  Conditions are the same
as for \fICurrent\fP. The \fIdirection\fP may be one of North, Northeast,
East, Southeast, South, Southwest, West and Northwest. Which window
Direction selects depends on angle and distance between the center points
of the windows. Closer windows are considered a better match than
those farther away.

.TP
.B "Next" "[ (\fIconditions\fP) ] \fIcommand\fP"
Performs \fIcommand\fP (typically Focus) on the next window which
satisfies all \fIconditions\fP.  Conditions are the same as for \fICurrent\fP
with the addition of CirculateHit which overrides the CirculateSkip style
attribute, CirculateHitIcon which overrides the CirculateSkipIcon style
attribute for iconified windows and CirculateHitShaded which does the
same for shaded windows.

.TP
.B "None" "[ (\fIconditions\fP) ] \fIcommand\fP"
Performs \fIcommand\fP if no window which satisfies all
\fIconditions\fP exists.  Conditions are the same as for \fINext\fP.

.TP
.B "Pick" "[ (\fIconditions\fP) ] \fIcommand\fP"
Pick works like Function if invoked in the context of a window. If
invoked in root context, it first asks the user to pick a window and
then executes the command in the context of that window. This avoids
annoying multiple selections with complex functions.  The command is
executed only if the given \fIConditions\fP are met.  The Conditions
are the same as for \fINext\fP.

.TP
.B "Prev" "[ (\fIconditions\fP) ] \fIcommand\fP"
Performs \fIcommand\fP (typically Focus) on the previous window which
satisfies all \fIconditions\fP.  Conditions are the same as for \fINext\fP.

.TP
.B "WindowId" "\fIid [ (\fIconditions\fP) ] func\fP"
The WindowId function is similar to the Next and Prev functions, except
that it looks for a specific window \fIid\fP and runs the specified
\fIfunc\fP on it. The optional \fIconditions\fP are the same as for
\fICurrent\fP.
.EX
WindowId 0x34567890 Raise
WindowId 0x34567890 WarpToWindow 50 50
WindowId $0 (Silly_Popup) Delete
.EE
Mostly this is useful for functions used with the WindowList builtin,
or for selective processing of FvwmEvent calls (as in the last example).


.SS MODULE COMMANDS

.TP
.B "DestroyModuleConfig" "\fImodule\fP"
Deletes module configuration entries, so that new configuration lines
may be entered instead.  You can use this to change the the way a
module runs during an fvwm session without restarting.  Wildcards can
be used for portions of the name as well.
.EX
DestroyModuleConfig FvwmFormFore
DestroyModuleConfig FvwmButtons*
.EE

.TP
.B "KillModule" "\fIname\fP"
Causes the module which was invoked with name \fIname\fP to be killed.
\fIname\fP may include wild-cards.

.TP
.B "Module" "\fIModuleName\fP"
Specifies a module which should be spawned during initialization.  At
the current time the available modules (included with fvwm) are
FvwmAnimate (fancy animation of (de)iconification) FvwmAudio (makes
sounds to go with window manager actions), FvwmAuto
(an auto raise module), FvwmBacker (to change the background when you
change desktops), FvwmBanner (to display a spiffy XPM), FvwmButtons
(brings up a customizable tool bar), FvwmCpp (to preprocess your
.I .fvwm2rc
with cpp), FvwmEvent (trigger various actions by events), FvwmForm
(to bring up dialogs), FvwmIconBox (like the mwm IconBox), FvwmIconMan
(like the twm icon manager), FvwmIdent (to get window info), FvwmM4
(to preprocess your
.I .fvwm2rc
with m4), FvwmPager (a mini version of
the desktop), FvwmSave (saves the desktop state in .xinitrc style),
FvwmSaveDesk (saves the desktop state in fvwm commands), FvwmScroll
(puts scrollbars on any window),
FvwmWinList (a window list), FvwmAnimate (produces
animation effects when a window is iconified or de-iconifed).
.\" Note: The "Optional Module Name" description is missing.
These modules have their own man pages.  There are other modules out
on there as well.

Modules can be short lived transient programs or, like FvwmButtons,
can remain for the duration of the X session.  Modules will be
terminated by the window manager prior to restarts and quits, if
possible.  See the introductory section on modules.  The keyword
"module" may be omitted if \fIModuleName\fP is distinct from all
built-in and function names.

.TP
.B "ModulePath \fIpath\fP"
Specifies a colon separated list of directories in which to search for
modules.  To find a module, fvwm searches each directory in turn
and uses the first file found.  Directory names on the list do not
need trailing slashes.

The ModulePath may contain environment variables such as $HOME (or
${HOME}).  Further, a '+' in the path is expanded to the previous
value of the path, allowing easy appending or prepending to the path.

For example:
.EX
ModulePath ${HOME}/lib/fvwm/modules:+
.EE

The directory containing the standard modules is available via the
environment variable $FVWM_MODULEDIR.

.TP
.B "ModuleSynchronous" "[\fIExpect string\fP] [\fITimeout seconds\fP] \fIModuleName\fP"
The \fIModuleSynchronous\fP command is very similar to \fIModule\fP.
Fvwm stops processing any commands and user input until the module
sends a string beginning with "FINISHED_STARTUP" back to fvwm. If
the optional \fITimeout\fP is given fvwm gives up if the module sent
no input back to fvwm for \fIsec\fP seconds. If the \fIExpect\fP
option is given, fvwm waits for the given \fIstring\fP instead.
\fIModuleSynchronous\fP should only be used during fvwm startup to
enforce the order in which modules are started. This command is
intended for use with the \fIFvwmTheme\fP module since the
configuration must be in place before any other modules are started.

Warning: It is quite easy to hang fvwm with this command, even if
a timeout is given. Be extra careful to choose the string to wait.
Although all modules in the fvwm distribution send back the
"FINISHED_STARTUP" string once they have properly started up,
this may not be the case for third party modules. Moreover,
you can try to escape from a locked ModuleSynchronous command by using
the key sequence Ctrl-Alt-Escape (see the \fIEscapeFunc\fP).

.TP
.B "SendToModule" "\fImodulename string\fP"
Sends an arbitrary string (no quotes required) to all modules matching
\fImodulename\fP, which may contain wildcards.  This only makes sense
if the module is set up to understand and deal with these strings
though...  Can be used for module to module communication, or
implementation of more complex commands in modules.


.SS QUIT, RESTART AND SESSION MANAGEMENT COMMANDS

.TP
.B "Quit"
Exits fvwm, generally causing X to exit too.

.TP
.B "QuitScreen"
Causes fvwm to stop managing the screen on which the command was issued.

.TP
.B "QuitSession"
Causes a session manager (if any) to shutdown the session.

This command does not work for xsm, it seems that xsm didn't implement this
functionality. Use unix signals to manage xsm remotely.

.TP
.B "Restart" "[\fIWindowManagerName\fP [\fIparams\fP]]"
Causes fvwm to restart itself if \fIWindowManagerName\fP is
left blank, or to switch to an alternate window manager (or other fvwm
version) if \fIWindowManagerName\fP is specified.  If the window
manager is not in your default search path, then you should use the
full path name for \fIWindowManagerName\fP.

This command should not have a trailing ampersand. The command can have
optional parameters with simple shell-like syntax. You can use
.I ~
(will be expanded to user home directory) and environmental variables
.IR $VAR " or " ${VAR} .
Here are several examples:
.EX
Key F1 R N Restart fvwm2
Key F1 R N Restart /home/nation/bin/fvwm2
Key F1 R N Restart ~/bin/fvwm2 -f $HOME/.fvwm/main
Key F1 R N Restart fvwm1 -s -f .fvwm1rc
Key F1 R N Restart xterm -n '"X console"' \\
  -T \\"X\\ console\\" -e fvwm1 -s
.EE

.TP
.B "Restart" "--pass-args \fIWindowManagerName\fP"
The same as 'Restart' without parameters but the name for a window manager
is replaced with the specified \fIWindowManagerName\fP and original arguments
are preserved.

This command is useful if you use initial arguments (like "-cmd FvwmCpp")
and want to switch to another fvwm version without losing the initial
arguments.

.TP
.B "Restart" "--dont-preserve-state [\fIother-params\fP]"
The same as 'Restart [other-params]', but it does not save any window states
over the restart.

Without this option, Restart command preserves most per-window state
by writing it to a file named
.I .fs-restart
in the user's home directory.

.TP
.B "SaveSession"
Causes a session manager (if any) to save the session.

This command does not work for xsm, it seems that xsm didn't implement this
functionality. Use unix signals to manage xsm remotely.

.TP
.B "SaveQuitSession"
Causes a session manager (if any) to save and then shutdown the session.

This command does not work for xsm, it seems that xsm didn't implement this
functionality. Use unix signals to manage xsm remotely.


.SS COLOR GRADIENTS

A color gradient is a background that changes its color gradually
from one hue to a different one.  Color gradients can be used by
various commands and modules of fvwm.  There are eight types of
gradients: HGradient is a horizontal gradient; VGradient is vertical;
DGradient is diagonal from top left to bottom right; BGradient is
backwards diagonal from bottom left to top right; SGradient is
concentric squares; CGradient is con-centric circles; RGradient is
a radar like pattern and YGradient is a Yin Yang style (but without
the dots).

The color gradient syntax has two forms:

.TP
.B "?Gradient" "\fIcolors start-color end-color\fP"
This form specifies a linear gradient.  The arguments denote the
total number of \fIcolors\fP to allocate (between 2 and 1000), the
initial color and the final color.

Example:
.EX
TitleStyle VGradient 20 rgb:b8/ce/bc rgb:5b/85/d0
.EE

.TP
.B "?Gradient" "\fIcolors segments color length color\fP [\fIlength color\fP] ..."
The second form specifies a nonlinear gradient.  The arguments are:
the total number of \fIcolors\fP to allocate (between 2 and 1000),
then the number of \fIsegments\fP.  For each segment, specify the
starting \fIcolor\fP, a relative \fIlength\fP, then the ending
color.  Each subsequent segment begins with the second color of
the last segment.  The lengths may be any non-negative integers.
The length of one segment divided by the sum of all segment's lengths
is the fraction of the colors that are used for the segment.
.in -2

Examples:
.EX
MenuStyle * MenuFace DGradient \\
  128 2 lightgrey 50 blue 50 white

# 20% gradient from red to blue,
# 30% from blue to black,
# 50% from black to grey
MenuStyle * DGradient 100 3 Red 20 Blue 30 \\
  Black 50 Grey

# 50% from blue to green, then
# 50% from yellow to red
*FvwmThemeColorset 0 Blue Red HGradient \\
  128 3 Blue 1000 Green 1 Yellow 1000 Red
.EE


.SH ENVIRONMENT
.TP
.I DISPLAY
Fvwm starts on this display unless the
.I -display
option is given.
.TP
.I FVWM_MODULEDIR
Set by fvwm to the directory containing the standard fvwm
modules.
.TP
.I SESSION_MANAGER
Fvwm tries to contact this session manager.
.TP
.I SM_SAVE_DIR
If this is set, fvwm saves its session data in this directory. Otherwise
it uses
.IR $HOME .
Note, the saved files are named
.I .fs-??????
and normally will be removed automatically when not used anymore.

.SH AUTHORS
Robert Nation with help from many people, based on twm code,
which was written by Tom LaStrange.  After Robert Nation came Charles Hines,
followed by Brady Montz. Currently fvwm is maintained by a number of people
on the fvwm-workers mailing list.

.SH COPYRIGHT
Fvwm and all the modules, scripts and other files coming with
the distribution are subject to the GNU Public License.  Please
refer to the
.I COPYING
file that came with fvwm for details.

.SH BUGS
As of fvwm version 2.3.14 there were exactly 71.8 unidentified bugs.
Since then 22.825 bugs have been fixed.  Assuming that there are
at least 10 unidentified bugs for every identified one, that leaves
us with 71.8 - 22.825 + 10 * 22.825 = 277.225 unidentified bugs.
If we follow this to its logical conclusion we will have an infinite
number of unidentified bugs before the number of bugs can start
to diminish, at which point the program will be bug-free.  Since
this is a computer program infinity = 3.4028e+38 if you don't insist
on double-precision.  At the current rate of bug discovery we should
expect to achieve this point in 4.27e+27 years.  I guess we better
plan on passing this thing on to our children....

Known bugs can be found in the fvwm bug tracking system (accessible
from the fvwm home page) and in the
.IR BUGS " or " TO-DO
files in the distribution.  These files are no longer maintained
and may be out of date.

Bug reports can be sent to the fvwm workers' mailing list (see the
.BR FAQ ).
\"  LocalWords:  XTerm rc
