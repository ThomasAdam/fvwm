#!/bin/sh

# Based on fvwmrc_convert.
# Convert .fvwm2rc from 2.2.x format to 2.4.x format.

# Originally written by Dan Espen <despen@telcordia.com>

echo ".fvwm2rc to ./fvwm/.fvwm2rc" >&2

# gawk has IGNORECASE, so we use it if possible.
if [ -n "`command -v gawk 2>/dev/null`" ] ; then
   AWK=`command -v gawk`
elif [ -x /usr/bin/gawk ] ; then
   AWK=/usr/bin/gawk
elif [ -n "`command -v nawk 2>/dev/null`" ] ; then
   AWK=`command -v nawk`
elif [ -n "`command -v awk 2>/dev/null`" ] ; then
   AWK=`command -v awk`
elif [ -x /usr/bin/awk ] ; then
   AWK=/usr/bin/awk
fi

if [ ! -x $AWK ]; then
   echo "Can't find any awk, cannot run!" >&2
   exit 1
fi

source=${1:-$HOME/.fvwm2rc}
#source=${1:-$HOME/.fvwm2rc.test} # dje, remove this (some test cases in here)
if [ ! -r $source ] ; then
	echo "Can't find source file $source, giving up" >&2
	exit 1
fi

#dest=${2:-/tmp/.fvwm/.fvwm2rc}  # dje, testing again, remove this.
dest=${2:-$HOME/.fvwm/.fvwm2rc}
if [ "$dest" != "-" ] ;then
  echo "Output to $dest" >&2
  # This may not be the best way to go, if $dest exists, don't run at all...?
  if [ -f $dest ] ; then
    echo "Saving existing $dest as $dest.bak" >&2
    cp -p $dest $dest.bak || { echo "Couldn't save; aborting" >&2; exit 1; }
  else
    cp -p $source $dest 2>/dev/null  # try to preserve permissions
  fi
fi
cat $source | $AWK '
BEGIN   {
  print "# This file passed thru the .fvwm2rc to .fvwm/.fvwm2rc converter";
  print "# on `date`.";
  TRUE=1; FALSE=0;
  # This onlyworks with gawk
  IGNORECASE=TRUE;
}

/^[#]/ {                    # Comment, pass it thru
  print;
  next;
}

/^[ \t]*$/ {                    # Empty line, pass it thru
  print;
  next;
}

# Adds "path" to "newpath":
function add_to_path(path) {
  psize = split(path,parray,":");	# split them up
  for (i=1; i<=psize; ++i) {
    # Here there has to be logic to drop all the built in image paths.
    # The fvwm24_convert.in file has to be run thru the Makefile to insert
    # the builtin image path.
    if (parray[i] == "/u/dane/icons") { continue };  # testing
    if (parray[i] == "\\") { continue };
    # This next line should probably only skip files starting with $
    # that dont start with  $HOME.
    if (substr(parray[i],1,1) == "$") { continue };  
    if (newpath == "") {
      newpath=parray[i];
    } else {
      newpath=newpath ":" parray[i];
    }
  }
}

# Note limited attempt to match case:
/[Ii]con[Pp]ath|[Pp]ixmap[Pp]ath/ { # Fix up IconPath/PixmapPath:
  newpath="";
  add_to_path($2);
  line=$0;			# prime possible loop
  while (substr(line,length(line),1) == "\\") {
    getline line;
    add_to_path(line);    
  }
  if (newpath == "") {
    print "# To use your own icons, uncomment and change the next line";
    print "#ImagePath $HOME/icons:+";
  } else {
    print "ImagePath " newpath ":+";
  }
  next;
}

/[Hh]ilight[Cc]olor/ {
  split($2,colors,"/");
  print "Style \"*\" Hilightfore " colors[1] ", HilightBack " colors[2];
  next;
}

/[Ww]indow[Ff]ont/ {
  print "Style \"*\" Font " $2;
  next;
}

/[Cc]olor[Ll]imit/ {
  next;
}

/ModulePath/ {
  # Delete it for now.
  # Fix this so it deletes continuation lines too, although if there are
  # continuation lines, there might be some part of the path we want to
  # keep.
  next;
}

{print;}			# pass everything else thru
' > $dest
diff $source $dest
