'true' || eval 'exec perl -S $0 $argv:q';
eval '(exit $?0)' && eval 'exec perl -S $0 ${1+"$@"}'
  & eval 'exec perl -S $0 $argv:q'
  if 0;

# Convert .fvwm2rc from 2.2.x format to 2.4.x format.

# Originally written by Dan Espen <despen@telcordia.com> Sept 2000


($source,$dest) = @ARGV;
if ( $source eq "") {
  $source = "$$HOME/.fvwm2rc";
}
if ( ! -e $source ) {
  die "Can't find source file $source, giving up.\n";
}

if ($dest eq "") {
  $dest = "$$HOME/.fvwm/.fvwm2rc";
}
if ( -e $dest ) {
  die "Output file $dest already exists, exiting.\n";
}
system "cp -p $source $dest 2>/dev/null"; # try to preserve permissions

print "Input from $source, output to $dest\n";

open(IN, $source) || die "Can't open $source";
open(STDOUT, ">$dest") || die "Can't redirect stdout to $dest";


$[ = 1;				# set array base to 1
$, = ' ';			# set output field separator
$\ = "\n";			# set output record separator

print '# This file changed by the .fvwm2rc to .fvwm/.fvwm2rc converter';
# create assoc array by imagepath:
$imagepath = 'FVWM_IMAGEPATH';
$isize = (@iarray = split(/:/, $imagepath, 9999));
for ($i = 1; $i <= $isize; ++$i) {
  $iassoc{$iarray[$i]} = '1';
}

$commchar="#";			  # help un-confuse emacs.
line: while ( <IN> ) {
  chomp;			# strip record separator
  @Fld = split(' ', $_, 9999);
  if (/^[$commchar]/) {		# Comment, pass it thru
    print $_;
    next line;
  }
  
  if (/^[ \t]*$/) {		# Empty line, pass it thru
    print $_;
    next line;
  }
  
  # Adds "path" to "newpath":
  if (/^[ \t]*ICONPATH|^[ \t]*PIXMAPPATH/i) { # Fix up IconPath/PixmapPath:
    $newpath = '';
    &add_to_path($Fld[2]);
    $line = $_;
    # prime possible loop
    while (substr($line, length($line), 1) eq "\\") {
      $line = &Getline1();
      &add_to_path($line);
    }
    if ($newpath eq '') {
      print
	'# To use your own icons, uncomment and change the next line';
      print "#ImagePath \$HOME/icons:+";
    }
    else {
      print 'ImagePath ' . $newpath . ':+';
    }
    next line;
  }
  
  if (/^[ \t]*HILIGHTCOLOR/i) {
    @colors = split("/", $Fld[2], 9999);
    if ($colors[2] eq '') {
      $colors[1] = $Fld[2];
      $colors[2] = $Fld[3];
    }
    print "Style \"*\" Hilightfore " . $colors[1] . ', HilightBack ' .
      $colors[2];
    next line;
  }
  
  if (/^[ \t]*WINDOWFONT/i) {
    print "Style \"*\" Font " . $Fld[2];
    next line;
  }
  
  if (/^[ \t]*COLORLIMIT/i) {
    print '# Removed by fvwm24_convert: ' . $_;
    next line;
  }
  
  if (/^[ \t]*MODULEPATH/i) {
    # Deletes continuation lines too, although if there are
    # continuation lines, there might be some part of the path we want to
    # Delete them anyway.
    print '# Removed by fvwm24_convert: ' . $_;
    while (substr($_, length($_), 1) eq "\\") {
      $_ = &Getline1();
      print '# Removed by fvwm24_convert: ' . $_;
    }
    next line;
  }
  if (/^[ \t]*READ/i) {
    print STDERR "Read command found, check file for conversion issues:";
    print STDERR "  $_";
  }
  print $_;			# pass everything else thru
}
exit 0;

sub add_to_path {
  local($path) = @_;
  $psize = (@parray = split(/:/, $path, 9999));
  # split them up
  for ($i = 1; $i <= $psize; ++$i) {
    # Drop any builtin imagepath:
    if ($iassoc{$parray[$i]} eq '1') {
      next;
    }
    if ($parray[$i] eq "\\") {
      next;
    }
    
    $skip . $any . $end . $of . $line . $backslash;
    # This next line should probably only skip files starting with $
    # that dont start with  $HOME.
    if (substr($parray[$i], 1, 1) eq "\$") {
      next;
    }
    
    if ($newpath eq '') {
      $newpath = $parray[$i];
    }
    else {
      $newpath = $newpath . ':' . $parray[$i];
    }
  }
}

sub Getline1 {
  local($_);
  if ($getline_ok = (($_ = <IN>) ne '')) {
    chomp;			# strip record separator
  }
  $_;
}
