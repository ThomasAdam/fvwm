# -*-perl-*-
'true' || eval 'exec perl -S $0 $argv:q';
eval '(exit $?0)' && eval 'exec perl -S $0 ${1+"$@"}'
  & eval 'exec perl -S $0 $argv:q'
  if 0;

# Convert .fvwm2rc from 2.2.x format to 2.4.x format.

# Originally written by Dan Espen <despen@telcordia.com> Sept 2000


($source,$dest) = @ARGV;
if ( $source eq "") {
  $source = "$$HOME/.fvwm2rc";
}
if ( ! -e $source ) {
  die "Can't find source file $source, giving up.\n";
}

if ($dest eq "") {
  $dest = "$$HOME/.fvwm/.fvwm2rc";
}
if ( -e $dest ) {
  die "Output file $dest already exists, exiting.\n";
}
system "cp -p $source $dest 2>/dev/null"; # try to preserve permissions

print "Input from $source, output to $dest\n";

open(IN, $source) || die "Can't open $source";
open(STDOUT, ">$dest") || die "Can't redirect stdout to $dest";


$[ = 1;				# set array base to 1
$, = ' ';			# set output field separator
$\ = "\n";			# set output record separator

# GlobalOpts that became Styles:
%OPTS = ('SMARTPLACEMENTISREALLYSMART','MinOverlapPlacement',
	 'SMARTPLACEMENTISNORMAL','TileCascadePlacement',
	 'ACTIVEPLACEMENTHONORSSTARTSONPAGE',
	   'ManualPlacementHonorsStartsOnPage',
	 'ACTIVEPLACEMENTIGNORESSTARTSONPAGE',
	   'ManualPlacementIgnoresStartsOnPage',
	 'CLICKTOFOCUSDOESNTPASSCLICK', 'ClickToFocusPassesClickOff',
	 'CLICKTOFOCUSDOESNTRAISE', 'ClickToFocusRaisesOff',
	 'MOUSEFOCUSCLICKDOESNTRAISE', 'MouseFocusClickRaisesOff',
	 'NOSTIPLEDTITLES', 'StippledTitleOff',
	 'STIPLEDTITLES', 'StippledTitle');

# GlobalOpts that became BugOpts:
%BUGOPTS= ('RAISEOVERNATIVEWINDOWS','RaiseOverNativeWindows on',
	   'IGNORENATIVEWINDOWS','RaiseOverNativeWindows off');

print '# This file changed by the .fvwm2rc to .fvwm/.fvwm2rc converter';
# create assoc array by imagepath:
$imagepath = 'FVWM_IMAGEPATH';
$isize = (@iarray = split(/:/, $imagepath, 9999));
for ($i = 1; $i <= $isize; ++$i) {
  $iassoc{$iarray[$i]} = '1';
}

$commchar="#";			# help un-confuse emacs.
line: while ( <IN> ) {
  chomp;			# strip record separator
  @Fld = split(' ', $_, 9999);
  if (/^\s*[$commchar]/) {	# Comment, pass it thru
    print $_;
    $line = $_;
    while (substr($line, length($line), 1) eq "\\") { # backslashed lines
      $line = &Getline1();
      print $line;
    }
    next line;
  }

  if (/^\s*$/) {		# Empty line, pass it thru
    print $_;
    next line;
  }

  # Adds "path" to "newpath":
  if (/^\s*ICONPATH|^\s*PIXMAPPATH/i) { # Fix up IconPath/PixmapPath:
    $newpath = '';
    &add_to_path($Fld[2]);
    $line = $_;
    # prime possible loop
    while (substr($line, length($line), 1) eq "\\") {
      $line = &Getline1();
      &add_to_path($line);
    }
    if ($newpath eq '') {
      print
	'# To use your own icons, uncomment and change the next line';
      print "#ImagePath \$HOME/icons:+";
    }
    else {
      print 'ImagePath ' . $newpath . ':+';
    }
    next line;
  }

  # Change GlobOpts to "Style * xxx, ..." commands
  if (/^\s*globalopts/i) { # Fix up GlobalOpts:
    $newopts = '';
    @rest=@Fld;			# copy the whole line
    shift @rest;		# remove first element
    &add_to_opts(join($",@rest)); # pass rest of line
    $line = $_;			# prime possible loop
    while (substr($line, length($line), 1) eq "\\") { # backslashed lines
      $line = &Getline1();
      &add_to_opts($line);	# build up newopts
    }
    if ($newopts eq '') {
      next line;		# GlobalOpts without argument, drop silently
    }
    else {
      print 'Style "*"  ' . $newopts;	# print as style command
    }
    next line;
  }

  if (/^\s*MODULEPATH/i) {
    # Deletes continuation lines too, although if there are
    # continuation lines, there might be some part of the path we want to
    # Delete them anyway.
    print '# Removed by fvwm24_convert: ' . $_;
    while (substr($_, length($_), 1) eq "\\") {
      $_ = &Getline1();
      print '# Removed by fvwm24_convert: ' . $_;
    }
    next line;
  }

  # collect continuation lines
  $line = $_;
  $single_lines = $_;
  while (substr($line, length($line), 1) eq "\\") { # backslashed lines
    $old_line = substr($line, 1, length($line) - 1);
    $new_line = &Getline1();
    $single_lines = "$single_lines\n$new_line";
    $line = "$old_line$new_line";
  }
  $_ = $line;

  if (/^\s*HILIGHTCOLOR\s/i) {
    @colors = split("/", $Fld[2], 9999);
    if ($colors[2] eq '') {
      $colors[1] = $Fld[2];
      $colors[2] = $Fld[3];
    }
    print "Style \"*\" HilightFore " . $colors[1] . ', HilightBack ' .
      $colors[2];
    next line;
  }

  if (/^\s*HILIGHTCOLORSET/i) {
    print "Style \"*\" HilightColorset " . $Fld[2];
    next line;
  }

  if (/^\s*WINDOWSHADEANIMATE/i) {
    print "Style \"*\" WindowShadeSteps " . $Fld[2];
    next line;
  }

  if (/^\s*WINDOWFONT/i) {
    print "Style \"*\" Font " . $Fld[2];
    next line;
  }

  if (/^\s*ICONFONT/i) {
    print "Style \"*\" IconFont " . $Fld[2];
    next line;
  }

  if (/^\s*COLORLIMIT/i) {
    print '# Removed by fvwm24_convert: ' . $_;
    next line;
  }

  if (/^\s*[*]\S+PANEL/i) {
    print STDERR "Possible old style FvwmButtons Panel definition found";
    print STDERR "  $_";
    print STDERR
      "  See FvwmButtons(1), \"CONVERTING OLD PANEL CONFIGURATIONS\"";
    print $_;
    next line;
  }

  if (/^\s*READ/i) {
    print STDERR "Read command found, check file for conversion issues:";
    print STDERR "  $_";
    print $_;
    next line;
  }

  if (/FvwmConfig/i) {
    print STDERR "The FvwmConfig module is no longer part of fvwm:";
    print STDERR "  $_";
    if (/^\s*[*]?\s*FvwmConfig/i) {
      print STDERR "  Line commented out.";
      print '# Removed by fvwm24_convert: ' . $_;
      next line;
    }
    else {
      print $_;
    }
    next line;
  }

  if (/FvwmPipe/i) {
    print STDERR "The FvwmPipe module is no longer part of fvwm:";
    print STDERR "  $_";
    if (/^\s*[*]?\s*FvwmPipe/i) {
      print STDERR "  Line commented out.";
      print '# Removed by fvwm24_convert: ' . $_;
    }
    else {
      print $_;
    }
    next line;
  }
  if (/RANDOMPLACEMENT|ACTIVEPLACEMENT|SMARTPLACEMENT/i ||
      /DUMBPLACEMENT|CLEVERPLACEMENT/i) {
    print STDERR "Placement style names can not be converted automatically:";
    print STDERR "  $_";
    print STDERR
      "  See fvwm2(1), \"Window manager placement\" for instructions.";
    print $_;
    next line;
  }

  print $single_lines;			# pass everything else thru
}
exit 0;

sub add_to_path {
  local($path) = @_;
  $psize = (@parray = split(/:/, $path, 9999));
  # split them up
  for ($i = 1; $i <= $psize; ++$i) {
    # Drop any builtin imagepath:
    if ($iassoc{$parray[$i]} eq '1') {
      next;
    }
    if ($parray[$i] eq "\\") {
      next;
    }

    # Maybe this next line should only skip files starting with $,
    # that dont start with  $HOME.
    if (substr($parray[$i], 1, 1) eq "\$") {
      next;
    }

    if ($newpath eq '') {
      $newpath = $parray[$i];
    }
    else {
      $newpath = $newpath . ':' . $parray[$i];
    }
  }
}

# take one GlobalOpt and convert it to a style argument -or-
# just print any bugOpts
sub add_to_opts {
  local($opts) = @_;
  $psize = (@parray = split(/[ ,\t]/, $opts, 9999));
  # split them up
  for ($i = 1; $i <= $psize; ++$i) {
    if ($parray[$i] eq "\\") {
      next;
    }
    if ($parray[$i] eq "") {
      next;
    }

    # Convert args:
    # Some args are the same in a style command
    # Some are changed a little,
    # the native window stuff becomes a BugOpt

    $work = $parray[$i];	# init w. unconverted arg
    $uwork = uc $work;		# uppercase version for lookup
    $newStyleArg = $OPTS{$uwork}; # do conversion using hash
    if ($newStyleArg ne '') {	# if arg got converted
      $work = $newStyleArg;	# save new arg
    }

    $bugArg = $BUGOPTS{$uwork};	# convert using hash
    if ($bugArg ne '') {	# if converted
      print 'BugOpts ' . $bugArg;
    } else {			# if not bugOpt, accum
      if ($newopts eq '') {	# first time, just arg
	$newopts = $work;
      } else {
	$newopts = $newopts . ', ' . $work; # add comma and arg
      }
    }				# end bugArg vs. style
  }				# end for
}

sub Getline1 {
  local($_);
  if ($getline_ok = (($_ = <IN>) ne '')) {
    chomp;			# strip record separator
  }
  $_;
}
