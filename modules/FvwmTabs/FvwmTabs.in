#!/usr/bin/perl -w

# $Id: FvwmTabs.in,v 1.4 2005/11/06 01:21:21 scott Exp $

# 	FvwmTabs
#	Copyright (C) 2002 Scott Smedley ss@aao.gov.au
#	
#	This program is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; either version 2 of the License, or
#	(at your option) any later version.
#	
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#	
#	You should have received a copy of the GNU General Public License
#	along with this program; if not, write to the Free Software
#	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


# see: http://users.tpg.com.au/users/scottie7/fvwmtabs.html
# for how to install/use this module.

use strict;
use vars qw($TOP $fvwm $xServer %tabWin);
use X11::Protocol;
use Tk;

use lib `fvwm-perllib dir`;
use FVWM::Module::Tk;

# colors - TODO: make configurable.
my $activeBG = 'MidnightBlue';
my $activeFG = 'yellow';
my $inactiveBG = 'royalblue';
my $inactiveFG = 'antiquewhite';


$TOP = new MainWindow();
$TOP->withdraw();
# Why does FVWM::Module::Tk require a widget?
$fvwm = new FVWM::Module::Tk($TOP,
							 Name => "FvwmTabs",
							 Mask => (M_ERROR | M_STRING));

$fvwm->addDefaultErrorHandler();

# TODO: read configuration settings from FVWM, etc.
# my $params = $fvwm->readConfigInfo();
# foreach (keys(%params))
# {
# 	print("$_=$params{$_}\n");
# }

sub createNewTabber ()
{
	my $tId;
	for ($tId = 0; ; $tId++)
	{
		last if (!defined($tabWin{$tId}));
	}

	my $title = "FvwmTabs [$tId]";
	my $tl = $TOP->Toplevel(Name => 'FvwmTabs',
							-class => 'FvwmTabs',
							-title => $title);
	$tl->iconname($title);
	my $topFrame = $tl->Frame();
	my $tabFrame = $topFrame->Frame();
	$tabFrame->pack(-side => 'top', -expand => 0, -fill => 'x');
	$topFrame->pack(-expand => 1, -fill => 'both', -anchor => 'nw');

	my $titleFrame = $topFrame->Label(-text => "No title");
	$titleFrame->pack(-expand => 0, -fill => 'x', -side => 'top');

	my $winFrame = $topFrame->Frame();
	$winFrame->pack(-expand => 1, -fill => 'both', -side => 'top');

	$tl->protocol('WM_DELETE_WINDOW', [\&closeTabber, $tId]);

	my $b = $tabFrame->Button(-text => "FvwmTabs", -command => [\&tabInfo, $tId]);
	$b->pack(-side => 'left', -expand => 0);

	my $menu = $tl->Menu(-tearoff => 0);

	$b->Tk::bind('<ButtonRelease-3>', sub {
		$menu->delete(0, 'end');
		$menu->add('command', -label => 'Release All', -command => [\&releaseAll, $tId, 0]);
		$menu->add('command', -label => 'Release All (Iconify)', -command => [\&releaseAll, $tId, 1]);
		$menu->add('command', -label => 'Add', -command => [\&pickAndAdd, $tId, '']);
		$menu->add('command', -label => 'Multi Add', -command => [\&pickAndAdd, $tId, 'multi']);
		$menu->add('separator');

		for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
		{
			$menu->add('command', -label => $tabWin{$tId}{tab}[$tabNo]{title},
								 -command => [\&showTab, $tId, $tabNo]);
		}
		$menu->add('separator') if ($tabWin{$tId}{nTabs} > 0);
		$menu->add('command', -label => 'Close', -command => [\&closeTabber, $tId]);
		$menu->Popup(-popanchor => 'nw', -popover => 'cursor');
	});

	$tabWin{$tId}{nTabs} = 0;
	$tabWin{$tId}{toplevel} = $tl;
	$tabWin{$tId}{tabFrame} = $tabFrame;
	$tabWin{$tId}{titleFrame} = $titleFrame;
	$tabWin{$tId}{winFrame} = $winFrame;
	$tabWin{$tId}{currentTab} = undef;
	$tabWin{$tId}{parent} = hex($winFrame->id);
	# selfId appears to be parent + 1.
	$tabWin{$tId}{selfId} = $tabWin{$tId}{parent} + 1;
	# printf("created parent 0x%x\n", $tabWin{$tId}{parent});

	$winFrame->waitVisibility();

	$xServer->ChangeWindowAttributes($tabWin{$tId}{parent},
		event_mask => $xServer->pack_event_mask('ResizeRedirect'));
}

sub destroy ($)
{
	my ($tId) = @_;

	print("destroy($tId)\n");
	$tabWin{$tId}{toplevel}->destroy();
    delete $tabWin{$tId};
}

sub closeTabber ($)
{
	my ($tId) = @_;

	print("closeTabber($tId)\n");
	&releaseAll($tId, 0);
	$tabWin{$tId}{toplevel}->withdraw();
	# we need to wait for the X server to do the reparenting before
	# we can destroy the window.
	# TODO: maybe we can just XSync or something?
	$TOP->after(500, [\&destroy, $tId]);
}


sub winIdToTId ($)
{
	my ($winId) = @_;

	foreach my $tId (keys(%tabWin))
	{
		return $tId if ($winId == $tabWin{$tId}{selfId});
	}
	print("BUGGER: no match on $winId\n");
	return -1;
}


# SendToModule commands should be arriving as M_STRING events.
$fvwm->addHandler(M_STRING, sub {
	my ($self, $event) = @_;

	foreach (sort(keys %{$event->args}))
	{
		print("\t$_ = " . $event->args->{$_} . "\n");
	}
	if ($event->args->{text} =~ /newTabber/)
	{
		&createNewTabber();
	}
	elsif ($event->args->{text} =~ /addme (w?)(\d+) (multi)?/)
	{
		my $bMulti = (defined $3);
		my $tId = ($1 eq '' ? $2 : &winIdToTId($2));
		if (!exists $tabWin{$tId})
		{
			printf("Unknown Tabber %d (0x%x)\n", $2, $2);
			return;
		}
		&addTab($tId, $event->args->{win_id});
		&pickAndAdd($tId, 'multi') if ($bMulti);
	}
	else
	{
		print(STDERR $self->name . ": Unknown command: " . $event->args->{text} . "\n");
	}
});

# ON_EXIT handler is invoked just before this module terminates.
$fvwm->addHandler(ON_EXIT, sub {
	my ($self, $event) = @_; 
	print("Got ON_EXIT event.\n");
	&cleanup();
});

# release all windows from <$tId> tabber.
sub releaseAll ($$)
{
	my ($tId, $bIconify) = @_;
	for (my $tabNo = $tabWin{$tId}{nTabs} - 1; $tabNo >= 0; $tabNo--)
	{
		&letItGo(undef, $tId, $tabNo, $bIconify);
	}
	$tabWin{$tId}{tab} = undef;
	$tabWin{$tId}{nTabs} = 0;
	$tabWin{$tId}{currentTab} = undef;
}

$SIG{PIPE} = sub {
	print("SIGPIPE!\n");
	&cleanup();
	exit;
};

sub cleanup ()
{
	foreach (keys(%tabWin))
	{
		&closeTabber($_);
	}
}

$xServer = X11::Protocol->new($TOP->screen());
# $xServer->{event_handler} = \&eventHandler;
$xServer->event_handler('queue');

sub callback
{
	# print("#");
	# $xServer->handle_input();
	# $xServer->next_event();
	# TODO: why do I have to send a req to get events.
	# Need a non-blocking way to get an event.
 	$xServer->req('ListProperties', $xServer->root());
	while (1)
	{
		my %event = $xServer->dequeue_event();
		last if (!exists($event{name}));
		&eventHandler(%event);
	}
}

# Check for registered X events every second.
$TOP->repeat(250, \&callback);

sub eventHandler
{
	my (%event) = @_;

	print("Got an X event: " . join(", ", map("$_ = $event{$_}", keys(%event))) . "\n");


	if ($event{name} eq 'ResizeRequest')
	{
		my $tId = -1;
		for (keys(%tabWin))
		{
			$tId = $_, last if ($tabWin{$_}{parent} == $event{window});
		}

		return if ($tId < 0);

		print("Got a resize event on tId $tId\n");
		# resize the $winFrame widget. Can't use $w->configure(-height ...)
		# cos we're requesting resize events on this widget.
		$xServer->ConfigureWindow($tabWin{$tId}{parent},
								  "height" => $event{height},
								  "width" => $event{width});

		# If the tabber is resized, resize the currently viewed app/tab
		# (if any) to fit into the new space.
		return if (!defined $tabWin{$tId}{currentTab});
		my $winId = $tabWin{$tId}{tab}[$tabWin{$tId}{currentTab}]{winId};
		
		$xServer->ConfigureWindow($winId,
								  "height" => $event{height},
								  "width" => $event{width});
		return;
	}

	my $tabNo = -1;
	my $tId = undef;
	for (keys(%tabWin))
	{
		$tabNo = &getTabNo($_, $event{window});
		$tId = $_, last if ($tabNo >= 0)
	}

	if ($tabNo < 0)
	{
		print(STDERR "Ignoring event for invalid/unknown window.\n");
		return;
	}

	# print("tId appears to be: $tId\n");

	if ($event{name} eq 'PropertyNotify')
	{
		my $prop = $xServer->atom_name($event{atom});
		print("$prop has changed.\n");
		return if ($prop ne 'WM_NAME' && $prop ne 'WM_ICON_NAME');
		my $val = &getProperty($event{window}, $prop);
		print("new value is: $val\n");
		if ($prop eq 'WM_NAME')
		{
			&setTabTitle($tId, $tabNo, $event{window}, $val);
		}
		elsif ($prop eq 'WM_ICON_NAME')
		{
			&setTabName($tId, $tabNo, $event{window}, $val);
		}
	}
	elsif ($event{name} eq 'DestroyNotify')
	{
		&removeTab($tId, $tabNo, 'destroyed');
	}
	else
	{
		print(STDERR "Got a strange event: $event{name}\n");
	}
}

# Don't you just *love* Prince!?
sub letItGo ($$$$)
{
	my ($button, $tId, $tabNo, $bIconify) = @_;

	print("letItGo($tId, $tabNo)\n");

	if ($tabNo >= $tabWin{$tId}{nTabs})
	{
		print(STDERR "BUG: invalid tabNo.\n");
		return;
	}

	my $winId = $tabWin{$tId}{tab}[$tabNo]{winId};
	print(sprintf("reparenting 0x%x\n", $winId));
	$xServer->ReparentWindow($winId, $xServer->root(), (0, 0));
	$xServer->MapWindow($winId);
	$fvwm->send("WindowId $winId Iconify") if ($bIconify);
	&removeTab($tId, $tabNo, 'letgo');
}

sub addTab ($$)
{
	my ($tId, $winId) = @_;

	# print("addTab($tId, $winId)\n");

	my %g = $xServer->req('GetGeometry', $winId);
	# TODO: save geometry of window for later.
	# foreach my $k (keys(%g))
	# {
	# 	print("\tgeom: $k = $g{$k}\n");
	# }
	print("geom: x=$g{x} y=$g{y} w=$g{width} h=$g{height}\n");

	# print("tId=$tId\n");
	# print("addTab parent=" . $tabWin{$tId}{parent} . "\n");
	# printf("reparenting 0x%x to 0x%x\n", $winId, $tabWin{$tId}{parent});

	if ($winId == $tabWin{$tId}{selfId})
	{
		# can't make tabber a child of itself
		print("Can't add self to tabber!\n");
		$fvwm->send("Beep");
		return;
	}

	$xServer->ReparentWindow($winId, $tabWin{$tId}{parent}, (0, 0));
	my $tabNo = $tabWin{$tId}{nTabs}++;
	# print("tabNo=$tabNo\n");
	$tabWin{$tId}{tab}[$tabNo]{winId} = $winId;
	my $txt = &getProperty($winId, "WM_ICON_NAME");
	$tabWin{$tId}{tab}[$tabNo]{button} =
		$tabWin{$tId}{tabFrame}->Button(-text => $txt,
										-command => [\&showTab, $tId, $tabNo]);
	my $pButton = $tabWin{$tId}{tab}[$tabNo]{button};

	# Raise the FvwmTabs window whenever a tab is selected.
	$pButton->Tk::bind('<ButtonPress-1>', sub { $fvwm->send("Current Raise"); });
	$pButton->pack(-side => 'left', -expand => 1, -fill => 'both');
	$pButton->Tk::bind('<ButtonRelease-2>', [\&letItGo, $tId, $tabNo, 0]);
	$tabWin{$tId}{tab}[$tabNo]{title} = &getProperty($winId, "WM_NAME");
	# Ensure we are notified of any attribute changes in the new window.
	# PropertyChange will tell us when WM_NAME or WM_ICON_NAME changes.
	# StructureNotify will tell us when a program running in a tab
	# terminates/is-destroyed.
	$xServer->ChangeWindowAttributes($winId,
			  event_mask => $xServer->pack_event_mask('PropertyChange',
			  										  'StructureNotify'));
	&showTab($tId, $tabNo);
}

sub pickAndAdd ($$)
{
	my ($tId, $arg) = @_;
	$fvwm->send("Pick SendToModule *" . $fvwm->name() . " addme $tId $arg");
}

sub tabInfo ($)
{
	my ($tId) = @_;

	print("\nnTabs=$tabWin{$tId}{nTabs}\n");
	printf("parent=0x%x\n", $tabWin{$tId}{parent});
	printf("self=0x%x\n", $tabWin{$tId}{selfId});
	for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
	{
		printf("Tab #$tabNo winId = 0x%x (%d)\n",
			   $tabWin{$tId}{tab}[$tabNo]{winId},
			   $tabWin{$tId}{tab}[$tabNo]{winId});
	}
}

sub getProperty ($$)
{
	my ($winId, $property) = @_;

	my $atom = $xServer->atom($property);
	my @s = $xServer->req('GetProperty', $winId, $atom, "AnyPropertyType", 0, 200, 0);
	return $s[0];
}

# return the tabNo for the specified window ID or -1 if the window is
# not part of the fvwm.
sub getTabNo ($$)
{
	my ($tId, $winId) = @_;
	for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
	{
		return $tabNo if ($tabWin{$tId}{tab}[$tabNo]{winId} == $winId);
	}
	return -1;
}

# the window for <$tabNo> has been destroyed/letgo - cleanup appropriately.
sub removeTab ($$$)
{
	my ($tId, $tabNo, $state) = @_;

	print("removeTab($tId, $tabNo, $state)\n");

	if ($state eq 'letgo')
	{
		# We are no longer interested in events for this window.
		$xServer->ChangeWindowAttributes($tabWin{$tId}{tab}[$tabNo]{winId},
			  event_mask => $xServer->pack_event_mask());
	}

	$tabWin{$tId}{tab}[$tabNo]{button}->packForget();
	$tabWin{$tId}{tab}[$tabNo] = undef;

	for (my $t = $tabNo; $t < $tabWin{$tId}{nTabs} - 1; $t++)
	{
		$tabWin{$tId}{tab}[$t] = $tabWin{$tId}{tab}[$t + 1];
		printf("new tab #$t = 0x%x\n", $tabWin{$tId}{tab}[$t]{winId});
		$tabWin{$tId}{tab}[$t]{button}->configure(-command => [\&showTab, $tId, $t]);
		$tabWin{$tId}{tab}[$t]{button}->Tk::bind('<ButtonRelease-2>', [\&letItGo, $tId, $t, 0]);
	}
	$tabWin{$tId}{nTabs}--;
	$tabWin{$tId}{tab}[$tabWin{$tId}{nTabs}] = undef;

	if ($tabWin{$tId}{currentTab} == $tabNo)
	{
		$tabWin{$tId}{currentTab} = undef;
		if ($tabWin{$tId}{nTabs} > 0)
		{
			&showTab($tId, ($tabNo < $tabWin{$tId}{nTabs} ? $tabNo : $tabNo - 1))
		}
		else
		{
			$tabWin{$tId}{titleFrame}->configure(-text => 'No title');
			# TODO: proper resize.
			$tabWin{$tId}{winFrame}->configure(-height => 10, -width => 0);
		}
	}
	elsif ($tabWin{$tId}{currentTab} > $tabNo)
	{
		$tabWin{$tId}{currentTab}--;
	}
}

sub showTab ($$)
{
	my ($tId, $tabNo) = @_;

	# print("showTab($tId, $tabNo)\n");

	if ($tabNo >= $tabWin{$tId}{nTabs})
	{
		print(STDERR "BUG: invalid tabNo ($tabNo) in call to showTab().\n");
		return
	}

	# Unmap the current tab.
	if (defined($tabWin{$tId}{currentTab}))
	{
		my $currentTab = $tabWin{$tId}{currentTab};
		print("showTab: currentTab=$currentTab\n");
		return if ($tabNo == $currentTab);
		my $winId = $tabWin{$tId}{tab}[$currentTab]{winId};
		$xServer->UnmapWindow($winId);
		$tabWin{$tId}{tab}[$currentTab]{button}->configure(-bg => $inactiveBG,
													  -activebackground => $inactiveBG,
													  -fg => $inactiveFG,
													  -activeforeground => $inactiveFG,
													  -relief => 'raised');
	}
	# Map the new tab.
	my $winId = $tabWin{$tId}{tab}[$tabNo]{winId};
	$xServer->MapWindow($winId);
	$tabWin{$tId}{currentTab} = $tabNo;
	# TODO: option sunken or flat.
	$tabWin{$tId}{tab}[$tabNo]{button}->configure(-bg => $activeBG,
												  -activebackground => $activeBG,
												  -fg => $activeFG,
												  -activeforeground => $activeFG,
												  -relief => 'sunken');
	$tabWin{$tId}{titleFrame}->configure(-text => $tabWin{$tId}{tab}[$tabNo]{title});

	my %g = $xServer->req('GetGeometry', $winId);
	$tabWin{$tId}{winFrame}->configure(-height => $g{height}, -width => $g{width});
	# print("showTab h=$g{height} w=$g{width}\n");
	$tabWin{$tId}{toplevel}->geometry("");
}

sub setTabTitle($$$$)
{
	my ($tId, $tabNo, $winId, $titleStr) = @_;

	$tabWin{$tId}{tab}[$tabNo]{title} = $titleStr;
	if ($tabNo == $tabWin{$tId}{currentTab})
	{
		$tabWin{$tId}{titleFrame}->configure(-text => $titleStr);
	}
}

sub setTabName($$$$)
{
	my ($tId, $tabNo, $winId, $name) = @_;

	$tabWin{$tId}{tab}[$tabNo]{button}->configure(-text => $name);
}

$fvwm->eventLoop();


# TODO
#
# - GetGeometry doesn't appear to return x/y only w/h.
#   (use to put windows back where they came from when released.)
# - when user resizes window, dynamic-resizes no longer work.
# - fix focusing?
# - configuration options: bg/fg colors/fonts/sizes, titles, etc.
# - key bindings:
#   * release current tab.
#	* release all tabs.
#	* add new window.
#	* display next tab.
#	* display previous tab.
#	* close tabber.
#	* create new tabber.
# - consider removing the 'FVWM-Tabs' button & using the menu popup over
#   the title frame.
# - associate a mini icon with each tab-button.
# - Preserve state b/w FVWM Restarts.
# - specify patterns for windows to be auto-"swallowed".
# - tons of stuff!
