#!/usr/bin/perl -w

# $Id: FvwmTabs.in,v 2.3 2005/11/06 01:31:44 scott Exp $

# 	FvwmTabs
#	Copyright (C) 2002, 2003 Scott Smedley ss@aao.gov.au
#	
#	This program is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; either version 2 of the License, or
#	(at your option) any later version.
#	
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#	
#	You should have received a copy of the GNU General Public License
#	along with this program; if not, write to the Free Software
#	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


# see: http://users.tpg.com.au/users/scottie7/fvwmtabs.html
# for how to install/use this module.

use strict;
use lib `fvwm-perllib dir`;
use FVWM::Module::Tk;
use FVWM::Module::Toolkit qw(Tk FileHandle X11::Protocol Tk::Balloon Tk::DragDrop Tk::DropSite);

use IO::Select;

use vars qw($TOP $fvwm $xServer %tabWin @autoSwallow $repeatId $balloon);

$TOP = new MainWindow();
$TOP->withdraw();
# Why does FVWM::Module::Tk require a widget?
$fvwm = new FVWM::Module::Tk($TOP,
							 Name => "FvwmTabs",
							 Mask => (M_ERROR | M_STRING | M_ADD_WINDOW),
							 Debug => 0);

$fvwm->debug("Debug level is: " . $fvwm->{debug});
$fvwm->addDefaultErrorHandler();

my $configTracker = $fvwm->track('ModuleConfig',
		 DefaultConfig => {activeBG => 'MidnightBlue',
						   activeFG => 'yellow',
						   inactiveBG => 'royalblue',
						   inactiveFG => 'antiquewhite',
						   titleFG => 'black',
						   titleBG => 'antiquewhite',
						   activeRelief => 'sunken',
						   pollRate => 250,	# in milliseconds.
						   autoSwallowClass => '',
						   autoSwallowResource => '',
						   autoSwallowName => '',
						   fontSelector => 'gfontsel --print -f "%f"',
						   buttonFont => 'Helvetica -12 bold',
						   titleFont => 'Helvetica -12 bold',
						   menuFont => 'Helvetica -12',
						   balloonFont => 'Helvetica -12',
						   balloonWait => 350, # in milliseconds
						   balloonBG => '#C0C080',
						   balloonMsg => 'Tab %tabNo:\n%iconText\n%title',
						   autoResize => 'false',
						   stateFile => '/tmp/.fvwmtabs.state',
						   fixedSizeTabs => 'false',
						   showTitlebar => 'true',
						   useTMTitlebar => 'true'});

my $pConfig = $configTracker->data;
$configTracker->observe("config line added", sub {
	# 1st arg is FVWM::Module::Tk hash
	# 2nd arg is FVWM::Tracker::ModuleConfig hash
	# 3rd arg is hash of config values
	# 4th arg is name of config value that has changed.
	my ($self, $h, $v, $p) = @_;
	$self->debug("Module Config event - \"$p\" changed, new val: \"$v->{$p}\"");

	foreach my $tId (keys(%tabWin))
	{
		if ($p =~ /^active(FG|BG|Relief)$/)
		{
			if (defined $tabWin{$tId}{currentTab})
			{
				$tabWin{$tId}{tab}[$tabWin{$tId}{currentTab}]{button}->configure(-lc($1) => $pConfig->{$p});
				if ($1 ne 'Relief')
				{
					my $active = 'active' . ($1 eq 'BG' ? 'back' : 'fore') . 'ground';
					$tabWin{$tId}{tab}[$tabWin{$tId}{currentTab}]{button}->configure(-$active => $pConfig->{$p});
				}
			}
		}
		elsif ($p =~ /^inactive(FG|BG)$/)
		{
			# currentTab is always defined if $nTabs > 0
			if (defined $tabWin{$tId}{currentTab})
            {
				my $active = 'active' . ($1 eq 'BG' ? 'back' : 'fore') . 'ground';
				for (my $i = 0; $i < $tabWin{$tId}{nTabs}; $i++)
				{
					next if ($i == $tabWin{$tId}{currentTab});
					$tabWin{$tId}{tab}[$i]{button}->configure(-lc($1) => $pConfig->{$p}, -$active => $pConfig->{$p});
				}
			}
		}
		elsif ($p =~ /^title(FG|BG)$/)
		{
			$tabWin{$tId}{titleFrame}->configure(-lc($1) => $pConfig->{$p});
		}
		elsif ($p eq 'pollRate')
		{
			$TOP->afterCancel($repeatId);
			$repeatId = $TOP->repeat($pConfig->{pollRate}, \&callback);
			return;	# not a per-tabber option.
		}
		elsif ($p =~ /^(button|title|menu)Font$/)
		{
			setFont($tId, $1, $pConfig->{$p});
		}
		elsif ($p =~ /^autoSwallow(Class|Resource|Name)$/)
		{
			parseAutoSwallow($1);
			return;	# not a per-tabber option.
		}
		elsif ($p =~ /^(fontSelector|autoResize|fixedSizeTabs|balloonMsg)$/)
		{
			# handled implicitly.
			return;
		}
		elsif ($p eq 'showTitlebar')
		{
			$tabWin{$tId}{showTitlebar} = ($pConfig->{showTitlebar} =~ /true/i ? 1 : 0);
			showTitlebar($tId);
		}
		elsif ($p eq 'useTMTitlebar')
		{
			if ($pConfig->{useTMTitlebar} !~ /true/i)
			{
				my $t = $fvwm->name() . " [$tId]";
				$tabWin{$tId}{toplevel}->configure(-title => $t);
			}
		}
		else
		{
			$self->showError("Unknown option: $p");
			return;
		}
	}
});

sub autoSwallow (%)
{
	my (%args) = @_;

	$fvwm->debug("AutoSwallow: " . join(", ", map("$_=" . $args{$_},
												  sort(keys(%args)))));
	push(@autoSwallow, \%args);
}

sub parseAutoSwallow ($)
{
	my ($type) = @_;
	foreach (split(/,/, $pConfig->{'autoSwallow' . $type}))
	{
		if (!/^\s*(.+?)(\s+(\d+|any))?\s*$/i)
		{
			print($fvwm->name() . ": unparseable autoSwallow$type.\n");
			next;
		}
		autoSwallow(lc($type) => $1, type => (!defined $3 ? 'any' : $3));
	}
}

foreach ('Class', 'Resource', 'Name')
{
	parseAutoSwallow($_);
}

# ======= ======= =======
# TODO: colorsets
# my $csTracker = $fvwm->track("Colorsets");
# my $csHash = $csTracker->data;
# my $cs1_fg = $csHash->{1}->{fg} || 'unknown';
# my $cs1_bg = $csHash->{1}->{bg} || 'unknown';
# my $cs5_bg = $csTracker->data(6)->{bg} || 'unknown';
# print("cs1_fg=$cs1_fg cs1_bg=$cs1_bg\n");

# $csTracker->observe("colorset changed", sub {
# 	print("Colorset observation.\n");
# 	    foreach (@_)
#     {
#         print("\targ=$_\n");
#     }
# });

# ======= ======= =======


$xServer = X11::Protocol->new($TOP->screen());
$xServer->event_handler('queue');
# $xServer->event_handler(\&eventHandler);

$xServer->error_handler(\&errorHandler);
sub errorHandler ($$)
{
	my($self, $data) = @_;
	print($fvwm->name() . ': ' . $self->make_error_msg($data));
}

# Check for registered X events every $pollRate milliseconds.
$repeatId = $TOP->repeat($pConfig->{pollRate}, \&callback);

$balloon = $TOP->Balloon(-bg => $pConfig->{balloonBG},
						 -font => $pConfig->{balloonFont},
						 -initwait => $pConfig->{balloonWait});

sub createNewTabber ()
{
	my $tId;
	for ($tId = 0; ; $tId++)
	{
		last if (!defined($tabWin{$tId}));
	}

	my $title = $fvwm->name() . " [$tId]";
	my $tl = $TOP->Toplevel(Name => $fvwm->name(),
							-class => $fvwm->name(),
							-title => $title);
	$tl->iconname($title);
	$tl->focusmodel("active");
	my $topFrame = $tl->Frame();
	my $tabFrame = $topFrame->Frame();
	$tabFrame->pack(-side => 'top', -expand => 0, -fill => 'x');
	$topFrame->pack(-expand => 1, -fill => 'both', -anchor => 'nw');

	# titlebar
	my $wrapFrame = $topFrame->Frame();
	$wrapFrame->pack(-expand => 1, -fill => 'x');
	my $titleFrame = $wrapFrame->Label(-text => "No title",
									  -font => $pConfig->{titleFont},
									  -bg => $pConfig->{titleBG},
									  -fg => $pConfig->{titleFG});
	$tabWin{$tId}{showTitlebar} = ($pConfig->{showTitlebar} =~ /true/i ? 1 : 0);
	$tabWin{$tId}{titleFrame} = $titleFrame;
	$tabWin{$tId}{wrapFrame} = $wrapFrame;
	showTitlebar($tId);

	my $winFrame = $topFrame->Frame();
	$winFrame->pack(-expand => 1, -fill => 'both', -side => 'top');

	$tl->protocol('WM_DELETE_WINDOW', [\&closeTabber, $tId]);
	$tl->protocol('WM_TAKE_FOCUS', [\&takeFocus, $tId]);

	my $b = $tabFrame->Button(-text => $fvwm->name(),
							  -font => $pConfig->{buttonFont},
							  -padx => 3,
							  -command => [\&tabInfo, $tId]);
	$b->pack(-side => 'left', -expand => 0);

	$tabFrame->configure(-width => $b->reqwidth(), -height => $b->reqheight());
	$tabFrame->packPropagate(0);

	my $menu = $tl->Menu(-tearoff => 0, -font => $pConfig->{menuFont});

	$b->Tk::bind('<ButtonRelease-3>', sub {
		$menu->delete(0, 'end');
		$menu->add('command',
				   -label => 'Release All',
				   -command => [\&releaseAll, $tId, 0]);
		$menu->add('command',
				   -label => 'Release All (Iconify)',
				   -command => [\&releaseAll, $tId, 1]);
		$menu->add('command',
				   -label => 'Add',
				   -command => [\&pickAndAdd, $tId, '']);
		$menu->add('command',
				   -label => 'Multi Add',
				   -command => [\&pickAndAdd, $tId, 'multi']);
		if ($pConfig->{fontSelector} ne 'none')
		{
			my $fontMenu = $menu->Menu(-tearoff => 0, -font => $pConfig->{menuFont});
			$fontMenu->add('command',
						   -label => 'Button Font',
						   -command => [\&selectFont, $tId, 'button']);
			$fontMenu->add('command',
						   -label => 'Title Font',
						   -command => [\&selectFont, $tId, 'title']);
			$fontMenu->add('command',
						   -label => 'Menu Font',
						   -command => [\&selectFont, $tId, 'menu']);

			$menu->add('cascade', -label => 'Font', -menu => $fontMenu);
		}
		$menu->add('checkbutton',
                   -label => 'Show Titlebar',
				   -variable => \$tabWin{$tId}{showTitlebar},
                   -command => [\&showTitlebar, $tId]);
		$menu->add('separator');

		for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
		{
			$menu->add('command', -label => $tabWin{$tId}{tab}[$tabNo]{title},
								 -command => [\&showTab, $tId, $tabNo]);
		}
		$menu->add('separator') if ($tabWin{$tId}{nTabs} > 0);
		$menu->add('command', -label => 'About', -command => [\&about, $tId]);
		$menu->add('command', -label => 'Close', -command => [\&closeTabber, $tId]);
		$menu->Popup(-popanchor => 'nw', -popover => 'cursor');
	});

	$tabWin{$tId}{nTabs} = 0;
	$tabWin{$tId}{toplevel} = $tl;
	$tabWin{$tId}{toplevelId} = hex($tabWin{$tId}{toplevel}->id());
	$tabWin{$tId}{tabFrame} = $tabFrame;
	$tabWin{$tId}{winFrame} = $winFrame;
	$tabWin{$tId}{currentTab} = undef;
	$tabWin{$tId}{lastId} = undef;
	$tabWin{$tId}{parent} = hex($winFrame->id);
	$tabWin{$tId}{menuButton} = $b;
	$tabWin{$tId}{menu} = $menu;
	# $tl->wrapper() doesn't work ...
	# selfId appears to be parent + 1 anyway.
	$tabWin{$tId}{selfId} = $tabWin{$tId}{parent} + 1;
	$tabWin{$tId}{balloonMsg} = '?';
	$winFrame->waitVisibility();

	$xServer->ChangeWindowAttributes($tabWin{$tId}{parent},
		event_mask => $xServer->pack_event_mask('ResizeRedirect'));

	wrapperWinId($tId);
}

sub wrapperWinId ($)
{
	my ($tId) = @_;

	if (exists $tabWin{$tId}{wrapperWinId})
	{
		$xServer->ChangeWindowAttributes($tabWin{$tId}{wrapperWinId},
			event_mask => $xServer->pack_event_mask());
	}

	$tabWin{$tId}{wrapperWinId} = hex($tabWin{$tId}{toplevel}->frame());
	$xServer->ChangeWindowAttributes($tabWin{$tId}{wrapperWinId},
		event_mask => $xServer->pack_event_mask('EnterWindow'));
	$tabWin{$tId}{focusTimestamp} = 'CurrentTime';
}

sub takeFocus ($)
{
	my ($tId) = @_;

	# $fvwm->debug("takeFocus($tId) state=" . $tabWin{$tId}{toplevel}->state());
	my $winId;
	if ($tabWin{$tId}{toplevel}->state() eq 'iconic')
	{
		# TODO: who do we give the focus to?
		$winId = $tabWin{$tId}{toplevelId};
	}
	elsif (!defined $tabWin{$tId}{currentTab})
	{
		$winId = $tabWin{$tId}{toplevelId};
	}
	else
	{
		$winId = $tabWin{$tId}{tab}[$tabWin{$tId}{currentTab}]{winId};
	}
	# "revert-to" (2nd) arg can be 'Parent', 'PointerRoot' or 'None'.
	$xServer->SetInputFocus($winId, 'Parent', $tabWin{$tId}{focusTimestamp});
	# $fvwm->debug("takeFocus(end) winId=$winId");
}

# Don't you just *love* Prince!?
sub letItGo ($$$$)
{
	my ($button, $tId, $tabNo, $bIconify) = @_;

	if ($fvwm->{debug} && $tabNo >= $tabWin{$tId}{nTabs})
	{
		$fvwm->debug("BUG: invalid tabNo.");
		return;
	}

	my $winId = $tabWin{$tId}{tab}[$tabNo]{winId};
	$xServer->ReparentWindow($winId, $xServer->root(), (0, 0));
	# position the window at the location we found it. (ie. before the
	# window was added to this tabber.)
	$xServer->ConfigureWindow($winId,
							  x => $tabWin{$tId}{tab}[$tabNo]{initialXPos},
							  y => $tabWin{$tId}{tab}[$tabNo]{initialYPos});
	$xServer->MapWindow($winId);
	XSync();

	# if the window we're releasing is a tabber, we need to recompute
	# the wrapper window id as it can change dynamically.
	my $otherTId = winIdToTId($winId);
	wrapperWinId($otherTId) if ($otherTId >= 0);

	$fvwm->send("Iconify", $winId) if ($bIconify);
	removeTab($tId, $tabNo, 'letgo');
}

sub letItGoClick ($$$$)
{
    my ($button, $tId, $winId, $bIconify) = @_;
	letItGo($button, $tId, getTabNo($tId, $winId), $bIconify);
}

# release all windows from <$tId> tabber.
sub releaseAll ($$)
{
	my ($tId, $bIconify) = @_;
	for (my $tabNo = $tabWin{$tId}{nTabs} - 1; $tabNo >= 0; $tabNo--)
	{
		letItGo(undef, $tId, $tabNo, $bIconify);
	}
	$tabWin{$tId}{tab} = undef;
	$tabWin{$tId}{nTabs} = 0;
	$tabWin{$tId}{currentTab} = undef;
}

sub XSync ()
{
	# There doesn't appear to be an XSync function so we'll just make
	# do with atom() & ignore the return value.
	# Actually, atom() is cached by X11::Protocol so we need to issue
	# the actual X request.
	# $xServer->atom("WM_NAME");
	$xServer->req('InternAtom', "WM_NAME", 0);
}

sub closeTabber ($)
{
	my ($tId) = @_;

	$fvwm->debug("closeTabber($tId)");

	$xServer->ChangeWindowAttributes($tabWin{$tId}{parent},
		event_mask => $xServer->pack_event_mask());

	releaseAll($tId, 0);
	$tabWin{$tId}{toplevel}->withdraw();
	# We need to wait for the X server to do the reparenting before
	# we can destroy the window.
	XSync();

	# If we destroy the toplevel we find that subsequent tabbers have
	# strange window ids. That is, X/FVWM identify the tabber differently
	# than the tabber identifies itself ($tabWin{$tId}{parent}).
	# Hence, we don't destroy the toplevel. This causes a memory leak of
	# ~40kb for every tabber.
	# $tabWin{$tId}{toplevel}->destroy();
	delete $tabWin{$tId};
}

sub winIdToTId ($)
{
	my ($winId) = @_;

	foreach my $tId (keys(%tabWin))
	{
		return $tId if ($winId == $tabWin{$tId}{selfId});
	}
	# print("BUGGER: no match on $winId\n");
	return -1;
}

# SendToModule commands arrive as M_STRING events.
$fvwm->addHandler(M_STRING, sub {
	my ($self, $event) = @_;

	$fvwm->debug("M_STRING: " . join(", ", map("$_ = " . $event->args->{$_}, keys(%{$event->args}))));

	if ($event->args->{text} =~ /newTabber/)
	{
		createNewTabber();
	}
	elsif ($event->args->{text} =~ /addme (w?)(\d+)(.*)?/)
	{
		my $bMulti = ($3 eq ' multi');
		my $tId = ($1 eq '' ? $2 : &winIdToTId($2));
		if (!exists $tabWin{$tId})
		{
			printf("Unknown Tabber %d (0x%x)\n", $2, $2);
			return;
		}
		addTab($tId, $event->args->{win_id});
		pickAndAdd($tId, 'multi') if ($bMulti);
	}
	# Older versions of Perl don't support 'xdigit'.
	# elsif ($event->args->{text} =~ /fn (\S+) (0x[[:xdigit:]]+)\s*(.*)/)
	elsif ($event->args->{text} =~ /fn (\S+) (0x[0-9a-fA-F]+)\s*(.*)/)
	{
		# fn <fnName> <winId> <optArgs>
		my $tId = winIdToTId(hex($2));
		print("focus not in tabber.\n"), return if ($tId < 0);
		no strict;
		&$1($tId, split(/\s+/, $3));
	}
	elsif ($event->args->{text} =~ /saveState/)
	{
		saveState();
	}
	else
	{
		print(STDERR $self->name() . ": Unknown command: " . $event->args->{text} . "\n");
	}
});

# showNext() - invoked from key binding.
sub showNext ($$)
{
	my ($tId, $inc) = @_;

	return if ($tabWin{$tId}{nTabs} <= 0);
	my $nextTabNo = ($tabWin{$tId}{currentTab} + $inc) % $tabWin{$tId}{nTabs};
	showTab($tId, $nextTabNo) if ($nextTabNo != $tabWin{$tId}{currentTab});
}

sub showLast ($)
{
	my ($tId) = @_;

	return if ($tabWin{$tId}{nTabs} <= 0 || !defined $tabWin{$tId}{lastId});
	my $tabNo = getTabNo($tId, $tabWin{$tId}{lastId});
	return if ($tabNo < 0);
	showTab($tId, $tabNo);
}

# releaseTab() - invoked from key binding.
sub releaseTab ($$$)
{
	my ($tId, $tabNo, $bIconify) = @_;
	$tabNo = $tabWin{$tId}{currentTab} if ($tabNo eq 'current');
	letItGo(undef, $tId, $tabNo, $bIconify);
}

$fvwm->addHandler(M_ADD_WINDOW, sub {
	my ($self, $event) = @_;

	$fvwm->debug("Add Window: " . join(", ", map("$_ = " . $event->args->{$_}, keys(%{$event->args}))));
	my $winId = $event->args->{win_id};

	my $s = chr(0);
	my ($resource, $class) = split(/$s/, getProperty($winId, 'WM_CLASS'));
	my $name = getProperty($winId, 'WM_NAME');
	$fvwm->debug("newWindow - resource=$resource class=$class name=$name");

	foreach (@autoSwallow)
	{
		if ((exists $_->{resource} && $_->{resource} eq $resource) ||
			(exists $_->{class} && $_->{class} eq $class) ||
			(exists $_->{name} && $_->{name} eq $name))
		{
			my $tId = $_->{type};
			if ($tId eq 'any')
			{
				my @tIds = keys(%tabWin);
				return if ($#tIds < 0);	# no tabbers running.
				# choose the emptiest tabber.
				my $n = 99;
				foreach (@tIds)
				{
					if ($tabWin{$_}{nTabs} < $n)
					{
						$tId = $_;
						$n = $tabWin{$_}{nTabs};
					}
				}
			}
			addTab($tId, $winId) if (exists $tabWin{$tId})
		}
	}
});

# ON_EXIT handler is invoked just before this module terminates.
$fvwm->addHandler(ON_EXIT, sub {
	my ($self, $event) = @_; 
	print($fvwm->name() . ": Got ON_EXIT event.\n");
	cleanup();
});

$SIG{PIPE} = sub {
	print($fvwm->name() . ": SIGPIPE!\n");
	cleanup();
	exit;
};

sub cleanup ()
{
	foreach (keys(%tabWin))
	{
		closeTabber($_);
	}
}

my $fds = IO::Select->new($xServer->connection->fh);

sub callback
{
	# Damn! This is the most annoying bug in X. I don't think it's
	# possible to tell the X server to flush its buffer without sending
	# an actual X command. FvwmTabs *almost* works without this XSync() call.
	# It would eradicate a significant amount of X traffic if we could
	# remove it.
	XSync();
	
	$xServer->flush();
 	# print("!\n"), $xServer->handle_input() if ($fds->can_read(0));
 	$xServer->handle_input() if ($fds->can_read(0));

	while (my %e = $xServer->dequeue_event())
	{
		eventHandler(%e)
	}
}

sub eventHandler
{
	my (%event) = @_;

	$fvwm->debug("Got a $event{name} event: " . join(", ", map("$_ = $event{$_}", keys(%event))));


	if ($event{name} eq 'ResizeRequest')
	{
		my $tId = -1;
		for (keys(%tabWin))
		{
			$tId = $_, last if ($tabWin{$_}{parent} == $event{window});
		}

		return if ($tId < 0);

		my $h = $tabWin{$tId}{winFrame}->height();
		# resize the $winFrame widget. Can't use $w->configure(-height ...)
		# cos we're requesting resize events on this widget.
		$xServer->ConfigureWindow($tabWin{$tId}{parent},
								  "height" => $h, #$event{height},
								  "width" => $event{width});

		if ($pConfig->{autoResize} =~ /true/i)
		{
			for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
			{
				$xServer->ConfigureWindow($tabWin{$tId}{tab}[$tabNo]{winId},
										  "height" => $h, # $event{height},
										  "width" => $event{width});
			}
		}
		else
		{
			# If the tabber is resized, resize the currently viewed app/tab
			# (if any) to fit into the new space.
			return if (!defined $tabWin{$tId}{currentTab});
			my $winId = $tabWin{$tId}{tab}[$tabWin{$tId}{currentTab}]{winId};
			
			$xServer->ConfigureWindow($winId,
									  "height" => $h, # $event{height},
									  "width" => $event{width});
		}
		return;
	}
	elsif ($event{name} eq 'EnterNotify')
	{
		my $tId = -1;
		for (keys(%tabWin))
		{
			$tId = $_, last if ($tabWin{$_}{wrapperWinId} == $event{event});
		}

		print "BUG: EnterNotify\n", return if ($tId < 0);
		$tabWin{$tId}{focusTimestamp} = $event{time};
		$fvwm->debug("focusTimestamp set to $tabWin{$tId}{focusTimestamp}");
		takeFocus($tId);
		return;
	}

	my $tabNo = -1;
	my $tId = undef;
	for (keys(%tabWin))
	{
		$tabNo = getTabNo($_, $event{window});
		$tId = $_, last if ($tabNo >= 0)
	}

	if ($tabNo < 0)
	{
		$fvwm->debug("Ignoring event for invalid/unknown window.");
		return;
	}

	if ($event{name} eq 'PropertyNotify')
	{
		my $prop = $xServer->atom_name($event{atom});
		return if ($prop ne 'WM_NAME' && $prop ne 'WM_ICON_NAME');
		my $val = getProperty($event{window}, $prop);
		return if (!defined $val);	# window no longer exists!
		if ($prop eq 'WM_NAME')
		{
			setTabTitle($tId, $tabNo, $val);
		}
		elsif ($prop eq 'WM_ICON_NAME')
		{
			setTabName($tId, $tabNo, $val);
		}
	}
	elsif ($event{name} eq 'DestroyNotify')
	{
		removeTab($tId, $tabNo, 'destroyed');
	}
	elsif ($event{name} eq 'MapNotify')
	{
		$xServer->SetInputFocus($event{window}, 'Parent', 'CurrentTime');
	}
	else
	{
		$fvwm->debug("Got a strange event: $event{name}");
	}
}

sub getXYPos ($)
{
	my ($winId) = @_;

	my ($na1, $na2, $x, $y) = $xServer->TranslateCoordinates($winId,
                                                             $xServer->root(),
                                                             0,
                                                             0);
	return ($x, $y);
}

sub addTab ($$)
{
	my ($tId, $winId) = @_;

	if ($winId == $tabWin{$tId}{selfId})
	{
		# can't make tabber a child of itself
		$fvwm->send("Beep");
		$fvwm->showError("Can't add self to tabber!");
		return;
	}

	# check if the window actually exists before we try to swallow it.
	if (!defined getProperty($winId, 'WM_NAME'))
	{
		print($fvwm->name() . ": Window doesn't exist.\n");
		return;
	}

	my $tabNo = $tabWin{$tId}{nTabs}++;
	$tabWin{$tId}{tab}[$tabNo]{winId} = $winId;

	# save position of window for later.
	($tabWin{$tId}{tab}[$tabNo]{initialXPos}, $tabWin{$tId}{tab}[$tabNo]{initialYPos}) = getXYPos($winId);

	# if the auto-resize option is specified & the new window to add is
	# smaller than the tabber, then we need to enlarge the new window. If
	# the new window is larger than the tabber, then the tabber will
	# expand appropriately (with all existing windows in the tabber) on
	# the resize event.
	if ($pConfig->{autoResize} =~ /true/i)
	{
		my %g = $xServer->GetGeometry($winId);
		my $h = $tabWin{$tId}{winFrame}->height();
		my $w = $tabWin{$tId}{winFrame}->width();
		if ($g{height} < $h || $g{width} < $w)
		{
			$xServer->ConfigureWindow($winId, "height" => $h, "width" => $w);
		}
	}

	$xServer->ReparentWindow($winId, $tabWin{$tId}{parent}, (0, 0));
	my $txt = getProperty($winId, "WM_ICON_NAME");
	$tabWin{$tId}{tab}[$tabNo]{button} =
		$tabWin{$tId}{tabFrame}->Button(-text => $txt,
										-padx => 2,
										-width => 1,
										-anchor => 'w',
										-command => [\&showTabClick, $tId, $winId],
										-font => $pConfig->{buttonFont});
	my $pButton = $tabWin{$tId}{tab}[$tabNo]{button};

	# Raise the FvwmTabs window whenever a tab is selected.
	$pButton->Tk::bind('<ButtonPress-1>', sub { $fvwm->send("Current Raise"); });
	$pButton->pack(-side => 'left', -expand => 1, -fill => 'x');
	$pButton->Tk::bind('<ButtonRelease-2>', [\&letItGoClick, $tId, $winId, 0]);
	$pButton->Tk::bind('<ButtonRelease-3>', [\&letItGoClick, $tId, $winId, 1]);

	# drag-&-drop to reorder tabs.
	$pButton->DragDrop(-event => '<Control-B2-Motion>',
					   -sitetypes => [qw(Local)],
					   -selection => $winId,
					   -cursor => 'sb_h_double_arrow',
					   -text => '*',
					   -handlers => []);
	$pButton->DropSite(-droptypes => [qw(Local)],
					   -dropcommand => [\&moveTabClick, [$tId, $winId]]);

	$tabWin{$tId}{tab}[$tabNo]{title} = getProperty($winId, "WM_NAME");

	$balloon->attach($pButton,
					 -balloonmsg => \$tabWin{$tId}{balloonMsg},
					 -postcommand => [\&setBalloonMsg, $tId, $winId]);

	# Ensure we are notified of any attribute changes in the new window.
	# PropertyChange will tell us when WM_NAME or WM_ICON_NAME changes.
	# StructureNotify will tell us when a program running in a tab
	# terminates/is-destroyed.
	$xServer->ChangeWindowAttributes($winId,
			  event_mask => $xServer->pack_event_mask('PropertyChange',
			  										  'StructureNotify'));
	showTab($tId, $tabNo);
}

sub pickAndAdd ($$)
{
	my ($tId, $arg) = @_;
	$fvwm->send("Pick SendToModule *" . $fvwm->name() . " addme $tId $arg");
}

sub tabInfo ($)
{
	my ($tId) = @_;

	print("\nnTabs=$tabWin{$tId}{nTabs}\n");
	printf("parent=0x%x (%d)\n", $tabWin{$tId}{parent}, $tabWin{$tId}{parent});
	printf("self=0x%x (%d)\n", $tabWin{$tId}{selfId}, $tabWin{$tId}{selfId});
	for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
	{
		printf("Tab #$tabNo winId = 0x%x (%d)\n",
			   $tabWin{$tId}{tab}[$tabNo]{winId},
			   $tabWin{$tId}{tab}[$tabNo]{winId});
	}
	print("AutoSwallow:\n");
	foreach my $a (@autoSwallow)
	{
		print("\t" . join(", ", map("$_=" . $a->{$_}, sort(keys(%{$a})))) . "\n");
	}
	print("toplevel->id()=" . $tabWin{$tId}{toplevel}->id() . "\n");
	print("toplevel->wrapper()=" . $tabWin{$tId}{toplevel}->wrapper() . "\n");
	print("toplevel->frame()=" . $tabWin{$tId}{toplevel}->frame() . "\n");
	print("wrapperWinId=" . $tabWin{$tId}{wrapperWinId} . "\n");
	print("autoResize is " . $pConfig->{autoResize} . "\n");
	print("fixedSizeTabs is " . $pConfig->{fixedSizeTabs} . "\n");
	XSync();
}

sub getProperty ($$)
{
	my ($winId, $property) = @_;

	my $atom = $xServer->atom($property);
	my @s = $xServer->GetProperty($winId, $atom, "AnyPropertyType", 0, 200, 0);
	return $s[0];
}

# return the tabNo for the specified window ID or -1 if the window is
# not part of the tabber.
# TODO: rename this function to "winIdToTabNo"?
sub getTabNo ($$)
{
	my ($tId, $winId) = @_;
	for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
	{
		return $tabNo if ($tabWin{$tId}{tab}[$tabNo]{winId} == $winId);
	}
	return -1;
}

# the window for <$tabNo> has been destroyed/letgo - cleanup appropriately.
sub removeTab ($$$)
{
	my ($tId, $tabNo, $state) = @_;

	$fvwm->debug("removeTab($tId, $tabNo, $state)");

	if ($state eq 'letgo')
	{
		# We are no longer interested in events for this window.
		$xServer->ChangeWindowAttributes($tabWin{$tId}{tab}[$tabNo]{winId},
			  event_mask => $xServer->pack_event_mask());
	}

	$balloon->detach($tabWin{$tId}{tab}[$tabNo]{button});
	$tabWin{$tId}{tab}[$tabNo]{button}->packForget();
	$tabWin{$tId}{tab}[$tabNo] = undef;

	for (my $t = $tabNo; $t < $tabWin{$tId}{nTabs} - 1; $t++)
	{
		$tabWin{$tId}{tab}[$t] = $tabWin{$tId}{tab}[$t + 1];
	}
	$tabWin{$tId}{nTabs}--;
	$tabWin{$tId}{tab}[$tabWin{$tId}{nTabs}] = undef;

	if ($tabWin{$tId}{currentTab} == $tabNo)
	{
		$tabWin{$tId}{currentTab} = undef;
		if ($tabWin{$tId}{nTabs} > 0)
		{
			showTab($tId, ($tabNo < $tabWin{$tId}{nTabs} ? $tabNo : $tabNo - 1))
		}
		else
		{
			$tabWin{$tId}{titleFrame}->configure(-text => 'No title');
			$tabWin{$tId}{winFrame}->configure(-height => 1, -width => 0);
		}
	}
	else
	{
		$tabWin{$tId}{currentTab}-- if ($tabWin{$tId}{currentTab} > $tabNo);
		if ($tabWin{$tId}{nTabs} == 1)
		{
			# allow the selected tab button to expand as much as possible.
			$tabWin{$tId}{tab}[$tabWin{$tId}{currentTab}]{button}->pack(-expand => 1);
		}
	}
}

sub showTab ($$)
{
	my ($tId, $tabNo) = @_;

	$fvwm->send("Beep"), return if ($tabNo >= $tabWin{$tId}{nTabs});

	# Unmap the current tab.
	if (defined($tabWin{$tId}{currentTab}))
	{
		my $currentTab = $tabWin{$tId}{currentTab};
		return if ($tabNo == $currentTab);
		my $winId = $tabWin{$tId}{tab}[$currentTab]{winId};
		$xServer->UnmapWindow($winId);
		$tabWin{$tId}{tab}[$currentTab]{button}->configure(
					-bg => $pConfig->{inactiveBG},
					-activebackground => $pConfig->{inactiveBG},
					-fg => $pConfig->{inactiveFG},
					-activeforeground => $pConfig->{inactiveFG},
					-width => 1,
					-relief => 'raised');
		$tabWin{$tId}{tab}[$currentTab]{button}->pack(-expand => 1);
		$tabWin{$tId}{lastId} = $winId;
	}
	# Map the new tab.
	my $winId = $tabWin{$tId}{tab}[$tabNo]{winId};
	$xServer->MapWindow($winId);
	$tabWin{$tId}{currentTab} = $tabNo;
	my $bEq = ($pConfig->{fixedSizeTabs} =~ /true/i ? 1 : 0);
	$tabWin{$tId}{tab}[$tabNo]{button}->configure(
					-bg => $pConfig->{activeBG},
					-activebackground => $pConfig->{activeBG},
					-fg => $pConfig->{activeFG},
					-activeforeground => $pConfig->{activeFG},
					-width => $bEq,
					-relief => $pConfig->{activeRelief});
	my $bExpand = ($bEq || ($tabWin{$tId}{nTabs} == 1));
	$tabWin{$tId}{tab}[$tabNo]{button}->pack(-expand => $bExpand);

	my %g = $xServer->GetGeometry($winId);
	$tabWin{$tId}{winFrame}->configure(-height => $g{height}, -width => $g{width});
	$tabWin{$tId}{toplevel}->geometry("");
	showTitle($tId, $tabNo, $g{width});
	# If we're changing the active tab really quickly we have to handle/flush
	# all the X events in the queue - this prevents us from getting a
	# 'Protocol Error'.
	callback();
}

sub showTabClick ($$)
{
	my ($tId, $winId) = @_;
	showTab($tId, getTabNo($tId, $winId));
}

sub showTitle ($$$)
{
	my ($tId, $tabNo, $w) = @_;

	$fvwm->debug("BUG: showTitle()") if ($tabNo != $tabWin{$tId}{currentTab});
	# This is a nice feature - Wrap the title text across multiple lines.
	# The following command in an xterm window illustrates the usefulness:
	# echo "abc\ndef\nghi\njkl" && sleep 3

	$w -= 30;

	my $titleStr = $tabWin{$tId}{tab}[$tabNo]{title};
	# make sure the title text does not exceed this length.
	$tabWin{$tId}{titleFrame}->configure(-text => $titleStr,
										 -wraplength => "${w}p");

	if ($pConfig->{useTMTitlebar} =~ /true/i)
	{
		my $title = $fvwm->name() . " [$tId] : " . $titleStr;
		$tabWin{$tId}{toplevel}->configure(-title => $title);
	}
}

sub setTabTitle($$$)
{
	my ($tId, $tabNo, $titleStr) = @_;

	$titleStr =~ s/\n//g;
	$tabWin{$tId}{tab}[$tabNo]{title} = $titleStr;
	if ($tabNo == $tabWin{$tId}{currentTab})
	{
		# get the width of the title label in pixels.
		my $w = $tabWin{$tId}{titleFrame}->width();
		showTitle($tId, $tabNo, $w);
	}
}

sub showTitlebar ($)
{
	my ($tId) = @_;

	if ($tabWin{$tId}{showTitlebar})
	{
		$tabWin{$tId}{titleFrame}->pack(-expand => 0, -fill => 'x', -side => 'top');
	}
	else
	{
		$tabWin{$tId}{titleFrame}->pack('forget');
		$tabWin{$tId}{wrapFrame}->configure(-width => 0, -height => 1);
	}
}

sub setTabName ($$$)
{
	my ($tId, $tabNo, $name) = @_;

	$tabWin{$tId}{tab}[$tabNo]{button}->configure(-text => $name);
}

sub selectFont ($$)
{
	my ($tId, $type) = @_;
	my $cmd = $pConfig->{fontSelector};
	my $currentFont = $pConfig->{$type . 'Font'};
	$cmd =~ s/%f/$currentFont/g;
	$SIG{CHLD}= sub { wait; };
	my $pipe = new FileHandle();
	if (!$pipe->open("$cmd|"))
	{
		$fvwm->showError("Select font: command $cmd failed.");
		return
	}

	sub fontCallback ($$$)
	{
		my ($pipe, $tId, $type) = @_;
		my $line = $pipe->getline();
		setFont($tId, $type, $line) if (defined($line));
		$pipe->close() if ($pipe->eof());
	}

	$TOP->fileevent($pipe, "readable" => [\&fontCallback, $pipe, $tId, $type]);
}

sub setFont ($$$)
{
	my ($tId, $type, $font) = @_;
	$fvwm->debug("new $type font is: $font");
	$pConfig->{$type . 'Font'} = $font;
	if ($type eq 'button')
	{
		for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
		{
			$tabWin{$tId}{tab}[$tabNo]{button}->configure(-font => $font);
		}	
		$tabWin{$tId}{menuButton}->configure(-font => $font);
		$tabWin{$tId}{tabFrame}->configure(-height => $tabWin{$tId}{menuButton}->reqheight());
	}
	elsif ($type eq 'title')
	{
		$tabWin{$tId}{titleFrame}->configure(-font => $font);
	}
	elsif ($type eq 'menu')
	{
		$tabWin{$tId}{menu}->configure(-font => $font);
	}
}

sub about ($)
{
	my ($tId) = @_;

	my $rcsId = '$Id: FvwmTabs.in,v 2.3 2005/11/06 01:31:44 scott Exp $';
	$rcsId =~ /,v (.*) (\d+\/\d+\/\d+) \d+:\d+:\d+/;
	my $version = $fvwm->name() . " v$1   ($2)\n\nby Scott Smedley\nscottie7\@tpg.com.au"; # \n\nhttp://users.tpg.com.au/users/scottie7/fvwmtabs.html";
	# TODO: Tk::Dialog has a hardcoded width of 3 inches, how annoying!
	# $tabWin{$tId}{toplevel}->Dialog(-text => $version,
	# 								-bitmap => 'info',
	# 								-title => 'About ' . $fvwm->name(),
	# 								-buttons => ['Ok'])->Show();
	$fvwm->showMessage($version, "About " . $fvwm->name());
}

sub setBalloonMsg ($$)
{
	my ($tId, $winId) = @_;

	my $tabNo = getTabNo($tId, $winId);

	my $msg = $pConfig->{balloonMsg};
	$msg =~ s/\\n/\n/g;
	$msg =~ s/%tabNo/$tabNo/gi;
	my $iconText = $tabWin{$tId}{tab}[$tabNo]{button}->cget(-text);
	$msg =~ s/%iconText/$iconText/gi;
	$msg =~ s/%title/$tabWin{$tId}{tab}[$tabNo]{title}/gi;
	$tabWin{$tId}{balloonMsg} = $msg;
}

sub moveTab ($$$)
{
	my ($tId, $insertionPoint, $tabNo) = @_;
	print(STDERR "move tabNo $tabNo before tabNo $insertionPoint (tId=$tId)\n");

	return if ($insertionPoint == $tabNo);

	# TODO
}

sub moveTabClick ($$$)
{
	my ($pa, $winId, $notUsed) = @_;

	my ($tId, $insertionPoint) = @$pa;
	moveTab($tId, getTabNo($tId, $insertionPoint), getTabNo($tId, $winId));
}

sub saveState ()
{
	my $file = $pConfig->{stateFile};
	if (!open(OUT, ">$file"))
	{
		print(STDERR $fvwm->name() . ": Couldn't save state to $file.\n");
		return;
	}
	print(STDERR $fvwm->name() . ": Saving state to $file\n");
	foreach my $tId (keys(%tabWin))
	{
		print(OUT "createNewTabber();\n");
		my ($x, $y) = getXYPos($tabWin{$tId}{wrapperWinId});
		print(OUT "\$fvwm->send(\"Move ${x}p ${y}p\", \$tabWin{$tId}{selfId});\n");
		for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
		{
			print(OUT "addTab($tId, $tabWin{$tId}{tab}[$tabNo]{winId});\n");
		}
		print(OUT "showTab($tId, $tabWin{$tId}{currentTab});\n");
	}
	close(OUT);
}

sub loadState ()
{
	my $file = $pConfig->{stateFile};
	if (-r $file)
	{
		print(STDERR $fvwm->name() . ": Reading state from $file\n");
		eval `cat $file`;
		unlink($file);
	}
}

loadState();

print("Module " . $fvwm->name() . " started with X11::Protocol version " .  $X11::Protocol::VERSION . ".\n");
$fvwm->eventLoop();
