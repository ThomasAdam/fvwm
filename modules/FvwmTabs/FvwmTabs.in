#!/usr/bin/perl -w

# $Id: FvwmTabs.in,v 2.9 2005/11/06 01:35:24 scott Exp $

# 	FvwmTabs
#	Copyright (C) 2002, 2003 Scott Smedley ss@aao.gov.au
#	
#	This program is free software; you can redistribute it and/or modify
#	it under the terms of the GNU General Public License as published by
#	the Free Software Foundation; either version 2 of the License, or
#	(at your option) any later version.
#	
#	This program is distributed in the hope that it will be useful,
#	but WITHOUT ANY WARRANTY; without even the implied warranty of
#	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#	GNU General Public License for more details.
#	
#	You should have received a copy of the GNU General Public License
#	along with this program; if not, write to the Free Software
#	Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA


# see: http://users.tpg.com.au/users/scottie7/fvwmtabs.html
# for how to install/use this module.

use strict;
use lib `fvwm-perllib dir`;
use FVWM::Module::Tk;
use FVWM::Module::Toolkit qw(FileHandle IO::Select X11::Protocol>=0.52 Tk Tk::Balloon Tk::DragDrop Tk::DropSite Tk::LabFrame Tk::BrowseEntry);

use vars qw($TOP $fvwm $xServer %tabWin @autoSwallow $repeatId $balloon %global);

# My Perl/Tk patch to fix dynamically-sized drop sites was merged into 
# Tk-804.025-beta6.
$global{buggyTkDND} = ($Tk::VERSION < 804.025);
print("This version of Tk has buggy drag-&-drop - workaround enabled.\n") if ($global{buggyTkDND});


$TOP = new MainWindow();
$TOP->withdraw();
$fvwm = new FVWM::Module::Tk($TOP,
							 Name => "FvwmTabs",
							 Mask => (M_ERROR | M_STRING | M_ADD_WINDOW),
							 Debug => 2);

$fvwm->debug("Debug level is: " . $fvwm->{debug});
$fvwm->addDefaultErrorHandler();

my $configTracker = $fvwm->track('ModuleConfig',
	 DefaultConfig => {activeBG => 'MidnightBlue',
					   activeFG => 'yellow',
					   inactiveBG => 'royalblue',
					   inactiveFG => 'antiquewhite',
					   titleFG => 'black',
					   titleBG => 'antiquewhite',
					   activeRelief => 'sunken',
					   pollRate => 250,	# in milliseconds.
					   autoSwallowClass => '',
					   autoSwallowResource => '',
					   autoSwallowName => '',
					   fontSelector => 'gfontsel --print -f "%f"',
					   buttonFont => 'Helvetica -12 bold',
					   titleFont => 'Helvetica -12 bold',
					   menuFont => 'Helvetica -12',
					   balloonFont => 'Helvetica -12',
					   balloonWait => 350, # in milliseconds
					   balloonBG => '#C0C080',
					   balloonMsg => 'Tab %tabNo:\n%iconText\n%title',
					   autoResize => 'false',
					   stateFile => $ENV{FVWM_USERDIR} . '/.fvwmtabs.state',
					   fixedSizeTabs => 'false',
					   showTitlebar => 'true',
					   useTMTitlebar => 'true',
					   dragDropIcon => 'happyMini.xpm'});

my $pConfig = $configTracker->data;
$configTracker->observe("config line added", sub {
	# 1st arg is FVWM::Module::Tk hash
	# 2nd arg is FVWM::Tracker::ModuleConfig hash
	# 3rd arg is hash of config values
	# 4th arg is name of config value that has changed.
	my ($self, $h, $v, $p) = @_;
	$self->debug("Module Config event - \"$p\" changed, new val: \"$v->{$p}\"");

	foreach my $tId (keys(%tabWin))
	{
		if ($p =~ /^active(FG|BG|Relief)$/)
		{
			if (defined $tabWin{$tId}{currentTab})
			{
				$tabWin{$tId}{tab}[$tabWin{$tId}{currentTab}]{button}->configure(-lc($1) => $pConfig->{$p});
				if ($1 ne 'Relief')
				{
					my $active = 'active' . ($1 eq 'BG' ? 'back' : 'fore') . 'ground';
					$tabWin{$tId}{tab}[$tabWin{$tId}{currentTab}]{button}->configure(-$active => $pConfig->{$p});
				}
			}
		}
		elsif ($p =~ /^inactive(FG|BG)$/)
		{
			# currentTab is always defined if $nTabs > 0
			if (defined $tabWin{$tId}{currentTab})
            {
				my $active = 'active' . ($1 eq 'BG' ? 'back' : 'fore') . 'ground';
				for (my $i = 0; $i < $tabWin{$tId}{nTabs}; $i++)
				{
					next if ($i == $tabWin{$tId}{currentTab});
					$tabWin{$tId}{tab}[$i]{button}->configure(-lc($1) => $pConfig->{$p}, -$active => $pConfig->{$p});
				}
			}
		}
		elsif ($p =~ /^title(FG|BG)$/)
		{
			$tabWin{$tId}{titleFrame}->configure(-lc($1) => $pConfig->{$p});
		}
		elsif ($p eq 'pollRate')
		{
			$TOP->afterCancel($repeatId);
			$repeatId = $TOP->repeat($pConfig->{pollRate}, \&callback);
			return;	# not a per-tabber option.
		}
		elsif ($p =~ /^(button|title|menu)Font$/)
		{
			setFont($tId, $1, $pConfig->{$p});
		}
		elsif ($p =~ /^autoSwallow(Class|Resource|Name)$/)
		{
			parseAutoSwallow($1);
			return;	# not a per-tabber option.
		}
		elsif ($p eq 'showTitlebar')
		{
			$tabWin{$tId}{showTitlebar} = ($pConfig->{showTitlebar} =~ /true/i ? 1 : 0);
			showTitlebar($tId);
		}
		elsif ($p eq 'useTMTitlebar')
		{
			if ($pConfig->{useTMTitlebar} !~ /true/i)
			{
				my $t = $fvwm->name() . " [$tId]";
				$tabWin{$tId}{toplevel}->configure(-title => $t);
			}
		}
		elsif ($p =~ /^(fontSelector|autoResize|fixedSizeTabs|balloonMsg|stateFile)$/)
		{
			# handled implicitly.
			return;
		}
		elsif ($p =~ /^(balloon(Font|Wait|BG)|dragDropIcon)$/)
		{
			print(STDERR $fvwm->name() . ": \"$p\" option will not take effect until FvwmTabs restarts.\n");
		}
		else
		{
			$self->showError("Unknown option: $p");
			return;
		}
	}
});


$pConfig->{global} = $fvwm->track("GlobalConfig")->data;

sub autoSwallow (%)
{
	my (%args) = @_;

	$fvwm->debug("AutoSwallow: " . join(", ", map("$_=" . $args{$_},
												  sort(keys(%args)))));
	push(@autoSwallow, \%args);
}

sub parseAutoSwallow ($)
{
	my ($type) = @_;
	foreach (split(/,/, $pConfig->{'autoSwallow' . $type}))
	{
		if (!/^\s*(.+?)(\s+(\d+|any|lastFocus))?\s*$/i)
		{
			print(STDERR $fvwm->name() . ": unparseable autoSwallow$type.\n");
			next;
		}
		autoSwallow(lc($type) => $1, type => (!defined $3 ? 'any' : $3));
	}
}

foreach ('Class', 'Resource', 'Name')
{
	parseAutoSwallow($_);
}

$xServer = X11::Protocol->new($TOP->screen());
$xServer->event_handler('queue');

$xServer->error_handler(\&errorHandler);
sub errorHandler ($$)
{
	my($self, $data) = @_;
	print(STDERR $fvwm->name() . ': ' . $self->format_error_msg($data));
}

# Check for registered X events every $pollRate milliseconds.
$repeatId = $TOP->repeat($pConfig->{pollRate}, \&callback);

$balloon = $TOP->Balloon(-bg => $pConfig->{balloonBG},
						 -font => $pConfig->{balloonFont},
						 -initwait => $pConfig->{balloonWait});

sub createNewTabber ()
{
	my $tId;
	for ($tId = 0; ; $tId++)
	{
		last if (!defined($tabWin{$tId}));
	}

	my $title = $fvwm->name() . " [$tId]";
	my $tl = $TOP->Toplevel(Name => $fvwm->name(),
							-class => $fvwm->name(),
							-title => $title);
	$tl->iconname($title);
	$tl->focusmodel("active");
	my $topFrame = $tl->Frame();
	my $tabFrame = $topFrame->Frame();
	$tabFrame->pack(-side => 'top', -expand => 0, -fill => 'x');
	$topFrame->pack(-expand => 1, -fill => 'both', -anchor => 'nw');

	# titlebar
	my $wrapFrame = $topFrame->Frame();
	$wrapFrame->pack(-expand => 0, -fill => 'x');
	my $titleFrame = $wrapFrame->Label(-text => "No title",
									  -font => $pConfig->{titleFont},
									  -bg => $pConfig->{titleBG},
									  -fg => $pConfig->{titleFG});
	$tabWin{$tId}{showTitlebar} = ($pConfig->{showTitlebar} =~ /true/i ? 1 : 0);
	$tabWin{$tId}{titleFrame} = $titleFrame;
	$tabWin{$tId}{wrapFrame} = $wrapFrame;
	showTitlebar($tId);

	my $winFrame = $topFrame->Frame();
	$winFrame->pack(-expand => 1, -fill => 'both', -side => 'top');

	$tl->protocol('WM_DELETE_WINDOW', [\&closeTabber, $tId]);
	$tl->protocol('WM_TAKE_FOCUS', [\&takeFocus, $tId]);

	my $b = $tabFrame->Button(-text => $fvwm->name(),
							  -font => $pConfig->{buttonFont},
							  -padx => 3,
							  -command => [\&tabInfo, $tId]);
	$b->pack(-side => 'left', -expand => 0);

	$tabFrame->configure(-width => $b->reqwidth(), -height => $b->reqheight());
	$tabFrame->packPropagate(0);

	my $menu = $tl->Menu(-tearoff => 0, -font => $pConfig->{menuFont});

	$b->Tk::bind('<ButtonRelease-3>', sub {
		$menu->delete(0, 'end');
		$menu->add('command',
				   -label => 'Release All',
				   -command => [\&releaseAll, $tId, 0]);
		$menu->add('command',
				   -label => 'Release All (Iconify)',
				   -command => [\&releaseAll, $tId, 1]);
		$menu->add('command',
				   -label => 'Add',
				   -command => [\&pickAndAdd, $tId, '']);
		$menu->add('command',
				   -label => 'Multi Add',
				   -command => [\&pickAndAdd, $tId, 'multi']);
		if ($pConfig->{fontSelector} ne 'none')
		{
			my $fontMenu = $menu->Menu(-tearoff => 0, -font => $pConfig->{menuFont});
			$fontMenu->add('command',
						   -label => 'Button Font',
						   -command => [\&selectFont, $tId, 'button']);
			$fontMenu->add('command',
						   -label => 'Title Font',
						   -command => [\&selectFont, $tId, 'title']);
			$fontMenu->add('command',
						   -label => 'Menu Font',
						   -command => [\&selectFont, $tId, 'menu']);

			$menu->add('cascade', -label => 'Font', -menu => $fontMenu);
		}
		$menu->add('checkbutton',
                   -label => 'Show Titlebar',
				   -variable => \$tabWin{$tId}{showTitlebar},
                   -command => [\&showTitlebar, $tId]);
		$menu->add('command',
				   -label => 'Window Tabizer Dialog',
				   -command => [\&tabizeWindows, $tId]);
		$menu->add('separator');

		for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
		{
			$menu->add('command', -label => $tabWin{$tId}{tab}[$tabNo]{title},
								 -command => [\&showTab, $tId, $tabNo]);
		}
		$menu->add('separator') if ($tabWin{$tId}{nTabs} > 0);
		$menu->add('command', -label => 'About', -command => [\&about, $tId]);
		$menu->add('command', -label => 'Close', -command => [\&closeTabber, $tId]);
		$menu->Popup(-popanchor => 'nw', -popover => 'cursor');
	});

	$tabWin{$tId}{nTabs} = 0;
	$tabWin{$tId}{toplevel} = $tl;
	$tabWin{$tId}{toplevelId} = hex($tabWin{$tId}{toplevel}->id());
	$tabWin{$tId}{tabFrame} = $tabFrame;
	$tabWin{$tId}{winFrame} = $winFrame;
	$tabWin{$tId}{currentTab} = undef;
	$tabWin{$tId}{lastId} = undef;
	$tabWin{$tId}{parent} = hex($winFrame->id);
	$tabWin{$tId}{menuButton} = $b;
	$tabWin{$tId}{menu} = $menu;
	$winFrame->waitVisibility();
	my ($root, $parent, @kids) = $xServer->QueryTree($tabWin{$tId}{toplevelId});
	$tabWin{$tId}{selfId} = $parent;
	$tabWin{$tId}{balloonMsg} = '?';

	$xServer->ChangeWindowAttributes($tabWin{$tId}{parent},
		event_mask => $xServer->pack_event_mask('ResizeRedirect'));

	buggyFocusWorkaround($tId);
}

sub getWrapperWinId ($)
{
	my ($tId) = @_;
	return hex($tabWin{$tId}{toplevel}->frame());
}

sub buggyFocusWorkaround ($)
{
	my ($tId) = @_;

	if (exists $tabWin{$tId}{_wrapperWinId})
	{
		# don't want events on old window id anymore.
		$xServer->ChangeWindowAttributes($tabWin{$tId}{_wrapperWinId},
			event_mask => $xServer->pack_event_mask());
	}

	$tabWin{$tId}{_wrapperWinId} = getWrapperWinId($tId);
	# request events on new window id.
	$xServer->ChangeWindowAttributes($tabWin{$tId}{_wrapperWinId},
		event_mask => $xServer->pack_event_mask('EnterWindow'));
	$tabWin{$tId}{focusTimestamp} = 'CurrentTime';
}

sub takeFocus ($)
{
	my ($tId) = @_;

	$global{lastFocus} = $tId;
	my $winId;
	if ($tabWin{$tId}{toplevel}->state() eq 'iconic')
	{
		# TODO: who do we give the focus to?
		$winId = $tabWin{$tId}{toplevelId};
		return;
	}
	elsif (!defined $tabWin{$tId}{currentTab})
	{
		$winId = $tabWin{$tId}{toplevelId};
	}
	else
	{
		$winId = $tabWin{$tId}{tab}[$tabWin{$tId}{currentTab}]{winId};
	}
	# "revert-to" (2nd) arg can be 'Parent', 'PointerRoot' or 'None'.
	$xServer->SetInputFocus($winId, 'Parent', $tabWin{$tId}{focusTimestamp});
}

# Don't you just *love* Prince!?
sub letItGo ($$$$)
{
	my ($button, $tId, $tabNo, $bIconify) = @_;

	if ($fvwm->{debug} && $tabNo >= $tabWin{$tId}{nTabs})
	{
		$fvwm->debug("BUG: invalid tabNo.");
		return;
	}

	my $winId = $tabWin{$tId}{tab}[$tabNo]{winId};
	$xServer->ReparentWindow($winId, $xServer->root(), (0, 0));
	# position the window at the location we found it. (ie. before the
	# window was added to this tabber.)
	$xServer->ConfigureWindow($winId,
							  x => $tabWin{$tId}{tab}[$tabNo]{initialXPos},
							  y => $tabWin{$tId}{tab}[$tabNo]{initialYPos});
	$xServer->MapWindow($winId);
	XSync(); # wait for window to popup.

	# if the window we're releasing is a tabber, we need to recompute
	# the wrapper window id as it can change dynamically.
	my $otherTId = winIdToTId($winId);
	buggyFocusWorkaround($otherTId) if ($otherTId >= 0);

	$fvwm->send("Iconify", $winId) if ($bIconify);
	removeTab($tId, $tabNo, 'letgo');
}

sub letItGoClick ($$$$)
{
    my ($button, $tId, $winId, $bIconify) = @_;
	letItGo($button, $tId, getTabNo($tId, $winId), $bIconify);
}

# release all windows from <$tId> tabber.
sub releaseAll ($$)
{
	my ($tId, $bIconify) = @_;
	for (my $tabNo = $tabWin{$tId}{nTabs} - 1; $tabNo >= 0; $tabNo--)
	{
		letItGo(undef, $tId, $tabNo, $bIconify);
	}
	$tabWin{$tId}{tab} = undef;
	$tabWin{$tId}{nTabs} = 0;
	$tabWin{$tId}{currentTab} = undef;
}

sub XSync ()
{
	# atom() is cached by X11::Protocol so we need to issue
	# the actual X request.
	# $xServer->atom("WM_NAME");
	$xServer->req('InternAtom', "WM_NAME", 0);
}

sub closeTabber ($)
{
	my ($tId) = @_;

	$fvwm->debug("closeTabber($tId)");

	$xServer->ChangeWindowAttributes($tabWin{$tId}{parent},
		event_mask => $xServer->pack_event_mask());

	releaseAll($tId, 0);
	$tabWin{$tId}{toplevel}->withdraw();
	# We need to wait for the X server to do the reparenting before
	# we can destroy the window.
	XSync();

	# TODO: destroy() call intermittently causes problems.
	# $tabWin{$tId}{toplevel}->destroy();
	delete $tabWin{$tId};
}

sub winIdToTId ($)
{
	my ($winId) = @_;

	foreach my $tId (keys(%tabWin))
	{
		return $tId if ($winId == $tabWin{$tId}{selfId});
	}
	return -1;
}

# SendToModule commands arrive as M_STRING events.
$fvwm->addHandler(M_STRING, sub {
	my ($self, $event) = @_;

	$fvwm->debug("M_STRING: " . join(", ", map("$_ = " . $event->args->{$_}, keys(%{$event->args}))));

	if ($event->args->{text} =~ /newTabber/)
	{
		createNewTabber();
	}
	elsif ($event->args->{text} =~ /addme (w?)(\d+)(.*)?/)
	{
		my $bMulti = ($3 eq ' multi');
		my $tId = ($1 eq '' ? $2 : &winIdToTId($2));
		if (!exists $tabWin{$tId})
		{
			printf("Unknown Tabber %d (0x%x)\n", $2, $2);
			return;
		}
		addTab($tId, $event->args->{win_id});
		pickAndAdd($tId, 'multi') if ($bMulti);
	}
	# Older versions of Perl don't support 'xdigit'.
	# elsif ($event->args->{text} =~ /fn (\S+) (0x[[:xdigit:]]+)\s*(.*)/)
	elsif ($event->args->{text} =~ /fn (\S+) (0x[0-9a-fA-F]+)\s*(.*)/)
	{
		# fn <fnName> <winId> <optArgs>
		my $tId = winIdToTId(hex($2));
		print(STDERR "focus not in tabber. ($2)\n"), return if ($tId < 0);
		no strict;
		&$1($tId, split(/\s+/, $3));
	}
	elsif ($event->args->{text} =~ /saveState/)
	{
		saveState();
	}
	else
	{
		print(STDERR $self->name() . ": Unknown command: " . $event->args->{text} . "\n");
	}
});

# showNext() - invoked from key binding.
sub showNext ($$)
{
	my ($tId, $inc) = @_;

	return if ($tabWin{$tId}{nTabs} <= 0);
	my $nextTabNo = ($tabWin{$tId}{currentTab} + $inc) % $tabWin{$tId}{nTabs};
	showTab($tId, $nextTabNo) if ($nextTabNo != $tabWin{$tId}{currentTab});
}

sub showLast ($)
{
	my ($tId) = @_;

	return if ($tabWin{$tId}{nTabs} <= 0 || !defined $tabWin{$tId}{lastId});
	my $tabNo = getTabNo($tId, $tabWin{$tId}{lastId});
	return if ($tabNo < 0);
	showTab($tId, $tabNo);
}

# releaseTab() - invoked from key binding.
sub releaseTab ($$$)
{
	my ($tId, $tabNo, $bIconify) = @_;
	$tabNo = $tabWin{$tId}{currentTab} if ($tabNo eq 'current');
	letItGo(undef, $tId, $tabNo, $bIconify);
}

$fvwm->addHandler(M_ADD_WINDOW, sub {
	my ($self, $event) = @_;

    return if (defined $global{doingTabize} && $global{doingTabize});
	$fvwm->debug("Add Window: " . join(", ", map("$_ = " . $event->args->{$_}, keys(%{$event->args}))));
	my $winId = $event->args->{win_id};

	swallowCheck($winId, \@autoSwallow);
});

# swallowCheck() - check if a window should be swallowed/tabized by a tabber.
sub swallowCheck ($$)
{
	my ($winId, $pArray) = @_;

	my $s = chr(0);
	my $name = getProperty($winId, 'WM_NAME');
	return if (!defined $name);
	my ($resource, $class) = split(/$s/, getProperty($winId, 'WM_CLASS'));

	foreach (@{$pArray})
	{
		if ((exists $_->{resource} && $resource =~ /$_->{resource}/) ||
			(exists $_->{class} && $class =~ /$_->{class}/) ||
			(exists $_->{name} && $name =~ /$_->{name}/))
		{
			my $tId = $_->{type};
			if ($tId =~ /any/i)
			{
				# choose the emptiest tabber.
				$tId = emptiestTabber();
				return if ($tId < 0);
			}
			elsif ($tId =~ /lastFocus/i)
			{
				$tId = (defined $global{lastFocus} ?
						$global{lastFocus} :
						emptiestTabber());
			}
			addTab($tId, $winId) if (exists $tabWin{$tId})
		}
	}
}

sub emptiestTabber ()
{
	my $tId = -1;	# return -1 if no tabbers running.
	my $n = 99;
	foreach (keys(%tabWin))
	{
		if ($tabWin{$_}{nTabs} < $n)
		{
			$tId = $_;
			$n = $tabWin{$_}{nTabs};
		}
	}
	return $tId;
}

# ON_EXIT handler is invoked just before this module terminates.
$fvwm->addHandler(ON_EXIT, sub {
	my ($self, $event) = @_; 
	print($fvwm->name() . ": Got ON_EXIT event.\n");
	cleanup();
});

$SIG{PIPE} = sub {
	print($fvwm->name() . ": SIGPIPE!\n");
	cleanup();
	exit;
};

sub cleanup ()
{
	foreach (keys(%tabWin))
	{
		closeTabber($_);
	}
}

my $fds = IO::Select->new($xServer->connection->fh);

sub callback
{
	$xServer->flush();
 	$xServer->handle_input() if ($fds->can_read(0));

	while (my %e = $xServer->dequeue_event())
	{
		eventHandler(%e)
	}
}

sub eventHandler
{
	my (%event) = @_;

	$fvwm->debug("Got a $event{name} event: " . join(", ", map("$_ = $event{$_}", keys(%event))));


	if ($event{name} eq 'ResizeRequest')
	{
		my $tId = -1;
		for (keys(%tabWin))
		{
			$tId = $_, last if ($tabWin{$_}{parent} == $event{window});
		}

		return if ($tId < 0);

		my $h = $tabWin{$tId}{winFrame}->height();
		# resize the $winFrame widget. Can't use $w->configure(-height ...)
		# cos we're requesting resize events on this widget.
		$xServer->ConfigureWindow($tabWin{$tId}{parent},
								  "height" => $h, #$event{height},
								  "width" => $event{width});

		if ($pConfig->{autoResize} =~ /true/i)
		{
			for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
			{
				$xServer->ConfigureWindow($tabWin{$tId}{tab}[$tabNo]{winId},
										  "height" => $h, # $event{height},
										  "width" => $event{width});
			}
		}
		else
		{
			# If the tabber is resized, resize the currently viewed app/tab
			# (if any) to fit into the new space.
			return if (!defined $tabWin{$tId}{currentTab});
			my $winId = $tabWin{$tId}{tab}[$tabWin{$tId}{currentTab}]{winId};
			
			$xServer->ConfigureWindow($winId,
									  "height" => $h, # $event{height},
									  "width" => $event{width});
		}
		return;
	}
	elsif ($event{name} eq 'EnterNotify')
	{
		my $tId = -1;
		for (keys(%tabWin))
		{
			$tId = $_, last if (getWrapperWinId($_) == $event{event});
		}

		print(STDERR "BUG: EnterNotify\n"), return if ($tId < 0);
		$tabWin{$tId}{focusTimestamp} = $event{time};
		$fvwm->debug("focusTimestamp set to $tabWin{$tId}{focusTimestamp}");
		takeFocus($tId);
		return;
	}

	my $tabNo = -1;
	my $tId = undef;
	for (keys(%tabWin))
	{
		$tabNo = getTabNo($_, $event{window});
		$tId = $_, last if ($tabNo >= 0)
	}

	if ($tabNo < 0)
	{
		$fvwm->debug("Ignoring event for invalid/unknown window.");
		return;
	}

	if ($event{name} eq 'PropertyNotify')
	{
		my $prop = $xServer->atom_name($event{atom});
		return if ($prop ne 'WM_NAME' && $prop ne 'WM_ICON_NAME');
		my $val = getProperty($event{window}, $prop);
		return if (!defined $val);	# window no longer exists!
		if ($prop eq 'WM_NAME')
		{
			setTabTitle($tId, $tabNo, $val);
		}
		elsif ($prop eq 'WM_ICON_NAME')
		{
			setTabName($tId, $tabNo, $val);
		}
	}
	elsif ($event{name} eq 'DestroyNotify')
	{
		removeTab($tId, $tabNo, 'destroyed');
	}
	elsif ($event{name} eq 'MapNotify')
	{
		$xServer->SetInputFocus($event{window}, 'Parent', 'CurrentTime');
	}
	else
	{
		$fvwm->debug("Got a strange event: $event{name}");
	}
}

sub getXYPos ($)
{
	my ($winId) = @_;

	my ($na1, $na2, $x, $y) = $xServer->TranslateCoordinates($winId,
                                                             $xServer->root(),
                                                             0,
                                                             0);
	return ($x, $y);
}

my $img;
if ($pConfig->{dragDropIcon} ne 'none')
{
	my $imgFile = $pConfig->{dragDropIcon};
	if (substr($imgFile, 0, 1) ne '/')
	{
		foreach (split(/:/, $pConfig->{global}->{ImagePath}))
		{
			my $tmp = "$_/$imgFile";
			$imgFile = $tmp, last if (-f $tmp);
		}
	}
	$img = eval { $TOP->Photo(-file => $imgFile); };
	if (!defined $img)
	{
		print(STDERR $fvwm->name() . ": Couldn't create D&D icon from $imgFile\n");
	}
}

sub addTab ($$)
{
	my ($tId, $winId) = @_;

	if ($winId == $tabWin{$tId}{selfId})
	{
		# can't make tabber a child of itself
		$fvwm->send("Beep");
		$fvwm->showError("Can't add self to tabber!");
		return;
	}

	# check if the window actually exists before we try to swallow it.
	if (!defined getProperty($winId, 'WM_NAME'))
	{
		print(STDERR $fvwm->name() . ": Window doesn't exist.\n");
		return;
	}

	my $tabNo = $tabWin{$tId}{nTabs}++;
	$tabWin{$tId}{tab}[$tabNo]{winId} = $winId;

	# save position of window for later.
	($tabWin{$tId}{tab}[$tabNo]{initialXPos}, $tabWin{$tId}{tab}[$tabNo]{initialYPos}) = getXYPos($winId);

	# if the auto-resize option is specified & the new window to add is
	# smaller than the tabber, then we need to enlarge the new window. If
	# the new window is larger than the tabber, then the tabber will
	# expand appropriately (with all existing windows in the tabber) on
	# the resize event.
	if ($pConfig->{autoResize} =~ /true/i)
	{
		my %g = $xServer->GetGeometry($winId);
		my $h = $tabWin{$tId}{winFrame}->height();
		my $w = $tabWin{$tId}{winFrame}->width();
		if ($g{height} < $h || $g{width} < $w)
		{
			$xServer->ConfigureWindow($winId, "height" => $h, "width" => $w);
		}
	}

	$xServer->ReparentWindow($winId, $tabWin{$tId}{parent}, (0, 0));
	my $txt = getProperty($winId, "WM_ICON_NAME");
	$tabWin{$tId}{tab}[$tabNo]{button} =
		$tabWin{$tId}{tabFrame}->Button(-text => $txt,
										-padx => 2,
										-width => 1,
										-anchor => 'w',
										-command => [\&showTabClick, $tId, $winId],
										-font => $pConfig->{buttonFont});
	my $pButton = $tabWin{$tId}{tab}[$tabNo]{button};

	# Raise the FvwmTabs window whenever a tab is selected.
	$pButton->Tk::bind('<ButtonPress-1>', sub { $fvwm->send("Current Raise"); });
	$pButton->pack(-side => 'left', -expand => 1, -fill => 'x');
	$pButton->Tk::bind('<ButtonRelease-2>', [\&letItGoClick, $tId, $winId, 0]);
	$pButton->Tk::bind('<ButtonRelease-3>', [\&letItGoClick, $tId, $winId, 1]);

	# drag-&-drop to reorder tabs.
	my $dd = $pButton->DragDrop(-event => '<Control-B2-Motion>',
								-sitetypes => [qw(Local)],
								-selection => $winId,
								-cursor => 'sb_h_double_arrow',
								-text => '*',
								-handlers => []);
	my $site =
	$pButton->DropSite(-droptypes => [qw(Local)],
					   -dropcommand => [\&reorderTabClick, [$tId, $winId]]);
	if ($pConfig->{dragDropIcon} ne 'none' && defined $img)
	{
		$dd->configure(-image => $img);
	}

	# This line gets around a bug in Tk::DropSite.
	$pButton->Tk::bind($site, '<Configure>', [$site, 'DropSiteUpdate']) if ($global{buggyTkDND});

	$tabWin{$tId}{tab}[$tabNo]{title} = getProperty($winId, "WM_NAME");

	$balloon->attach($pButton,
					 -balloonmsg => \$tabWin{$tId}{balloonMsg},
					 -postcommand => [\&setBalloonMsg, $tId, $winId]);

	# Ensure we are notified of any attribute changes in the new window.
	# PropertyChange will tell us when WM_NAME or WM_ICON_NAME changes.
	# StructureNotify will tell us when a program running in a tab
	# terminates/is-destroyed.
	$xServer->ChangeWindowAttributes($winId,
			  event_mask => $xServer->pack_event_mask('PropertyChange',
			  										  'StructureNotify'));
	showTab($tId, $tabNo);
}

sub pickAndAdd ($$)
{
	my ($tId, $arg) = @_;
	$fvwm->send("Pick SendToModule *" . $fvwm->name() . " addme $tId $arg");
}

sub tabInfo ($)
{
	my ($tId) = @_;

	print("\nnTabs=$tabWin{$tId}{nTabs}\n");
	printf("parent=0x%x (%d)\n", $tabWin{$tId}{parent}, $tabWin{$tId}{parent});
	printf("self=0x%x (%d)\n", $tabWin{$tId}{selfId}, $tabWin{$tId}{selfId});
	for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
	{
		printf("Tab #$tabNo winId = 0x%x (%d)\n",
			   $tabWin{$tId}{tab}[$tabNo]{winId},
			   $tabWin{$tId}{tab}[$tabNo]{winId});
	}
	print("AutoSwallow:\n");
	foreach my $a (@autoSwallow)
	{
		print("\t" . join(", ", map("$_=" . $a->{$_}, sort(keys(%{$a})))) . "\n");
	}

	XSync();
}

sub getProperty ($$)
{
	my ($winId, $property) = @_;

	my @s = $xServer->robust_req('GetProperty',
								 $winId,
								 $xServer->atom($property),
								 'AnyPropertyType', 0, 200, 0);
	my $p = $s[0];
	return undef if ($p eq 'Window');
	return $p->[0];
}

# return the tabNo for the specified window ID or -1 if the window is
# not part of the tabber.
# TODO: rename this function to "winIdToTabNo"?
sub getTabNo ($$)
{
	my ($tId, $winId) = @_;
	for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
	{
		return $tabNo if ($tabWin{$tId}{tab}[$tabNo]{winId} == $winId);
	}
	return -1;
}

# the window for <$tabNo> has been destroyed/letgo - cleanup appropriately.
sub removeTab ($$$)
{
	my ($tId, $tabNo, $state) = @_;

	$fvwm->debug("removeTab($tId, $tabNo, $state)");

	if ($state eq 'letgo')
	{
		# We are no longer interested in events for this window.
		$xServer->ChangeWindowAttributes($tabWin{$tId}{tab}[$tabNo]{winId},
			  event_mask => $xServer->pack_event_mask());
	}

	$balloon->detach($tabWin{$tId}{tab}[$tabNo]{button});
	$tabWin{$tId}{tab}[$tabNo]{button}->destroy();
	$tabWin{$tId}{tab}[$tabNo] = undef;

	for (my $t = $tabNo; $t < $tabWin{$tId}{nTabs} - 1; $t++)
	{
		$tabWin{$tId}{tab}[$t] = $tabWin{$tId}{tab}[$t + 1];
	}
	$tabWin{$tId}{nTabs}--;
	$tabWin{$tId}{tab}[$tabWin{$tId}{nTabs}] = undef;

	if ($tabWin{$tId}{currentTab} == $tabNo)
	{
		$tabWin{$tId}{currentTab} = undef;
		if ($tabWin{$tId}{nTabs} > 0)
		{
			showTab($tId, ($tabNo < $tabWin{$tId}{nTabs} ? $tabNo : $tabNo - 1))
		}
		else
		{
			$tabWin{$tId}{toplevel}->wm('grid', '', '', '', '');
			$tabWin{$tId}{titleFrame}->configure(-text => 'No title');
			$tabWin{$tId}{winFrame}->configure(-height => 1, -width => 0);
		}
	}
	else
	{
		$tabWin{$tId}{currentTab}-- if ($tabWin{$tId}{currentTab} > $tabNo);
		if ($tabWin{$tId}{nTabs} == 1)
		{
			# allow the selected tab button to expand as much as possible.
			$tabWin{$tId}{tab}[$tabWin{$tId}{currentTab}]{button}->pack(-expand => 1);
		}
	}
}

sub showTab ($$)
{
	my ($tId, $tabNo) = @_;

	$fvwm->send("Beep"), return if ($tabNo >= $tabWin{$tId}{nTabs});

	# Unmap the current tab.
	if (defined($tabWin{$tId}{currentTab}))
	{
		my $currentTab = $tabWin{$tId}{currentTab};
		return if ($tabNo == $currentTab);
		my $winId = $tabWin{$tId}{tab}[$currentTab]{winId};
		$xServer->UnmapWindow($winId);
		$tabWin{$tId}{tab}[$currentTab]{button}->configure(
					-bg => $pConfig->{inactiveBG},
					-activebackground => $pConfig->{inactiveBG},
					-fg => $pConfig->{inactiveFG},
					-activeforeground => $pConfig->{inactiveFG},
					-width => 1,
					-relief => 'raised');
		$tabWin{$tId}{tab}[$currentTab]{button}->pack(-expand => 1);
		$tabWin{$tId}{lastId} = $winId;
	}
	# Map the new tab.
	my $winId = $tabWin{$tId}{tab}[$tabNo]{winId};
	$xServer->MapWindow($winId);
	$tabWin{$tId}{currentTab} = $tabNo;
	my $bEq = ($pConfig->{fixedSizeTabs} =~ /true/i ? 1 : 0);
	$tabWin{$tId}{tab}[$tabNo]{button}->configure(
					-bg => $pConfig->{activeBG},
					-activebackground => $pConfig->{activeBG},
					-fg => $pConfig->{activeFG},
					-activeforeground => $pConfig->{activeFG},
					-width => $bEq,
					-relief => $pConfig->{activeRelief});
	my $bExpand = ($bEq || ($tabWin{$tId}{nTabs} == 1));
	$tabWin{$tId}{tab}[$tabNo]{button}->pack(-expand => $bExpand);

	my %g = $xServer->GetGeometry($winId);
	$tabWin{$tId}{winFrame}->configure(-height => $g{height}, -width => $g{width});
	$tabWin{$tId}{toplevel}->geometry("");
	showTitle($tId, $tabNo, $g{width});
	setResizing ($tId, $winId);
	# If we're changing the active tab really quickly we have to handle/flush
	# all the X events in the queue - this prevents us from getting a
	# 'Protocol Error'.
	callback();
}

sub showTabClick ($$)
{
	my ($tId, $winId) = @_;
	showTab($tId, getTabNo($tId, $winId));
}

sub showTitle ($$$)
{
	my ($tId, $tabNo, $w) = @_;

	$fvwm->debug("BUG: showTitle()") if ($tabNo != $tabWin{$tId}{currentTab});
	# This is a nice feature - Wrap the title text across multiple lines.
	# The following command in an xterm window illustrates the usefulness:
	# echo "abc\ndef\nghi\njkl" && sleep 3

	$w -= 30;

	my $titleStr = $tabWin{$tId}{tab}[$tabNo]{title};
	# make sure the title text does not exceed this length.
	$tabWin{$tId}{titleFrame}->configure(-text => $titleStr,
										 -wraplength => "${w}p");

	if ($pConfig->{useTMTitlebar} =~ /true/i)
	{
		my $title = $fvwm->name() . " [$tId] : " . $titleStr;
		$tabWin{$tId}{toplevel}->configure(-title => $title);
	}
}

sub setTabTitle($$$)
{
	my ($tId, $tabNo, $titleStr) = @_;

	$titleStr =~ s/\n//g;
	$tabWin{$tId}{tab}[$tabNo]{title} = $titleStr;
	if ($tabNo == $tabWin{$tId}{currentTab})
	{
		# get the width of the title label in pixels.
		my $w = $tabWin{$tId}{titleFrame}->width();
		showTitle($tId, $tabNo, $w);
	}
}

sub showTitlebar ($)
{
	my ($tId) = @_;

	if ($tabWin{$tId}{showTitlebar})
	{
		$tabWin{$tId}{titleFrame}->pack(-expand => 0, -fill => 'x', -side => 'top');
	}
	else
	{
		$tabWin{$tId}{titleFrame}->pack('forget');
		$tabWin{$tId}{wrapFrame}->configure(-width => 0, -height => 1);
	}
}

sub setTabName ($$$)
{
	my ($tId, $tabNo, $name) = @_;

	$tabWin{$tId}{tab}[$tabNo]{button}->configure(-text => $name);
}

sub selectFont ($$)
{
	my ($tId, $type) = @_;
	my $cmd = $pConfig->{fontSelector};
	my $currentFont = $pConfig->{$type . 'Font'};
	$cmd =~ s/%f/$currentFont/g;
	$SIG{CHLD}= sub { wait; };
	my $pipe = new FileHandle();
	if (!$pipe->open("$cmd|"))
	{
		$fvwm->showError("Select font: command $cmd failed.");
		return
	}

	sub fontCallback ($$$)
	{
		my ($pipe, $tId, $type) = @_;
		my $line = $pipe->getline();
		setFont($tId, $type, $line) if (defined($line));
		$pipe->close() if ($pipe->eof());
	}

	$TOP->fileevent($pipe, "readable" => [\&fontCallback, $pipe, $tId, $type]);
}

sub setFont ($$$)
{
	my ($tId, $type, $font) = @_;
	$fvwm->debug("new $type font is: $font");
	$pConfig->{$type . 'Font'} = $font;
	if ($type eq 'button')
	{
		for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
		{
			$tabWin{$tId}{tab}[$tabNo]{button}->configure(-font => $font);
		}	
		$tabWin{$tId}{menuButton}->configure(-font => $font);
		$tabWin{$tId}{tabFrame}->configure(-height => $tabWin{$tId}{menuButton}->reqheight());
	}
	elsif ($type eq 'title')
	{
		$tabWin{$tId}{titleFrame}->configure(-font => $font);
	}
	elsif ($type eq 'menu')
	{
		$tabWin{$tId}{menu}->configure(-font => $font);
	}
}

sub version ()
{
	my $rcsId = '$Id: FvwmTabs.in,v 2.9 2005/11/06 01:35:24 scott Exp $';
	$rcsId =~ /,v (.*) (\d+\/\d+\/\d+) \d+:\d+:\d+/;
	return ($1, $2);
}

sub about ($)
{
	my ($tId) = @_;

	my ($v, $d) = version();
	my $version = $fvwm->name() . " v$v   ($d)\n\nby Scott Smedley\nscottie7\@tpg.com.au"; # \n\nhttp://users.tpg.com.au/users/scottie7/fvwmtabs.html";
	# TODO: Tk::Dialog has a hardcoded width of 3 inches, how annoying!
	$fvwm->showMessage($version, "About " . $fvwm->name());
}

sub setBalloonMsg ($$)
{
	my ($tId, $winId) = @_;

	my $tabNo = getTabNo($tId, $winId);

	my $msg = $pConfig->{balloonMsg};
	$msg =~ s/\\n/\n/g;
	$msg =~ s/%tabNo/$tabNo/gi;
	my $iconText = $tabWin{$tId}{tab}[$tabNo]{button}->cget(-text);
	$msg =~ s/%iconText/$iconText/gi;
	$msg =~ s/%title/$tabWin{$tId}{tab}[$tabNo]{title}/gi;
	$tabWin{$tId}{balloonMsg} = $msg;
}

sub reorderTab ($$$)
{
	my ($tId, $insertionPoint, $tabNo) = @_;

	return if ($insertionPoint == $tabNo || $insertionPoint == $tabNo + 1);

	my ($s, $e) = ($insertionPoint > $tabNo ?
				   ($tabNo, $insertionPoint) :
				   ($insertionPoint, $tabNo));

	for (my $i = $s; $i < $tabWin{$tId}{nTabs}; $i++)
	{
		$tabWin{$tId}{tab}[$i]{button}->pack('forget');
	}
	
	my $currentWinId = $tabWin{$tId}{tab}[$tabWin{$tId}{currentTab}]{winId};

	my $mover = $tabWin{$tId}{tab}[$tabNo];
	if ($insertionPoint > $tabNo)
	{
		for (my $i = $s; $i < $e - 1; $i++)
		{
			$tabWin{$tId}{tab}[$i] = $tabWin{$tId}{tab}[$i+1];
		}
		$tabWin{$tId}{tab}[$e-1] = $mover;
	}
	else
	{
		for (my $i = $e; $i > $s; $i--)
		{
			$tabWin{$tId}{tab}[$i] = $tabWin{$tId}{tab}[$i-1];
		}
		$tabWin{$tId}{tab}[$insertionPoint] = $mover;
	}
	$tabWin{$tId}{currentTab} = getTabNo($tId, $currentWinId);

	for (my $i = $s; $i < $tabWin{$tId}{nTabs}; $i++)
	{
		my $bExpand = 1;
		if ($i == $tabWin{$tId}{currentTab})
		{
			my $bEq = ($pConfig->{fixedSizeTabs} =~ /true/i ? 1 : 0);
			$bExpand = ($pConfig->{fixedSizeTabs} =~ /true/i ||
						($tabWin{$tId}{nTabs} == 1) ? 1 : 0);
		}
		$tabWin{$tId}{tab}[$i]{button}->pack(-expand => $bExpand, -fill => 'x', -side => 'left');
	}
}

sub reorderTabClick ($$$)
{
	my ($pa, $winId, $notUsed) = @_;

	my ($tId, $insertionPoint) = @$pa;
	reorderTab($tId, getTabNo($tId, $insertionPoint), getTabNo($tId, $winId));
}

sub swapRight ($)
{
	my ($tId) = @_;

	return if ($tabWin{$tId}{nTabs} <= 0);
	if ($tabWin{$tId}{currentTab} == $tabWin{$tId}{nTabs} - 2)
	{
		reorderTab($tId, $tabWin{$tId}{currentTab}, $tabWin{$tId}{currentTab}+1);
	}
	else
	{
		my $inc = ($tabWin{$tId}{currentTab} == ($tabWin{$tId}{nTabs} - 1) ? 1 : 2);
		reorderTab($tId,
				   ($tabWin{$tId}{currentTab} + $inc) % $tabWin{$tId}{nTabs},
				   $tabWin{$tId}{currentTab});
	}
}

sub swapLeft ($)
{
	my ($tId) = @_;

	return if ($tabWin{$tId}{nTabs} <= 0);
	my $b = ($tabWin{$tId}{currentTab} == 0 ? 1 : 0);
	reorderTab($tId,
			   ($tabWin{$tId}{currentTab} - 1) % $tabWin{$tId}{nTabs},
			   $tabWin{$tId}{currentTab});
	swapRight($tId) if ($b);
}

# record which desk each tab-manager is on for saveState().
$fvwm->mask($fvwm->mask() | M_CONFIGURE_WINDOW | M_ADD_WINDOW);
$fvwm->addHandler(M_ADD_WINDOW, sub {
	my ($self, $event) = @_;

	# we keep all windows cos at this point 'selfId' may not be defined
	# & we need to use it to decide if this is a tab-manager window.
	$global{winIdToDesk}{$event->args->{win_id}} = $event->args->{desk};
});
$fvwm->addHandler(M_CONFIGURE_WINDOW, sub {
	my ($self, $event) = @_;

	$global{winIdToDesk}{$event->args->{win_id}} = $event->args->{desk};
});

sub getDesk ($)
{
	my ($winId) = @_;
	return $global{winIdToDesk}{$winId};
}

sub saveState ()
{
	my $file = $pConfig->{stateFile};
	if (!open(OUT, ">$file"))
	{
		print(STDERR $fvwm->name() . ": Couldn't save state to $file.\n");
		return;
	}
	chmod(0600, $file);
	print(STDERR $fvwm->name() . ": Saving state to $file\n");
	foreach my $tId (sort(keys(%tabWin)))
	{
		print(OUT "createNewTabber();\n");
		my ($x, $y) = getXYPos(getWrapperWinId($tId));
		print(OUT "\$fvwm->send(\"Move ${x}p ${y}p\", \$tabWin{$tId}{selfId});\n");
		my $desk = getDesk($tabWin{$tId}{selfId});
		print(OUT "\$fvwm->send(\"MoveToDesk 0 $desk\", \$tabWin{$tId}{selfId});\n");
		for (my $tabNo = 0; $tabNo < $tabWin{$tId}{nTabs}; $tabNo++)
		{
			print(OUT "addTab($tId, $tabWin{$tId}{tab}[$tabNo]{winId});\n");
		}
		if ($tabWin{$tId}{nTabs} > 0)
		{
			print(OUT "showTab($tId, $tabWin{$tId}{currentTab});\n");
		}
	}
	close(OUT);
}

sub loadState ()
{
	my $file = $pConfig->{stateFile};
	if (-r $file)
	{
		print(STDERR $fvwm->name() . ": Reading state from $file\n");
		eval `cat $file`;
		unlink($file);
	}
}

# ======= ======= =======

sub createThingy ($$$;@)
{
	my ($w, $label, $var, @po) = @_;

	my $f = $w->Frame()->pack(@po, -expand => 0, -fill => 'x');
	$f->Label(-text => $label)->pack(-side => 'left', -anchor => 'w');
	my $lb = $f->BrowseEntry(-listwidth => 20,
							 -state => 'readonly',
							 -variable => $var,
							 -width => 3);
	$lb->Subwidget('entry')->Subwidget('entry')->configure(-bg => 'white');
	$lb->Subwidget('slistbox')->configure(-bg => 'white', -height => 4);
	$lb->Subwidget('choices')->configure(-bg => 'yellow');
	return $lb;
}
 
sub createSwallowDialog ($)
{
	my ($main) = @_;

	$global{tabberNo} = $global{deskNo} = $global{pageNo} = 'Any';
	my @pad = qw/-padx 3 -pady 3/;
	my $name = $fvwm->name . ": Tabizer";
	my $tl = $main->Toplevel(-title => $name);
	my $top = $tl->Frame()->pack(-expand => 1, -fill => 'both', @pad);
	$tl->iconname($name);
	$tl->protocol('WM_DELETE_WINDOW', [$tl, 'destroy']);

	$global{eTabberNo} = createThingy($top,
									  'Add to Tab-Manager no.:',
									  \$global{tabberNo},
									  @pad);
	$global{eTabberNo}->pack(-side => 'left', -anchor => 'w', @pad);

	my $lf = $top->LabFrame(-label => 'Swallow Matching Windows',
							-labelside => 'acrosstop');
	$lf->pack(-expand => 0, -fill => 'both', @pad);
	$global{regex} = $lf->LabEntry(-label => 'regex:',
								   -bg => 'white',
								   -labelPack => [qw/-side left/]);
	$global{regex}->pack(-fill => 'x', @pad);

	$global{regexType} = 'Name';
	my $f = $lf->Frame()->pack();
	foreach ('Name', 'Class', 'Resource')
	{
		$f->Radiobutton(-text => $_,
						-value => $_,
						-variable => \$global{regexType})->pack(-side => 'left');
	}

	$f = $lf->Frame()->pack(-expand => 0, -fill => 'x');
	$global{eDeskNo} = createThingy($f, 'Desk:',
									\$global{deskNo},
									-side => 'left', @pad)->pack(@pad);
	$global{ePageNo} = createThingy($f, 'Page:',
									\$global{pageNo},
									-side => 'left', @pad)->pack(@pad);
	$lf->Button(-text => 'Add Matching',
				-activeforeground => 'LimeGreen',
				-command => \&doRegexSwallow)->pack(-fill => 'x', @pad);

	$lf = $top->LabFrame(-label => 'Swallow Individual Windows',
						 -labelside => 'acrosstop');
	$lf->pack(-expand => 1, -fill => 'both', @pad);

	$global{list} = $lf->Scrolled('Listbox',
								  -width => 40,
								  -height => 10,
								  -setgrid => 1,
								  -bg => 'white',
								  -selectmode => 'extended',
								  -selectbackground => 'darkblue',
								  -selectforeground => 'white',
								  -scrollbars => 'osoe');
	$global{list}->pack(-expand => 1, -fill => 'both', -padx => 2, -pady => 2);
	my @po = qw/-side left -expand 1 -fill x/;
	$lf->Button(-text => 'Add Selected',
				-activeforeground => 'LimeGreen',
				-command => \&doSwallow)->pack(@po, @pad);
	$lf->Button(-text => 'Refresh List',
				-activeforeground => 'orange',
				-command => \&fillDialog)->pack(@po, @pad);
	$top->Button(-text => 'Close',
				 -activeforeground => 'red',
				 -command => [$tl, 'destroy'])->pack(@po, @pad);
	# $tl->resizable(0, 0);
}

sub doSwallow ()
{
	foreach ($global{list}->curselection())
	{
		my $tId = $global{tabberNo};
		$tId = emptiestTabber() if ($global{tabberNo} eq 'Any');
		addTab($tId, $global{windows}[$_]);
	}
	fillDialog();
}

sub doRegexSwallow ()
{
	my $regex = $global{regex}->get();
	if ($regex ne '')
	{
		$regex =~ s|/|\/|g;
		my $deskNo = $global{deskNo};
		my $pageNo = $global{pageNo};
		my %p = (lc($global{regexType}) => $regex, type => $global{tabberNo});
		my @a;
		push(@a, \%p);
		foreach my $winId (keys(%{$global{info}}))
		{
			next if ($deskNo ne 'Any' &&
					 $global{info}{$winId}{desk} != $deskNo);
			next if ($pageNo ne 'Any' &&
					 $global{info}{$winId}{page} != $pageNo);

			swallowCheck($winId, \@a);
		}
	}
	fillDialog();
}

sub tabizeWindows ($)
{
	my ($tId) = @_;

	createSwallowDialog($TOP);
	my $nTabbers = scalar(keys(%tabWin)) - 1;
	$global{eTabberNo}->configure(-choices => ['Any', 0 .. $nTabbers]);
	$global{tabberNo} = $tId;
	fillDialog();
}

sub max ($$) { return ($_[0] > $_[1] ? $_[0] : $_[1]); }

sub fillDialog ()
{
	if (!defined $global{bHandlersInstalled})
	{
		$global{bHandlersInstalled} = 1;
		$fvwm->addHandler(M_NEW_PAGE, sub {
			my ($module, $event) = @_;

			$global{pageWidth} = $event->args->{vp_width};
			$global{pageHeight} = $event->args->{vp_height};
			$global{nPagesPerDesk} = $event->args->{desk_pages_x};
		});

		$fvwm->addHandler(M_CONFIGURE_WINDOW, sub {
			my ($module, $event) = @_;

			my $page = $event->args->{frame_x} / $global{pageWidth};
			$global{maxDesk} = max($event->args->{desk}, $global{maxDesk});
			my $winId = $event->args->{win_id};
			push(@{$global{windows}}, $winId);
			$global{info}{$winId}{desk} = $event->args->{desk};
			$global{info}{$winId}{page} = $page;
		});

		$fvwm->addHandler(M_WINDOW_NAME, sub {
			my ($module, $event) = @_;

			return unless $global{doingTabize};
			$global{list}->insert('end', $event->args->{name});
		});

		$fvwm->addHandler(M_END_WINDOWLIST, sub {
			$fvwm->mask($global{oldMask});
			$fvwm->debug("pageWidth=$global{pageWidth}");
			$fvwm->debug("pageHeight=$global{pageHeight}");
			$fvwm->debug("nPages/desk=$global{nPagesPerDesk}");
			my $nPages = $global{nPagesPerDesk} - 1;
			$global{eDeskNo}->configure(-choices => ['Any', 0 .. $global{maxDesk}]);
			$global{ePageNo}->configure(-choices => ['Any', 0 .. $nPages]);
		});
	}

	$global{oldMask} = $fvwm->mask();
	$fvwm->mask($global{oldMask} | M_WINDOW_NAME | M_NEW_PAGE | M_CONFIGURE_WINDOW | M_END_WINDOWLIST);
	$global{maxDesk} = 0;
	delete $global{info};
	@{$global{windows}} = ();
    $global{doingTabize} = 1;
	$global{list}->delete('0.0', 'end');
	$fvwm->send("Send_WindowList");
}

# ======= ======= =======

sub setResizing ($$)
{
	my ($tId, $winId) = @_;

	my @s = $xServer->GetProperty($winId,
								  $xServer->atom('WM_NORMAL_HINTS'),
								  'AnyPropertyType', 0, 200, 0);

	my ($flags) = unpack("L", $s[0]);
	my ($wInc, $hInc, $baseW, $baseH) = (1, 1, 0, 0);
	if ($flags & (1 << 6)) # PResizeInc
	{
		# $wInc & $hInc specify multiples of pixels to increment by.
		($wInc, $hInc) = unpack("II", substr($s[0], 36, 8));
		# $baseW & $baseH are number of pixels in window that aren't
		# part of the resizable area. But note that this is completely
		# different to the $baseW & $baseH we need to input to wmGrid().
		($baseW, $baseH) = unpack("II", substr($s[0], 60, 8));
	}

	my %g = $xServer->GetGeometry($winId);
	# $baseW & $baseH are number of grid units of *resizable* part of window.
	$baseW = ($g{width} - $baseW) / $wInc;
	$baseH = ($g{height} - $baseH) / $hInc;

	# In pre-804.025 versions of Tk there is a bug in wmGrid().
	# $tabWin{$tId}{toplevel}->wmGrid($baseW, $baseH, $wInc, $hInc);
	$tabWin{$tId}{toplevel}->wm('grid', $baseW, $baseH, $wInc, $hInc);
}

loadState();
my ($version, $date) = version();
print($fvwm->name() . " (v$version) started with: Perl " . join('.', map(ord($_), split(//, $^V))) . ", X11::Protocol " .  $X11::Protocol::VERSION . ", Tk $Tk::VERSION.\n");
$fvwm->eventLoop();
