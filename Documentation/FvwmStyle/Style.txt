   [IMG]    Home ⋅ All Commands ⋅ Grouped Commands ⋅ Modules ⋅ FAQ      [IMG]

Style

   --------------------------------------------------------------------------

   Style stylename options...

   The Style command is used to set attributes of a window to values other
   than the default or to set the window manager default styles.

   stylename can be a window's name, class, visible name, or resource string.
   It may contain the wildcards '*' and '?', which are matched in the usual
   Unix filename manner. Multiple style options in a single Style command are
   read from left to right as if they were issued one after each other in
   separate commands. A given style always overrides all conflicting styles
   that have been issued earlier (or further left on the same style line).

   Note: windows that have no name (WM_NAME) are given a name of "Untitled",
   and windows that do not have a class (WM_CLASS, res_class) are given class
   "NoClass" and those that do not have a resource (WM_CLASS, res_name) are
   given resource "NoResource".

   If a window has the resource "fvwmstyle" set, the value of that resource
   is used in addition to any window names when selecting the style.

   options is a comma separated list containing one or more of the following
   keywords. Each group of style names is separated by slashes ('/'). The
   last style in these groups is the default. BorderWidth, HandleWidth, !Icon
   / Icon, MiniIcon, IconBox, IconGrid, IconFill, IconSize, !Title / Title,
   TitleAtBottom / TitleAtLeft / TitleAtRight / TitleAtTop,
   LeftTitleRotatedCW / LeftTitleRotatedCCW, RightTitleRotatedCCW /
   RightTitleRotatedCW, TopTitleRotated / TopTitleNotRotated,
   BottomTitleRotated / BottomTitleNotRotated, !UseTitleDecorRotation /
   UseTitleDecorRotation, StippledTitle / !StippledTitle, StippledIconTitle /
   !StippledIconTitle, IndexedWindowName / ExactWindowName, IndexedIconName /
   ExactIconName, !Borders / Borders, !Handles / Handles, WindowListSkip /
   WindowListHit, CirculateSkip / CirculateHit, CirculateSkipShaded /
   CirculateHitShaded, CirculateSkipIcon / CirculateHitIcon, Layer,
   StaysOnTop / StaysOnBottom / StaysPut, Sticky / Slippery,
   StickyAcrossPages / !StickyAcrossPages, StickyAcrossDesks /
   !StickyAcrossDesks, !StickyStippledTitle / StickyStippledTitle,
   !StickyStippledIconTitle / StickyStippledIconTitle, StartIconic /
   StartNormal, Color, ForeColor, BackColor, Colorset, HilightFore,
   HilightBack, HilightColorset, BorderColorset, HilightBorderColorset,
   IconTitleColorset, HilightIconTitleColorset, IconBackgroundColorset,
   IconTitleRelief, IconBackgroundRelief, IconBackgroundPadding, Font,
   IconFont, StartsOnDesk / StartsOnPage / StartsAnyWhere, StartsOnScreen,
   StartShaded / !StartShaded, ManualPlacementHonorsStartsOnPage /
   ManualPlacementIgnoresStartsOnPage, CaptureHonorsStartsOnPage /
   CaptureIgnoresStartsOnPage, RecaptureHonorsStartsOnPage /
   RecaptureIgnoresStartsOnPage, StartsOnPageIncludesTransients /
   StartsOnPageIgnoresTransients, IconTitle / !IconTitle, MwmButtons /
   FvwmButtons, MwmBorder / FvwmBorder, MwmDecor / !MwmDecor, MwmFunctions /
   !MwmFunctions, HintOverride / !HintOverride, !Button / Button,
   ResizeHintOverride / !ResizeHintOverride, OLDecor / !OLDecor,
   GNOMEUseHints / GNOMEIgnoreHints, StickyIcon / SlipperyIcon,
   StickyAcrossPagesIcon / !StickyAcrossPagesIcon, StickyAcrossDesksIcon /
   !StickyAcrossDesksIcon, ManualPlacement / CascadePlacement /
   MinOverlapPlacement / MinOverlapPercentPlacement / TileManualPlacement /
   TileCascadePlacement / PositionPlacement, MinOverlapPlacementPenalties,
   MinOverlapPercentPlacementPenalties, DecorateTransient / NakedTransient,
   DontRaiseTransient / RaiseTransient, DontLowerTransient / LowerTransient,
   DontStackTransientParent / StackTransientParent, SkipMapping /
   ShowMapping, ScatterWindowGroups / KeepWindowGroupsOnDesk, UseDecor,
   UseStyle, !UsePPosition / NoPPosition / UsePPosition, !UseUSPosition,
   NoUSPosition / UseUSPosition, !UseTransientPPosition, NoTransientPPosition
   / UseTransientPPosition, !UseTransientUSPosition / NoTransientUSPosition /
   UseTransientUSPosition, !UseIconPosition / NoIconPosition /
   UseIconPosition, Lenience / !Lenience, ClickToFocus / SloppyFocus /
   MouseFocus|FocusFollowsMouse / NeverFocus, ClickToFocusPassesClickOff /
   ClickToFocusPassesClick, ClickToFocusRaisesOff / ClickToFocusRaises,
   MouseFocusClickRaises / MouseFocusClickRaisesOff, GrabFocus /
   GrabFocusOff, GrabFocusTransientOff / GrabFocusTransient,
   FPFocusClickButtons, FPFocusClickModifiers, !FPSortWindowlistByFocus /
   FPSortWindowlistByFocus, FPClickRaisesFocused / !FPClickRaisesFocused,
   FPClickDecorRaisesFocused / !FPClickDecorRaisesFocused,
   FPClickIconRaisesFocused / !FPClickIconRaisesFocused,
   !FPClickRaisesUnfocused / FPClickRaisesUnfocused,
   FPClickDecorRaisesUnfocused / !FPClickDecorRaisesUnfocused,
   FPClickIconRaisesUnfocused / !FPClickIconRaisesUnfocused, FPClickToFocus /
   !FPClickToFocus, FPClickDecorToFocus / !FPClickDecorToFocus,
   FPClickIconToFocus / !FPClickIconToFocus, !FPEnterToFocus /
   FPEnterToFocus, !FPLeaveToUnfocus / FPLeaveToUnfocus, !FPFocusByProgram /
   FPFocusByProgram, !FPFocusByFunction / FPFocusByFunction,
   FPFocusByFunctionWarpPointer / !FPFocusByFunctionWarpPointer, FPLenient /
   !FPLenient, !FPPassFocusClick / FPPassFocusClick, !FPPassRaiseClick /
   FPPassRaiseClick, FPIgnoreFocusClickMotion / !FPIgnoreFocusClickMotion,
   FPIgnoreRaiseClickMotion / !FPIgnoreRaiseClickMotion,
   !FPAllowFocusClickFunction / FPAllowFocusClickFunction,
   !FPAllowRaiseClickFunction / FPAllowRaiseClickFunction, FPGrabFocus /
   !FPGrabFocus, !FPGrabFocusTransient / FPGrabFocusTransient,
   FPOverrideGrabFocus / !FPOverrideGrabFocus, FPReleaseFocus /
   !FPReleaseFocus, !FPReleaseFocusTransient / FPReleaseFocusTransient,
   FPOverrideReleaseFocus / !FPOverrideReleaseFocus, StartsLowered /
   StartsRaised, IgnoreRestack / AllowRestack, FixedPosition /
   VariablePosition, FixedUSPosition / VariableUSPosition, FixedPPosition /
   VariablePPosition, FixedSize / VariableSize, FixedUSSize / VariableUSSize,
   FixedPSize / VariablePSize, !Closable / Closable, !Iconifiable /
   Iconifiable, !Maximizable / Maximizable, !AllowMaximizeFixedSize /
   AllowMaximizeFixedSize, IconOverride / NoIconOverride /
   NoActiveIconOverride, DepressableBorder / FirmBorder, MinWindowSize,
   MaxWindowSize, IconifyWindowGroups / IconifyWindowGroupsOff, ResizeOpaque
   / ResizeOutline, BackingStore / BackingStoreOff /
   BackingStoreWindowDefault, Opacity / ParentalRelativity, SaveUnder /
   SaveUnderOff, WindowShadeShrinks / WindowShadeScrolls, WindowShadeSteps,
   WindowShadeAlwaysLazy / WindowShadeBusy / WindowShadeLazy, EWMHDonateIcon
   / EWMHDontDonateIcon, EWMHDonateMiniIcon / EWMHDontDonateMiniIcon,
   EWMHMiniIconOverride / EWMHNoMiniIconOverride, EWMHUseStackingOrderHints /
   EWMHIgnoreStackingOrderHints, EWMHIgnoreStateHints / EWMHUseStateHints,
   EWMHIgnoreStrutHints / EWMHUseStrutHints, EWMHIgnoreWindowType /
   !EWMHIgnoreWindowType, EWMHMaximizeIgnoreWorkingArea /
   EWMHMaximizeUseWorkingArea / EWMHMaximizeUseDynamicWorkingArea,
   EWMHPlacementIgnoreWorkingArea / EWMHPlacementUseWorkingArea /
   EWMHPlacementUseDynamicWorkingArea, MoveByProgramMethod, Unmanaged, State,
   SnapGrid, SnapAttraction, EdgeMoveDelay, EdgeResizeDelay.
   EdgeMoveResistance, InitialMapCommand

   In the above list some options are listed as
   style-option/opposite-style-option. The opposite-style-option for entries
   that have them describes the fvwm default behavior and can be used if you
   want to change the fvwm default behavior.

  Focus policy

   ClickToFocus instructs fvwm to give the focus to a window when it is
   clicked in. The default MouseFocus (or its alias FocusFollowsMouse) tells
   fvwm to give a window the focus as soon as the pointer enters the window,
   and take it away when the pointer leaves the window. SloppyFocus is
   similar, but doesn't give up the focus if the pointer leaves the window to
   pass over the root window or a ClickToFocus window (unless you click on
   it, that is), which makes it possible to move the mouse out of the way
   without losing focus. A window with the style NeverFocus never receives
   the focus. This is useful for modules like FvwmButtons. for example. Note:
   Once any of the "FP..." styles has been used, the defaults that come with
   the basic focus policies are not restored when the latter are used again.
   For example, once !FPGrabFocus has been used, using ClickToFocus does not
   restore FPGrabFocus.

   The focus model can be augmented with several additional options. In
   fvwm-2.5.3 and later, there are a large number of advanced options
   beginning with "FP" or "!FP". These options shall replace the older
   options one day and are described first. Using any of these new options
   may limit compatibility with older releases. In general, options beginning
   with "FP" turn a feature on, while those beginning with "!FP" turn it off.

  Focusing the window

   With FPEnterToFocus, when the pointer enters a window it receives focus.

   With FPLeaveToUnfocus a window loses focus when the pointer leaves it.

   With FPClickToFocus, FPClickDecorToFocus or FPClickIconToFocus, a window
   receives focus when the inside of the window or the decorations or its
   icon is clicked.

   The FPFocusByProgram style allows windows to take the focus themselves.

   The !FPFocusByFunction style forbids that a window receives the focus via
   the Focus and FlipFocus commands.

   The FPFocusByFunctionWarpPointer style controls if the pointer is warped
   to a selected window when the Focus command is used.

   FPLenient allows focus on windows that do not want it, like FvwmPager or
   xclock.

   The FPFocusClickButtons style takes a list of mouse buttons that can be
   clicked to focus or raise a window when the appropriate style is used. The
   default is to use the first three buttons ("123").

   The FPFocusClickModifiers style takes a list of modifier keys just like
   the Key command. The exact combination of modifier keys must be pressed
   for the click to focus or raise a window to work. The default is to use no
   modifiers ("N").

   With the FPPassFocusClick style, the click that was used to focus a window
   is passed to the application.

   With the FPAllowFocusClickFunction style, the click that was used to focus
   a window can also trigger a normal action that was bound to the window
   with the Mouse command).

   If the FPIgnoreFocusClickMotion style is used, clicking in a window and
   then dragging the pointer with the button held down does not count as the
   click to focus the window. Instead, the application processes these events
   normally. This is useful to select text in a terminal window with the
   mouse without raising the window. However, mouse bindings on the client
   window are not guaranteed to work anymore (see Mouse command). This style
   forces the initial click to be passed to the application. The distance
   that the pointer must be moved to trigger this is controlled by the
   MoveThreshold command.

   The FPSortWindowlistByFocus and !FPSortWindowlistByFocus styles control
   whether the internal window list is sorted in the order the windows were
   focused or in the order they were created. The latter is the default for
   ClickToFocus and SloppyFocus.

   Clicking the window to raise

   The styles FPClickRaisesFocused, FPClickDecorRaisesFocused and
   FPClickIconRaisesFocused allow to raise the window when the interior or
   the decorations or the icon of the window is clicked while the window is
   already focused.

   The styles FPClickRaisesUnfocused, FPClickDecorRaisesUnfocused and
   FPClickIconRaisesUnfocused allow to raise the window when the interior or
   the decorations or the icon of the window is clicked while the window is
   not yet focused.

   With the FPPassRaiseClick style, the click that was used to raise the
   window is passed to the application.

   With the FPAllowRaiseClickFunction style, the click that was used to raise
   the window can also trigger a normal action that was bound to the window
   with the Mouse command.

   If the FPIgnoreRaiseClickMotion style is used, clicking in a window and
   then dragging the pointer with the button held down does not count as the
   click to raise the window. Instead, the application processes these events
   normally. This is useful to select text in a terminal window with the
   mouse without raising the window. However, mouse bindings on the client
   window are not guaranteed to work anymore (see Mouse command. Note that
   this style forces that the initial click is passed to the application. The
   distance that the pointer must be moved to trigger this is controlled by
   the MoveThreshold command.

   Grabbing the focus when a new window is created

   New normal or transient windows with the FPGrabFocus or
   FPGrabFocusTransient style automatically receive the focus when they are
   created. FPGrabFocus is the default for windows with the ClickToFocus
   style. Note that even if these styles are disabled, the application may
   take the focus itself. Fvwm can not prevent this.

   The OverrideGrabFocus style instructs fvwm to never take away the focus
   from such a window via the GrabFocus or GrabFocusTransient styles. This
   can be useful if you like to have transient windows receive the focus
   immediately, for example in a web browser, but not while you are working
   in a terminal window or a text processor.

   The above three styles are accompanied by FPReleaseFocus,
   FPReleaseFocusTransient and FPOverrideReleaseFocus. These control if the
   focus is returned to another window when the window is closed. Otherwise
   no window or the window under the pointer receives the focus.

   ClickToFocusPassesClickOff and ClickToFocusPassesClick controls whether a
   mouse click to focus a window is sent to the application or not.
   Similarly, ClickToFocusRaisesOff/MouseFocusClickRaisesOff and
   ClickToFocusRaises/MouseFocusClickRaises control if the window is raised
   (but depending on the focus model).

   Note: in fvwm versions prior to 2.5.3, the "Click..." options applied only
   to windows with ClickToFocus while the "Mouse..." options applied to
   windows with a different focus policy. This is no longer the case.

   The old GrabFocus style is equivalent to using FPGrabFocus +
   FPReleaseFocus.

   The old GrabFocusTransient style is equivalent to using
   FPGrabFocusTransient + FPReleaseFocusTransient.

   Lenience is equivalent to the new style FPLenient.

  Window title

   The Title and !Title options determine if the window has a title-bar or
   not. By default all windows have a title-bar. NoTitle is equivalent to
   !Title but is deprecated.

   Windows with the TitleAtBottom, TitleAtLeft or TitleAtRight style have a
   title-bar below, to the left or to the right of the window instead of
   above as usual. The TitleAtTop style restores the default placement. Even
   if the window has the !Title style set, this affects the WindowShade
   command. Please check the WindowShade command for interactions between
   that command and these styles. Titles on the left or right side of the
   windows are augmented by the following styles:

   Normally, the text in titles on the left side of a window is rotated
   counterclockwise by 90 degrees from the normal upright position and 90
   degrees clockwise for titles on the right side. It can also be rotated in
   the opposite directions with LeftTitleRotatedCW if TitleAtLeft is used,
   and with RightTitleRotatedCCW if TitleAtRight is used. The defaults can be
   restored with LeftTitleRotatedCCW and RightTitleRotatedCW. A normal
   horizontal text may be rotated as well with TopTitleRotated if TitleAtTop
   is used, and with BottomTitleRotated if TitleAtBottom is used. The
   defaults can be restored with TopTitleNotRotated and
   BottomTitleNotRotated.

   By default the title bar decoration defined using the TitleStyle command
   is rotated following the title text rotation (see the previous paragraph).
   This can be disabled by using the !UseTitleDecorRotation style.
   UseTitleDecorRotation reverts back to the default.

   With the StippledTitle style, titles are drawn with the same effect that
   is usually reserved for windows with the Sticky, StickyAcrossPages or
   StickyAcrossDesks style. !StippledTitle reverts back to normal titles.
   StippledTitleOff is equivalent to !StippledTitle but is deprecated.

   Color takes two arguments. The first is the window-label text color and
   the second is the window decorations normal background color. The two
   colors are separated with a slash. If the use of a slash causes problems
   then the separate ForeColor and BackColor options can be used.

   Colorset takes the colorset number as its sole argument and overrides the
   colors set by Color. Instead, the corresponding colors from the given
   colorset are used. Note that all other features of a colorset are not
   used. Use the Colorset decoration style in the TitleStyle and ButtonStyle
   command for that. To stop using the colorset, the colorset number is
   omitted.

   The HilightFore, HilightBack and HilightColorset style options work
   exactly like ForeColor, BackColor and Colorset but are used only if the
   window has the focus. These styles replace the old commands HilightColor
   and HilightColorset.

   BorderColorset takes the colorset number as its sole argument and
   overrides the colors set by Color or Colorset. for the window border. To
   stop using a colorset, the argument is omitted.

   The HilightBorderColorset style option works similarly to BorderColorset
   but is used when the window has the focus.

   !IconTitle disables displaying icon labels while the opposite style
   IconTitle enables icon labels (default behaviour). NoIconTitle is
   equivalent to !IconTitle but is deprecated.

   IconTitleColorset takes the colorset number as its sole argument and
   overrides the colors set by Color or Colorset. To stop using this
   colorset, the argument is omitted.

   HilightIconTitleColorset takes the colorset number as its sole argument
   and overrides the colors set by HilightColor or HilightColorset. To stop
   using this colorset, the argument is omitted.

   IconBackgroundColorset takes the colorset number as its sole argument and
   uses it to set a background for the icon picture. By default the icon
   picture is not drawn onto a background image. To restore the default, the
   argument is omitted.

   IconTitleRelief takes one numeric argument that may be between -50 and +50
   pixels and defines the thickness of the 3D relief drawn around the icon
   title. With negative values the icon title gets a pressed in look. The
   default is 2 and it is restored if the argument is omitted.

   IconBackgroundRelief takes one numeric argument that may be between -50
   and +50 pixels and defines the thickness of the 3D relief drawn around the
   icon picture background (if any). With negative values the icon background
   gets a pressed in look. The default is 2 and it is restored if the
   argument is omitted.

   IconBackgroundPadding takes one numeric argument that may be between 0 and
   50 pixels and defines the amount of free space between the relief of the
   icon background picture (if any) and the icon picture. The default is 2
   and it is restored if the argument is omitted.

   The Font and IconFont options take the name of a font as their sole
   argument. This font is used in the window or icon title. By default the
   font given in the DefaultFont command is used. To revert back to the
   default, use the style without the name argument. These styles replace the
   older WindowFont and IconFont commands.

   The IndexedWindowName style causes fvwm to use window titles in the form

 name (i)

   where name is the exact window name and i is an integer which represents
   the i th window with name as window name. ExactWindowName restores the
   default which is to use the exact window name. IndexedIconName and
   ExactIconName work the same as IndexedWindowName and ExactWindowName
   styles but for the icon titles.

  Title buttons

   Button and !Button take a numeric argument which is the number of the
   title-bar button which is to be shown or omitted. NoButton is equivalent
   to !Button but is deprecated.

   MwmButtons makes the Maximize button look pressed-in when the window is
   maximized. See the MwmDecorMax flag in ButtonStyle for more information.
   To switch this style off again, use the FvwmButtons style.

  Borders

   !Borders suppresses the window border (but not the title) completely. The
   Borders style enables them again. Without borders, all other styles
   affecting window borders are meaningless.

   MwmBorder makes the 3D bevel more closely match Mwm's. FvwmBorder turns
   off the previous option.

   With the !Handles style, the window does not get the handles in the window
   corners that are commonly used to resize it. With !Handles, the width from
   the BorderWidth style is used. By default, or if Handles is specified, the
   width from the HandleWidth style is used. NoHandles is equivalent to
   !Handles but is deprecated.

   HandleWidth takes a numeric argument which is the width of the border to
   place the window if it does have resize-handles. Using HandleWidth without
   an argument restores the default.

   BorderWidth takes a numeric argument which is the width of the border to
   place the window if it does not have resize-handles. It is used only if
   the !Handles style is specified too. Using BorderWidth without an argument
   restores the default.

   DepressableBorder makes the border parts of the window decoration look
   sunken in when a button is pressed over them. This can be disabled again
   with the FirmBorder style.

  Icons, shading, maximizing, movement, resizing

   Icon takes an (optional) unquoted string argument which is the icon bitmap
   or pixmap to use. Icons specified this way override pixmap icons, but not
   icon windows or the ewmh icon, provided by the client in the application
   (with the WM_HINTS property or with the ewmh _NET_WM_ICON property). The
   IconOverride style changes the behavior to override any client-provided
   icons; the NoIconOverride style changes the behavior to not override any
   client-provided icons; the default overriding behavior can be activated
   with the NoActiveIconOverride style. With this style, fvwm uses
   application provided icons if the icon is changed but uses the icon
   provided in the configuration file until then.

   There is one exception to these rules, namely

 Style * Icon unknown.xpm

   doesn't force the unknown.xpm icon on every window, it just sets the
   default icon like the DefaultIcon command. If you really want all windows
   to have the same icon, you can use

 Style ** Icon unknown.xpm

   If the NoIcon attribute is set then the specified window simply disappears
   when it is iconified. The window can be recovered through the window-list.
   If Icon is set without an argument then the NoIcon attribute is cleared
   but no icon is specified. An example which allows only the FvwmPager
   module icon to exist:

 Style * NoIcon
 Style FvwmPager Icon

   IconBox takes no argument, four numeric arguments (plus optionally a
   screen specification), an X11 geometry string or the string "none":

 IconBox [screen scr-spec] l t r b

   or

 IconBox geometry

   Where l is the left coordinate, t is the top, r is right and b is bottom.
   Negative coordinates indicate distance from the right or bottom of the
   screen. If the first argument is the word screen, the scr-spec argument
   specifies the Xinerama screen on which the IconBox is defined. It can be
   the usual screen Xinerama specification, 'p', ´c', 'g', a screen number or
   the additional 'w' for the screen where the window center is located. This
   is only useful with multiple Xinerama screens. The "l t r b" specification
   is more flexible than an X11 geometry. For example:

 IconBox -80 240 -1 -1

   defines a box that is 80 pixels wide from the right edge, 240 pixels down
   from the top, and continues to the bottom of the screen.

   Perhaps it is easier to use is an X11 geometry string though:

 IconBox 1000x70-1-1

   places an 1000 by 70 pixel icon box on the bottom of the screen starting
   in the lower right hand corner of the screen. One way to figure out a
   geometry like this is to use a window that resizes in pixel increments,
   for example, xv. Then resize and place the xv window where you want the
   iconbox. Then use FvwmIdent to read the windows geometry. The icon box is
   a region of the screen where fvwm attempts to put icons for any matching
   window, as long as they do not overlap other icons. Multiple icon boxes
   can be defined as overflow areas. When the first icon box is full, the
   second one is filled. All the icon boxes for one style must be defined in
   one Style command. For example:

 Style * IconBox -80 240 -1 -1, \
         IconBox 1000x70-1-1

   A Style command with the IconBox option replaces any icon box defined
   previously by another Style command for the same style. Thats why the
   backslash in the previous example is required.

   Note: The geometry for the icon box command takes the additional screen
   specifier "@w" in case a Xinerama setup is used. This designates the
   screen where the window center is located. The additional screen specifier
   is not allowed anywhere else.

   If you never define an icon box, or you fill all the icon boxes, fvwm has
   a default icon box that covers the screen, it fills top to bottom, then
   left to right, and has an 80x80 pixel grid. To disable all but the default
   icon box you can use IconBox without arguments in a separate Style
   command. To disable all icon boxes including the default icon box, the
   argument "none" can be specified.

   Hint: You can auto arrange your icons in the icon box with a simple fvwm
   function. Put the "DeiconifyAndRearrange" function below in your
   configuration file:

 AddToFunc DeiconifyAndRearrange
  + C Iconify off
  + C All (CurrentPage, Iconic) PlaceAgain Icon

   And then replace all places where you call the Iconify command to
   de-iconify an icon with a call to the new function. For example replace

 AddToFunc IconFunc
  + C Iconify off
  + M Raise
  + M Move
  + D Iconify off

 Mouse 1 I A Iconify off

   with

 AddToFunc IconFunc
  + C DeiconifyAndRearrange
  + M Raise
  + M Move
  + D DeiconifyAndRearrange

 Mouse 1 I A DeiconifyAndRearrange

   IconGrid takes 2 numeric arguments greater than zero.

 IconGrid x y

   Icons are placed in an icon box by stepping through the icon box using the
   x and y values for the icon grid, looking for a free space. The default
   grid is 3 by 3 pixels which gives a tightly packed appearance. To get a
   more regular appearance use a grid larger than your largest icon. Use the
   IconSize definition to clip an icon to a maximum size. An IconGrid
   definition must follow the IconBox definition that it applies to:

 Style * IconBox -80x240-1-1, IconGrid 90 90

   IconFill takes 2 arguments.

 IconFill Bottom Right

   Icons are placed in an icon box by stepping through the icon box using
   these arguments to control the direction the box is filled in. By default
   the direction is left to right, then top to bottom. This would be
   expressed as:

 IconFill left top

   To fill an icon box in columns instead of rows, specify the vertical
   direction (top or bottom) first. The directions can be abbreviated or
   spelled out as follows: "t", "top", "b", "bot", "bottom", "l", "lft",
   "left", "r", "rgt", "right". An IconFill definition must follow the
   IconBox definition that it applies to:

 Style * IconBox -80x240-1-1, IconFill b r

   IconSize sets limits on the size of an icon image. Both user-provided and
   application-provided icon images are affected.

 IconSize [ width height [ maxwidth maxheight ] ]

   All arguments are measured in pixels. When all four arguments are passed
   to IconSize, width and height represent the minimum size of an icon, and
   maxwidth and maxheight represent the maximum size of an icon. Icon images
   that are smaller than the minimum size are padded. Icon images that are
   bigger than the maximum size are clipped.

   If only two arguments are passed to IconSize, width and height represent
   the absolute size of an icon. Icons covered by this style are padded or
   clipped to achieve the given size.

   If no arguments are specified, the default values are used for each
   dimension. This effectively places no limits on the size of an icon.

   The value of "-1" can be used in place of any of the arguments to specify
   the default value for that dimension.

   Note that application-provided icon windows are not affected.

   MiniIcon specifies a pixmap to use as the miniature icon for the window.
   This miniature icon can be drawn in a title-bar button (see ButtonStyle),
   and can be used by various fvwm modules (FvwmWinList, FvwmIconMan and
   FvwmTaskBar). It takes the name of a pixmap as an argument.

   WindowShadeShrinks and WindowShadeScrolls control if the contents of a
   window that is being shaded with the WindowShade command are scrolled
   (default) or if they stay in place. The shrinking mode is a bit faster

   The WindowShadeSteps option selects the number of steps for animation when
   shading a window with WindowShade. It takes one number as its argument. If
   the number has a trailing 'p' it sets the number of pixels to use as the
   step size instead of a fixed number of steps. 0 disables the animation.
   This happens too if the argument is omitted or invalid.

   The WindowShade command has two modes of operation: busy and lazy shading.
   Busy shading can be 50% slower than lazy shading, but the latter can look
   strange under some conditions, for example, if the window borders, buttons
   or the title are filled with a tiled pixmap. Also, the window handles are
   not drawn in lazy mode and the border relief may only be drawn partially
   right before the window reaches the shaded state or tight after leaves the
   unshaded state. By default, fvwm uses lazy mode if there are no bad visual
   effects (not counting the window handles) and busy mode otherwise. Use the
   WindowShadeAlwaysLazy or WindowShadeBusy to force using the lazy or busy
   mode. The default setting is restored with WindowShadeLazy.

   ResizeOpaque instructs fvwm to resize the corresponding windows with their
   contents visible instead of using an outline. Since this causes the
   application to redraw frequently it can be quite slow and make the window
   flicker excessively, depending on the amount of graphics the application
   redraws. The ResizeOutline style (default) negates the ResizeOpaque style.
   Many applications do not like their windows being resized opaque, e.g.
   XEmacs, Netscape or terminals with a pixmap background. If you do not like
   the result, do not use the ResizeOpaque style for these windows. To exempt
   certain windows from opaque resizing you could use these lines in your
   configuration file:

 Style * ResizeOpaque
 Style rxvt ResizeOutline
 Style emacs ResizeOutline

   Sticky makes the window sticky, i.e. it is always visible on each page and
   each desk. The opposite style, Slippery reverts back to the default.

   StickyIcon makes the window sticky when it's iconified. It de-iconifies on
   top the active desktop. SlipperyIcon reverts back to the default.

   StickyAcrossPages and StickyAcrossPagesIcon work like Sticky and
   StickyIcon, but stick the window only across pages, not desks while
   StickyAcrossDesks and StickyAcrossDesksIcon works the other way round.

   Windows that have been marked as Sticky or StickyAcrossDesks or
   StickyAcrossPages will have stipples drawn on the titlebar. This can be
   negated with the !StickyStippledTitle style. The style StickyStippledTitle
   puts back the stipples where that window has also been marked as Sticky.
   Note that this is the default style for Sticky windows. Sticky icons will
   have stipples drawn on the icon title. This can be disabled in the same
   way with the !StickyStippledIconTitle style.

   Windows with the StartIconic style are shown as icons initially. Note that
   some applications counteract that by deiconifying themselves. The default
   is to not iconify windows and can be set with the StartNormal style.

   StickyIcon makes the window sticky when it's iconified. It de-iconifies on
   top the active desktop. SlipperyIcon reverts back to the default.

   StickyIconPage works like StickyIcon, but sticks the icon only across
   pages, not desks while StickyIconDesk works the other way round.

   StippledIconTitle works like StippledTitle in that it draws stipples on
   the titles of icons but doesn't make the icon sticky.

   IgnoreRestack makes fvwm ignore attempts of clients to raise or lower
   their own windows. By default, the opposite style, AllowRestack is active.

   FixedPosition and FixedUSPosition make fvwm ignore attempts of the user to
   move the window. It is still possible to move the window by resizing it.
   To allow the user to move windows, use the VariablePosition or
   VariableUSPosition style.

   FixedSize and FixedUSSize make fvwm ignore attempts of the user to resize
   the window. To allow the user to resize windows, use the VariableSize or
   VariableUSSize style.

   FixedPPosition and FixedPSize make fvwm ignore attempts of the program to
   move or resize its windows. To allow this kind of actions, use the
   VariablePPosition or VariablePSize style. These styles may sometimes
   affect the initial placement and dimensions of new windows (depending on
   the application). If windows are created at strange places, try either the
   VariablePPosition or NoPPosition styles. The FixedPSize style may screw up
   window dimensions for some applications. Do Not use this style in this
   case.

   MoveByProgramMethod affects how fvwm reacts to requests by the application
   to move its windows. By default, fvwm tries to detect which method to use,
   but it sometimes detects the wrong method. You may come across a window
   that travels across the screen by a few pixels when the application
   resizes it, moves to a screen border with the frame decorations off
   screen, that remembers its position for the next time it starts but
   appears in a slighly shifted position, or that attepmts to become full
   screen but has the. Try out both options, UseGravity and IgnoreGravity on
   the window (and that window only) and see if that helps. By default, fvwm
   uses the AutoDetect method. Once the method was detected, it is never
   changed again. As long as fvwm can not detect the proper method, it uses
   IgnoreGravity. To force fvwm to retry the detection, use one of the other
   two options first and then use AutoDetect again.

   Note: This option was introduced to alleviate a problem with the ICCCM
   specification. The ICCCM clearly states that the UseGravity option should
   be used, but traditionally applications ignored this rule.

   Closable enables the functions Close, Delete and Destroy to be performed
   on the windows. This is on by default. The opposite, !Closable, inhibits
   the window to be closed.

   Iconifiable enables the function Iconify to be performed on the windows.
   This is on by default. The opposite, !Iconifiable, inhibits the window
   from being iconified.

   Maximizable enables the function Maximize to be performed on the windows.
   This is on by default. The opposite, !Maximizable, inhibits the window
   from being maximized.

   AllowMaximizeFixedSize enables the function Maximize to be performed on
   windows that are not resizable, unless maximization has been disabled
   either using the style !Maximizable or through WM hints. This is on by
   default. The opposite, !AllowMaximizeFixedSize, inhibits all windows that
   are not resizable from being maximized.

   ResizeHintOverride instructs fvwm to ignore the program supplied minimum
   and maximum size as well as the resize step size (the character size in
   many applications). This can be handy for broken applications that refuse
   to be resized. Do not use it if you do not need it. The default (opposite)
   style is NoResizeOverride.

   MinWindowSize [ width [ p ] height [ p ] ] Tells fvwm the minimum width
   and height of a window. The values are the percentage of the total screen
   area. If the letter 'p' is appended to either of the values, the numbers
   are interpreted as pixels. This command is useful for certain versions of
   xemacs which freak out if their windows become too small. If you omit he
   parameters or their values are invalid, both limits are set to 0 pixels
   (which is the default value).

   MaxWindowSize [ width [ p ] height [ p ] ] Tells fvwm the maximum width
   and height of a window. The values are the percentage of the total screen
   area. If the letter 'p' is appended to either of the values, the numbers
   are interpreted as pixels. This command is useful to force large
   application windows to be fully visible. Neither height nor width may be
   less than 100 pixels. If you omit the parameters or their values are
   invalid, both limits are set to 32767 pixels (which is the default).

   With IconifyWindowGroups all windows in the same window group are
   iconified and deiconified at once when any window in the group is
   (de)iconified. The default is IconifyWindowGroupsOff, which disables this
   behavior. Although a number of applications use the window group hint, it
   is rarely used in a proper way, so it is probably best to use
   IconifyWindowGroups only for selected applications.

   The option SnapAttraction affects interactive window movement: If during
   an interactive move the window or icon comes within proximity pixels of
   another the window or icon, it is moved to make the borders adjoin. The
   default of 0 means that no snapping happens. Calling this command without
   arguments turns off snap attraction and restores the default behavior.
   Please refer also to the SnapGrid command.

   The second argument determined is optional and may be set to one of the
   five following values: With All both icons and windows snap to other
   windows and other icons. SameType lets windows snap only to windows, and
   icons snap only to icons. With Windows windows snap only to other windows.
   Similarly with Icons icons snap only to other icons. With None no snapping
   takes place. This option can be useful in conjunction with the following
   argument if you only want to snap against the screen edges. The default
   behavior is All.

   The third and last optional argument may be set to one of the four
   following values:

     o With Screen the already snapping icons or windows, which is controlled
       by the second argument, will snap now also to the screen edges.

     o ScreenWindows snaps only windows to the screen edges.

     o ScreenIcons snaps only icons to the screen edges.

     o ScreenAll snaps windows and icons to the screen edges.

   The option SnapGrid defines an invisible grid on the screen. During an
   interactive move a window or icon is positioned such that its location
   (top left corner) is coincident with the nearest grid point. The default
   x-grid-size and y-grid-size setting are both 1, which is effectively no
   grid all.

   An interactive move with both SnapGrid and SnapAttraction results in the
   window being moved to be adjacent to the nearest window border (if within
   snap proximity) or grid position. The window moves the shortest distance
   possible to satisfy both SnapGrid and SnapAttraction. Note that the x and
   y coordinates are not coupled. For example, a window may snap to another
   window on the x axis while snapping to a grid point on the y axis. Using
   this style without arguments reinstates the default settings.

   The styles EdgeMoveDelay and EdgeResizeDelay tells how hard it should be
   to change the desktop viewport by moving or resizing a window over the
   edge of the screen. The parameter tells how many milliseconds the pointer
   must spend on the screen edge before fvwm moves the viewport. The command
   EdgeScroll determines how far the viewport is scrolled. If -1 is given as
   the delay, page flipping is disabled completely. The defaults are no delay
   for moving (0) and no flipping for resizing (-1). Using these styles
   without any argument restores the default settings. Note that, with

 EdgeScroll 0 0

   it is still possible to move or resize windows across the edge of the
   current screen. See also EdgeThickness.

   The option EdgeMoveResistance makes it easier to place a window directly
   adjacent to the screen's or xinerama screen's border. It takes one or two
   parameters. The first parameter tells how many pixels over the edge of the
   screen a window's edge must move before it actually moves partially off
   the screen. The optional second parameter does the same as the first, but
   for individual Xinerama screens. If omitted, the value of the first
   parameter is assumed for this type of movement. Set the second parameter
   to 0 to zero to ignore individual xinerama screen edges. Note that the
   center of the window being moved determines the xinerama screen on which
   the window should be kept. Both values are 0 by default. To restore the
   defaults, the option EdgeMoveResistance can be used without any
   parameters.

   The option InitialMapCommand allows for any valid fvwm command or function
   to run when the window is initially mapped by fvwm. Example:

 Style MyWindow StartsOnPage 0 0, InitialMapCommand Iconify

   This would hence place the window called MyWindow on page 0 0 for the
   current desk, and immediately run the Iconify command on that window.

   Note that should InitialMapCommand be used as a global option for all
   windows, but there is a need that some windows should not have this
   command applied, then an action of Nop can be used on those windows, as in
   the following example:

 Style * InitialMapCommand Iconify
 Style XTeddy InitialMapCommand Nop

  Window Manager placement

   Applications can place windows at a particular spot on the screen either
   by window manager hints or a geometry specification. When they do neither,
   then the window manager steps in to find a place for the window. Fvwm
   knows several ways to deal with this situation. The default is
   TileCascadePlacement.

   PositionPlacement [Center|UnderMouse|move-arguments] When used without an
   argument, new windows are placed in the top left corner of the display.
   With the argument Center, all new window appear at the center of the
   screen, and with UnderMouse, windows are centered under the mouse pointer
   where possible. If the window is unable to fit on the screen because the
   pointer is at the edge of the screen, then the window is forced on-screen
   using this option. If any other move-arguments are given, they are
   interpreted exactly as the Move command does (with the exception that
   references to the current window position do not work as the window has
   not been placed yet).

   CascadePlacement automatically place new windows in a cascading fashion.

   TileCascadePlacement automatically places new windows in a smart location
   - a location in which they do not overlap any other windows on the screen.
   If no such position can be found CascadePlacement is used as a fall-back
   method.

   TileManualPlacement This is the same as TileCascadePlacement, but uses
   ManualPlacement as the fall-back method.

   MinOverlapPlacement automatically places new windows in a location in
   which the overlapping area in pixels of other windows is minimized. By
   default this placement policy tries to avoid overlapping icons and windows
   on higher layers. This can be configured with the
   MinOverlapPlacementPenalties style.

   MinOverlapPercentPlacement is similar to MinOverlapPlacement but tries to
   minimize the overlapped percentages of other windows instead of the
   overlapped area in pixels. This placement policy tries to avoid covering
   other windows completely and tries even harder not to cover small windows.
   This can be configured with the MinOverlapPlacementPenalties and
   MinOverlapPercentPlacementPenalties styles.

   MinOverlapPlacementPenalties takes at most 6 positive or null decimal
   arguments:

 normal ontop icon sticky below strut

   if trailing arguments are missing the default is used which is:

 1 5 10 1 0.05 50

   To reset this style to the default values, prefix it with a '!'. This
   style configures the MinOverlapPlacement and MinOverlapPercentPlacement
   placement policy. The normal factor affects normal windows, the ontop
   factor affects windows with a greater layer than the window being placed,
   the icon factor affects icons, the sticky factor affects sticky windows,
   the below factor affects windows with a smaller layer than the window
   being placed, the strut factor affects the complement of the EWMH working
   area if the window being placed has the EWMHPlacementUseWorkingArea style
   and windows with an EWMH strut hint (i.e., a "please do not cover me"
   hint) if the window being placed has the
   EWMHPlacementUseDynamicWorkingArea style. These factors represent the
   amount of area that these types of windows (or area) are counted as, when
   a new window is placed. For example, by default the area of ontop windows
   is counted 5 times as much as normal windows. So MinOverlapPlacement and
   MinOverlapPercentPlacement covers 5 times as much area of another window
   before it will cover an ontop window. To treat ontop windows the same as
   other windows, set this to 1. To really, really avoid putting windows
   under ontop windows, set this to a high value, say 1000. This style
   affects the window already mapped and not the window which is currently
   placed. There is one exception to this rule: in the case of the window
   being placed has the EWMHPlacementUseWorkingArea style the strut factor
   affects the placed window.

   MinOverlapPercentPlacementPenalties takes at most 4 positive or null
   integer arguments:

 cover_100 cover_95 cover_85 cover_75

   if trailing arguments are missing the defaults are used which are:

 12 6 4 1

   To reset this style to the default values, prefix it with a '!'. This
   style affects the MinOverlapPercentPlacement placement policy and is
   similar to the MinOverlapPlacementPenalties style. The cover_xx factor is
   used when the window being placed covers at least xx percent of the
   window. This factor is added to the factor determined by the
   MinOverlapPlacementPenalties style.

   ManualPlacement (aka active placement). The user is required to place
   every new window manually. The window only shows as a rubber band until a
   place is selected manually. The window is placed when a mouse button or
   any key except Escape is pressed. Escape aborts manual placement which
   places the window in the top left corner of the screen. If mouse button 2
   is pressed during the initial placement of a window (respectively Shift
   and mouse button 1 in case Mwm emulation has been enabled with the Emulate
   command), the user is asked to resize the window too.

   It is possible to define buttons usable to place windows with the Move
   command and the special context 'P' for placement (see Move command).
   However, you can't redefine the way to also resize the window other than
   the way it is affected by the Emulate command. The button used for placing
   the window can be checked with the PlacedByButton condition (see Current
   command).

   Example:

 Style * ManualPlacement

 *FvwmEvent: PassID
 *FvwmEvent: add_window GrowDownFunc
 AddToFunc StartFunction
 + I FvwmEvent

 AddToFunc GrowDownFunc
 + I windowid $0 (PlacedByButton 3) \
   Resize bottomright keep -0p

   Now, whenever a window is created and the user presses button 3 to finish
   initial placement, the window is automatically enlarged until it hits the
   bottom screen border.

   Old placement styles DumbPlacement / SmartPlacement / SmartPlacementOff,
   CleverPlacement / CleverPlacementOff, ActivePlacement / RandomPlacement,
   ActivePlacementsHonorsStartsOnPage /
   ActivePlacementsHonorsStartsOnPageOff, GlobalOpts
   SmartPlacementIsReallySmart / GlobalOpts SmartPlacementIsNormal are still
   supported but will be removed in the future. The old and new styles can be
   translated according to the following table:

 GlobalOpts SmartPlacementIsReallySmart
 Style * SmartPlacement
 -->
 Style * SmartPlacement, CleverPlacement

 GlobalOpts SmartPlacementIsNormal
 Style * SmartPlacement
   -->
 Style * SmartPlacement, CleverPlacementOff

 Style * DumbPlacement, RandomPlacement
   -->
 Style * CascadePlacement

 Style * DumbPlacement, ActivePlacement
   -->
 Style * ManualPlacement

 Style * SmartPlacement, \
 RandomPlacement, CleverPlacementOff
   -->
 Style * TileCascadePlacement

 Style * SmartPlacement, \
 ActivePlacement, CleverPlacementOff
   -->
 Style * TileManualPlacement

 Style * SmartPlacement, CleverPlacement
   -->
 Style * MinOverlapPlacement

 Style * SmartPlacement, \
 ActivePlacement, CleverPlacement
   -->
 Style * MinOverlapPercentPlacement

 Style * ActivePlacementsHonorsStartsOnPage
   -->
 Style * ManualPlacementsHonorsStartsOnPage

 Style * ActivePlacementsHonorsStartsOnPageOff
   -->
 Style * ManualPlacementsHonorsStartsOnPageOff

  Placement policy options and window stacking

   NoUsePPosition instructs fvwm to ignore the program specified position
   (PPosition hint) when adding new windows. Using PPosition is required for
   some applications, but if you do not have one of those it's a real
   headache. Many programs set PPosition to something obnoxious like 0,0
   (upper left corner). Note: !UsePPosition is equivalent to the deprecated
   option NoPPosition

   NoUseUSPosition works like !UsePPosition but applies suppresses using the
   user specified position indicated by the program (USPosition hint). It is
   generally a bad thing to override the user's choice, but some applications
   misuse the USPosition hint to force their windows to a certain spot on the
   screen without the user's consent. Note: !UseUSPosition is equivalent to
   the deprecated option !USPosition

   NoUseTransientPPosition and UseTransientPPosition work like !UsePPosition
   and UsePPosition but apply only to transient windows. Note:
   !UseTransientPPosition is equivalent to the deprecated option
   !TransientPPosition

   NoUseIconPosition instructs fvwm to ignore the program specified icon
   position (IconPosition hint) when iconifying the window. Note:
   !UseIconPosition is equivalent to the deprecated option !IconPosition

   StartsOnDesk takes a numeric argument which is the desktop number on which
   the window should be initially placed. Note that standard Xt programs can
   also specify this via a resource (e.g. "-xrm '*Desk: 1'").

   StartsOnPage takes 1, 2, or 3 numeric arguments. If one or three arguments
   are given, the first (or only) argument is the desktop number. If three
   arguments are given, the 2nd and 3rd arguments identify the x,y page
   position on the virtual window. If two arguments are given, they specify
   the page position, and indicate no desk preference. If only one argument
   is given, StartsOnPage functions exactly like StartsOnDesk. For those
   standard Xt programs which understand this usage, the starting desk/page
   can also be specified via a resource (e.g., "-xrm '*page: 1 0 2'").
   StartsOnPage in conjunction with SkipMapping is a useful technique when
   you want to start an app on some other page and continue with what you
   were doing, rather than waiting for it to appear.

   StartsOnScreen takes one argument. It can be 'p' for the primary screen,
   'c' for the current screen (containing the mouse pointer), 'g' for the
   global screen or the screen number itself (counting from zero). A new
   window is placed on the specified Xinerama screen. The default is to place
   windows on the screen that contains the mouse pointer at the time the
   window is created. However, those windows which are not placed by fvwm
   (i.e., those with a USPosition hint from a user specified geometry) are
   normally placed in a position relative to the global screen. The
   StartsOnScreen style is also useful to cause these windows to be placed
   relative to a specific Xinerama screen. For example:

 Style * StartsOnScreen c

   Would cause all windows, including those with their own geometry to be
   placed relative to the current Xinerama screen rather than the global
   screen. For those standard Xt programs which understand this usage, the
   starting desk/page can also be specified via a resource (e.g., "-xrm
   '*fvwmscreen: c'"). ('fvwmscreen' was chosen because some applications
   already use ´.screen' for other purposes.)

   StartsOnPageIncludesTransients causes the StartsOnPage style to be applied
   even for transient windows. This is not usually useful, since transients
   are usually pop ups that you want to appear in your visible viewport; but
   occasionally an application uses a transient for something like a startup
   window that needs to be coerced into place.

   ManualPlacementIgnoresStartsOnPage suppresses StartsOnPage or StartsOnDesk
   placement in the event that both ManualPlacement and SkipMapping are in
   effect when a window is created. This prevents you from interactively
   placing a window and then wondering where it disappeared to, because it
   got placed on a different desk or page. ManualPlacementHonorsStartsOnPage
   allows this to happen anyway. The option has no effect if SkipMapping is
   not in effect, because fvwm switches to the proper desk/page to perform
   interactive placement. The default is ManualPlacementIgnoresStartsOnPage;
   ManualPlacementHonorsStartsOnPage matches the way the old StartsOnDesk
   style used to handle the situation.

   CaptureHonorsStartsOnPage causes the initial capture (of an already
   existing window) at startup to place the window according to the
   StartsOnPage and StartsOnScreen desk, page and Xinerama screen
   specification. CaptureIgnoresStartsOnPage causes fvwm to ignore these
   settings (including StartsOnDesk) on initial capture. The default is
   CaptureIgnoresStartsOnPage.

   RecaptureHonorsStartsOnPage causes a window to be placed according to, or
   revert to, the StartsOnPage and StartsOnScreen desk, page and Xinerama
   screen specification on Restart or Recapture. RecaptureIgnoresStartsOnPage
   causes fvwm to respect the current window position on Restart or
   Recapture. The default is RecaptureIgnoresStartsOnPage.

   Layer accepts one optional argument: a non-negative integer. This is the
   layer the window is put in. If no argument is given, any previously set
   value is deleted and the default layer is implied.

   StaysOnTop puts the window in the top layer. This layer can be changed by
   the command DefaultLayers; the default is 6.

   StaysPut puts the window in the put layer. This layer can be changed by
   the command DefaultLayers; the default is 4.

   StaysOnBottom puts the window in the bottom layer. This layer can be
   changed by the command DefaultLayers; the default is 2.

   StartsLowered instructs fvwm to put the window initially at the bottom of
   its layer rather than the default StartsRaised.

   StartShaded tells fvwm to shade the window. An optional direction argument
   may be given, which can be one of "North", "South", "West", "East",
   "NorthWest", "NorthEast", "SouthWest", "SouthEast" or if no direction is
   given, the default is to shade north.

   SkipMapping tells fvwm not to switch to the desk the window is on when it
   gets mapped initially (useful with StartsOnDesk or StartsOnPage).

   KeepWindowGroupsOnDesk makes new windows that have the window group hint
   set appear on the same desk as the other windows of the same group. Since
   this behavior may be confusing, the default setting is
   ScatterWindowGroups. The window group hint is ignored when placing windows
   in this case.

  Transient windows

   DecorateTransient causes transient windows, which are normally left
   undecorated, to be given the usual fvwm decorations (title bar, buttons,
   etc.). Note that some pop-up windows, such as the xterm menus, are not
   managed by the window manager and still do not receive decorations.
   NakedTransient (the default) causes transient windows not to be given the
   standard decorations. You can only bind keys or mouse buttons to the sides
   and the client part of an undecorated window ('S' and ´W' contexts in
   bindings, see Mouse and Key commands).

   A window with the RaiseTransient style that has transient windows raises
   all its transients when it is raised. The DontRaiseTransient style
   disables this behavior. All windows are then treated as if they had no
   transients.

   A window with the LowerTransient style that has transient windows lowers
   all its transients when it is lowered. The DontLowerTransient style
   disables this behavior. All windows are then treated as if they had no
   transients.

   The StackTransientParent style augments RaiseTransient and LowerTransient
   styles. Raising a window with StackTransientParent style transfers the
   raise action to the main window if the window being raised is a transient
   and its main window has RaiseTransient style; this effect makes raise on a
   transient act just like raise on its main - the whole group is raised.
   Similar behavior holds for lowering a whole group of transients when the
   main has LowerTransient style. DontStackTransientParent turns this
   behavior off. (Dont)StackTransientParent has no effect if RaiseTransient
   and LowerTransient are not used.

   A reasonable emulation of Motif raise/lower on transients is possible like
   this

 Style * RaiseTransient
 Style * LowerTransient
 Style * StackTransientParent

  Extended Window Manager Hints styles

   To understand the used terminology in this sub section, please read the
   Extended Window Manager Hints section.

   EWMHDonateIcon instructs fvwm to set the application ewmh icon hint with
   the icon that is used by fvwm if the application does not provide such
   hint (and if the icon used by fvwm is not an icon window).
   EWMHDonateMiniIcon does the same thing for mini icons. This allows
   compliant pager, taskbar, iconbox ...etc to display the same (mini) icons
   as fvwm. Note that on some hardware (e.g., 8-bit displays) these styles
   can slow down window mapping and that in general only one of these styles
   is needed by a compliant application. EWMHDontDonateIcon and
   EWMHDontDonateMiniIcon restore the defaults which are to not set any ewmh
   (mini) icons hints.

   By default, if an application provides an ewmh icon hint of small size
   (i.e., height and width less than or equal to 22), then fvwm uses this
   icon as its mini icon. EWMHMiniIconOverride instructs fvwm to ignore ewmh
   icons and to use the mini icon provided by the MiniIcon style.
   EWMHNoMiniIconOverride restores the default.

   EWMHUseStackingOrderHints causes fvwm to use EWMH hints and respect EWMH
   hints which change the window layer. EWMHIgnoreStackingOrderHints causes
   fvwm to ignore EWMH layer hints.

   An application can ask for some reserved space on the desktop by a hint.
   In the EWMH terminology such a hint is called a strut and it is used to
   compute the working area and may be used for window placement and in the
   maximize command. EWMHIgnoreStrutHints causes fvwm to ignore such hints,
   as EWMHUseStrutHints, causes fvwm to use it which is the default.

   EWMHIgnoreStateHints causes fvwm to ignore initial EWMH state hints when a
   new window is mapped. The default EWMHUseStateHints causes fvwm to accept
   such hints.

   EWMHIgnoreWindowType causes fvwm to ignore EWMH window type specification.
   The default !EWMHIgnoreWindowType causes fvwm to style windows of
   specified types as such.

   EWMHMaximizeIgnoreWorkingArea causes fvwm to ignore the EWMH working area
   when it executes a Maximize command. With EWMHMaximizeUseWorkingArea the
   EWMH working area is used as with EWMHMaximizeUseDynamicWorkingArea the
   EWMH dynamic working area is used (the default).

   EWMHPlacementIgnoreWorkingArea causes fvwm to ignore the EWMH working area
   when it places (or places again) a window. With
   EWMHPlacementUseWorkingArea the EWMH working area is taken in account as
   with EWMHPlacementUseDynamicWorkingArea the EWMH dynamic working area is
   taken in account (the default). Note that with the MinOverlapPlacement and
   MinOverlapPercentPlacement placement policy, the way the EWMH (dynamic)
   working area is taken in account is configurable with the
   MinOverlapPlacementPenalties style.

  Miscellaneous

   The BackingStore, BackingStoreOff and BackingStoreWindowDefault determine
   if the X server uses backing store for the window or not. BackingStore
   means that the X server tries to keep the obscured parts of a window in
   memory. This is usually slower if the client runs on the same machine as
   the X server, but can be much faster if the connection is slow (see also
   SaveUnder below). BackingStoreOff disables backing store for the window.
   By default, fvwm does not enable or disable backing store itself but
   leaves is as the window requested it. To revert back to the application's
   choice, use the BackingStoreWindowDefault style.

   Note: This style is useless if the X server does not allow backing store.

   SaveUnder enables the corresponding window attribute in the X server. For
   a window using this style, the X server tries to store the graphics below
   it in memory which is usually slower if the client runs on the same
   machine as the X server. SaveUnder may speed up fvwm if the connection to
   the X server is slow (e.g. over a modem link). To disable save under, use
   the SaveUnderOff style. This is the default. See also BackingStore above.

   Note: This style is useless if the X server does not allow save under.

   ParentalRelativity enables clients that use a background pixmap of type
   ParentRelative to achieve transparency. Fvwm modules that support
   transparent colorsets require this setting. Opacity is the default and
   should be used for all non-transparent clients for better performance.

   MwmDecor makes fvwm attempt to recognize and respect the mwm decoration
   hints that applications occasionally use. To switch this style off, use
   the NoDecorHint style.

   MwmFunctions makes fvwm attempt to recognize and respect the mwm
   prohibited operations hints that applications occasionally use.
   HintOverride makes fvwm shade out operations that mwm would prohibit, but
   it lets you perform the operation anyway. NoFuncHint allows turns off the
   mwm hints completely.

   OLDecor makes fvwm attempt to recognize and respect the olwm and olvwm
   hints that many older XView and OLIT applications use. Switch this option
   off with NoOLDecor.

   With GNOMEIgnoreHints fvwm ignores all GNOME hints for the window, even if
   GNOME compliance is compiled in. This is useful for those pesky
   applications that try to be more clever than the user and use GNOME hints
   to force the window manager to ignore the user's preferences. The
   GNOMEUseHints style switches back to the default behavior.

   UseDecor This style is deprecated and will be removed in the future. There
   are plans to replace it with a more flexible solution in fvwm-3.0.

   UseDecor accepts one argument: the name of a decor created with
   AddToDecor. If no decor name is specified, the "Default" decor is used.
   Windows do not actually contain decors, but are always assigned to one. If
   the decor is later modified with AddToDecor, the changes are visible for
   all windows which are assigned to it. The decor for a window can be
   reassigned with ChangeDecor.

   UseStyle This style is deprecated and will be removed in the future. There
   are plans to replace it with a more flexible solution in fvwm-3.0.

   UseStyle takes one arg, which is the name of another style. That way you
   can have unrelated window names easily inherit similar traits without
   retyping. For example:

   Style rxvt UseStyle XTerm

   Warning: If a style is built from one or more parent styles and the parent
   styles are changed, the derived style is not modified. To achieve this you
   have to issue the UseStyle line again.

   Unmanaged Windows with the Unmanaged style option are ignored by fvwm.
   They are not decorated, can not be moved or resized, etc. You probably
   want to use Bugopts RaiseOverUnmanaged too. This option can be turned off
   with the !Unmanaged style. However, windows that are already ignored at
   the time when the option is set must be recaptured with the Recapture
   command in order to become managed.

   State sets the initial value of one of the 32 user defined states which
   are associated with each window. The state number ranges from 0 to 31 and
   must be given as an argument. The states have no meaning in fvwm, but they
   can be checked in conditional commands like Next with the State condition
   and manipulated with the State command.

 # turn on state 11 for xterms ...
 Style xterm State 11
 # ... but not for rxvts.
 Style rxvt !State 11

   Windows with the WindowListSkip styles do not appear in the menu that is
   created with the WindowList command or the lists shown in several modules
   like FvwmIconMan or FvwmWinList. In the modules, the style can usually be
   ignored with an option. Please refer to the man page of the module in
   question for further information. To disable this feature, use the default
   style WindowListHit.

   The styles CirculateSkip and CirculateHit control whether the window is
   considered by conditional commands, for example Next, Prev or All. Windows
   with CirculateSkip, are never selected by conditional commands. However,
   the styles can be overridden explicitly in the condition with the
   CirculateHit, CirculateHitIcon or CirculateHitShaded conditions, and some
   conditional commands, e.g. Current and All, do this by default. The styles
   CirculateSkipIcon, CirculateHitIcon, CirculateSkipShaded and
   CirculateHitShaded work like CirculateSkip and CirculateHit but apply only
   to iconic or shaded windows. Note: if multiple ...Skip... options are
   combined, windows are only selected if they match none of the given
   conditions. So, with

 Style * CirculateSkipIcon, CirculateSkipShaded

   only windows that are neither iconic nor shaded are selected. Note: For
   historical reasons, the conditional commands understand the names of these
   styles as condition names. Take care not to confuse them.

  Examples

 # Change default fvwm behavior to no title-
 # bars on windows! Also define a default icon.
 Style *             !Title,                \
                     Icon unknown1.xpm,     \
                     BorderWidth 4,         \
                     HandleWidth 5

 # now, window specific changes:
 Style Fvwm*       !Handles, Sticky,        \
                   WindowListSkip,          \
                   BorderWidth 0
 Style FvwmPager   StaysOnTop, BorderWidth 0
 Style *lock       !Handles, Sticky,        \
                   StaysOnTop, WindowListSkip
 Style xbiff       Sticky, WindowListSkip
 Style FvwmButtons !Handles, Sticky,        \
                   WindowListSkip
 Style sxpm        !Handles

 # Put title-bars back on xterms only!
 Style xterm     Title, Color black/grey

 Style rxvt        Icon term.xpm
 Style xterm       Icon rterm.xpm
 Style xcalc       Icon xcalc.xpm
 Style xbiff       Icon mail1.xpm
 Style xmh         Icon mail1.xpm,         \
                     StartsOnDesk 2
 Style xman        Icon xman.xpm
 Style matlab      Icon math4.xpm,         \
                     StartsOnDesk 3
 Style xmag        Icon magnifying_glass2.xpm
 Style xgraph      Icon graphs.xpm
 Style FvwmButtons Icon toolbox.xpm
 Style Maker       StartsOnDesk 1
 Style signal      StartsOnDesk 3

 # Fire up Netscape on the second desk, in the
 # middle of my 3x3 virtual desktop, and do not
 # bother me with it...
 Style Netscape* SkipMapping,              \
                 StartsOnPage 1 1 1

   Note that all properties for a window are or'ed together. In the above
   example "FvwmPager" gets the property StaysOnTop via an exact window name
   match but also gets !Handles, Sticky and WindowListSkip by a match to
   "Fvwm*". It gets !Title by virtue of a match to "*". If conflicting styles
   are specified for a window, then the last style specified is used.

   --------------------------------------------------------------------------

   fvwm 2.6.3 (from cvs)
