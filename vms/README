--------------------------------------------------------------------------------
Fvwm2 with OpenVms, how-to
Fabien Villard (Villard_f@Decus.Fr), February 1999
--------------------------------------------------------------------------------

	Compilation
	-----------
		Copy VMS/Make_Fvwm.Mms to top of source tree.
		Edit the Make_Fvwm.Mms file and modify the first macros to suit
your environment. 
		Copy VMS/Config.h file to Config.h.
		Edit the Config.h file and modifiy what you want, according to
the comments in it. Especially, deactive all XPMlibraries uses if you don't have
them or don't need this support. 
		Then do a 
			$ Mms/Descript=Make_Fvwm.Mms/Ignore=Warning.
		This will create the fvwm executable Fvwm.Exe in [.Fvwm] and the
modules executables FvwmXxx.Exe in the directory [.Modules.Bin]. 


	Installation
	------------
		Copy the images Fvwm.Exe and FvwmXxx.Exe where appropriate.
		Extract from the end of this README and edit the Fvwm_Ope.Com
procedure, mofify the logical names to reflect your environment. The Fvwm
distribution contains a set of icons, pixmaps and miniicons in the [.icons]
directory. They can be moved to a more appropriate place. Put this file where it
goes in your environment. 
		Copy the FvwmRc.Dat file in your Sys$Login.
		In your Sys$Login, you have a VUE$PROFILE.VUE$DAT file. Save it,
for example under the name VUE$PROFILE.VUE$DAT_MOTIF. 
		Open DecWindow "Menus..." option of the Session Menu Bar.
		Create a new "Item name", say "Fvwm", with the following command :
			@<Fvwm_Ope.Com path>Fvwm_Ope.Com
		Open DecWindow "Automatic Startup..." entry of the Session Menu
Bar. Kill the "Window Manager" entry and add instead the newly created "Fvwm"
item. 
		Save the session manager options.
		Now in your Sys$Login, the modification timestamp of
VUE$PROFILE.VUE$DAT has changed. Save the new form, for example under the name
VUE$PROFILE.VUE$DAT_FVWM. 
		Close the session and reopen it. Fvwm must run.


	If it goes wrong
	----------------

		If Fvwm doesn't run, or run and die, but the XServer is still
there, no problem. Just open a new DecTerm. It will popup on top of the windows
list. Click in it, it gets the focus. Then do something like 
	Copy VUE$PROFILE.VUE$DAT_MOTIF VUE$PROFILE.VUE$DAT
		CLose the session, reopen it, Mwm wil run.
		Some informations can be found in the file Fvwm.Log in your
Sys$Login. In vms.h there are some debugguing macros that can be activated to 
trace more. Especially, the one that enable flush and/or open/close of the trace 
file. Attention it slows the fvwm start a lot.

		All that precedes can be accomplished with only TmpMbx and NetMbx 
privileges. Next, if you are unlucky, need more privileges, or less kindness :-)
		If the XServer die unexpectadly (Quotas limits, file 
protections...), you can restart it from the console, or from another machine, 
or, you can reboot your ws. That's not very fair, but... In both cases, don't 
forget to manage the copy above.


--------------------------------------------------------------------------------
Fvwm2 under OpenVms, modifications list
Fabien Villard (Villard_F@Decus.Fr), 20-JAN-1999
--------------------------------------------------------------------------------

	Fvwm configuration :
	--------------------

	The file VMS_config.h is derived from the config.h.in generated by
autoconf. It can be edited to modify the system configuration (HAVE_xxx, ...)
and the stuff you want in Fvwm (SHAPE, ...). 
	Some things are added here to help debugguing the VMS port, and others
ARE the port :-) : 

	#include "vms.h" : this gives acces to the VMS stuff for all sources of
Fvwm without modifying them. 

	#define fork vfork : in my version of DecC I haven't fork, but vfork.
See more on this later. 

	#define execvp execv : this avoid using the PATH environment variable
and with a minor modification of code, allows to use logicals to locate the
modules. 

	#define execl VMS_ExecL : the new function VMS_ExecL() gets the command
Unix'ly passed to the shell, splits it in words and rebuild an array of
arguments. Then it calls execv(), assuming it has found an image name. If
execv() call fails, VMS_ExecL() returns 0, hiding the fail. Thus the original 
code, executing in the parent context, doesn't call exit() which is fatal for 
the parent with actual version of Dec C RTL.

	#define fvwm_msg VMS_msg : there is a coredump I can't figure out
(quotas) when using the fprintf(stderr,...) function to display debug
informations. DecWindows crashes with a generic error 65535, probably meaning a
VMS IO error. I give in Vms.c another tracing function wich can be forced to
open/close the output file, or to flush outputs (it could be cool to get the
the image name of the process running to display in the log file or to have
separate logs for each modules, if someone is interested in adding it)

	#define select VMS_select_pipes : that's the big deal. The select()
function is not working as expected and we cannot give it the X file descriptor
wich under VMS is an event flag. So I rewrote the select() function,
considering the C pipes are implemented as MailBoxes under VMS. 


	New sources :
	-------------

	Vms.c/Vms.h : contains specific functions for VMS.


	Sources modifications :
	-----------------------

	[.Fvwm]Fvwm.c :
		Because DecWindow gives an event flag instead of a file
descriptor in the fd field of the Display structure, we cannot use the fcntl()
function with it. I don't know if we could get the fd, or even if there is one.
So we must comment the fcntl() call on X file descriptor. If DecWindow uses a
file descriptor (I guess no), it will remain open in the subprocesses spawned by
exec() functions family. If it doesn't use one, no consequences. 

	[.fvwm]module.c
		o When the fork/exec functions are used with Unixes, the code
between the fork() and the exec() is executed by the child process. With VMS,
it is executed by the parent process, for the child doesn't exist yet. So, we
cannot close the parent pipes that the child doesn't need. 
		o Despite the fact that there is code to verify the existence
of the image to run in a child process, the child process spawning can fail
(protections, quotas,...) more easely than under Unix. The exec() function then
returns just after the call and the original code exits. I think with VMS it
must not be considered a fatal error. 

	[.fvwm]misc.c
		Just comment out the original fvwm_msg() function to activate
the VMS_msg(). 

	[.fvwm]module.c
		The image names are traditionnaly built wit a ".exe" extension
in VMS and without extension in Unix. To limit the incompatibilities in the
Fvwm resource files, speaking of module names, I add temporarily this extension
to the file name searched, when the file type is executable. So, apart from the
actual locations of things, the syntaxe of the resource file is not changed. 

	[.modules.fvwmpager]fvwmpager.c
		o Due to the VMS_select_pipes() implementation (see the source),
some ghosts X events can be generated. Depending upon the way returns from the
function are managed, this can lead to false "missed X events". Fvwmpager.c
exits when those missed X events are to numerous. I bypass this test. 

	[.modules.fvwmwinlist]fvwmwinlist.c
		o Probably due to DecWindow events buffering, I must add an
XFlush() call to have the window really redrawn. 



	Fvwm unused sources :
	---------------------

	[.Libs]usleep.c
	[.libs]strerror.c
        [.Libs]strcasecmp.c
        [.Libs]strncasecmp.c


--------------------------------------------------------------------------------
Fvwm2 with OpenVms, DCL procedures
Fabien Villard (Villard_f@Decus.Fr), 28-JAN-1999
--------------------------------------------------------------------------------

	FVWM_OPE.COM : launch Fvwm from the DecWindow session manager.
	SHSUBPROC.COM : is a small utility to view the processes involved in
Fvwm execution. Launch it with :
		$ @SHSUBPROC DECW$SESSION

----------- FVWM_OPE.COM --------------------------------------------------
$!	Set Process/Dump
$! --- Location of the Fvwm images ---
$	Assign/NoLog Fab$Exe fvwm_bindir
$! --- Location of the pixmaps  ---
$	Assign/NoLog DARC:[VMS.Pixmaps] fvwm_pixdir
$! --- Location of the icons ---
$	Assign/NoLog DARC:[VMS.Icons] fvwm_icodir
$	Run/NoDebug Fab$Exe:fvwm.Exe
$	Exit
----------- FVWM_OPE.COM --------------------------------------------------


---------- SHSUBPROC.COM --------------------------------------------------
$	Verbose = 0
$	Say :== Write Sys$Output
$	If P1 .Eqs. ""
$	Then
$	  Say "P1 : Master Process Name"
$	  Goto EndScript
$	EndIf
$	MasterName = P1
$!
$	ProcessContext = ""
$	A = F$Context("Process", ProcessContext, "PRCNAM", MasterName, "Eql")
$	MasterPid = F$Pid(ProcessContext)
$	If MasterPid .Eqs. "" Then Goto EndScript
$	If Verbose .Eq. 1 Then Say "---------- Pid of Decw$Session process : " + MasterPid
$	NbProc == 1
$	Level == 0
$	Call DisplayProcess 'MasterPid
$	Call ListSubProc 'MasterPid
$	Say "There are ", NbProc, " processes in this job."
$EndScript:
$	Exit
$!
$ListSubProc: SubRoutine
$	Level == Level + 1
$	Owner = P1
$	If Verbose .Eq. 1 Then Say "---------- Listing subprocesses of ", Owner
$	SubContext = ""
$	A = F$Context("Process", SubContext, "OWNER", Owner, "Eql")
$NextProcess:
$	Pid = F$Pid(SubContext)
$	If Pid .Eqs. "" Then Goto NoMoreProcess
$	NbProc == NbProc + 1
$	Call DisplayProcess 'Pid
$	Call ListSubProc 'Pid
$	Goto NextProcess
$!
$NoMoreProcess:
$	Level == Level - 1
$	If Verbose Then Say "---------- End ", Owner
$EndSubroutine
$!
$DisplayProcess:SubRoutine
$	Pid = P1
$	PrcNam = F$GetJpi(Pid, "PrcNam")
$	ImagName = F$GetJpi(Pid, "ImagName")
$	ModuleName = F$Parse(ImagName,"","","NAME","SYNTAX_ONLY")
$	FormPrcNam = F$Fao("!#AS!AS", Level*2, "", PrcNam)
$	Say F$Fao("!22AS  !8AS  !12AS", FormPrcNam, Pid, ModuleName)
$EndSubroutine
---------- SHSUBPROC.COM --------------------------------------------------
