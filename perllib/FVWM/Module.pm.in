# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA

package FVWM::Module;

require 5.003;
use strict;
use IO::File;

BEGIN {
	use vars qw($prefix $datadir);
	$prefix = "@prefix@";
	$datadir = "@datadir@";
}

use lib "@FVWM_PERLLIBDIR@";
use vars qw($VERSION @ISA @EXPORT $AUTOLOAD);

use FVWM::Constants;
use FVWM::Event;

use Exporter;
@EXPORT = @FVWM::Constants::EXPORT;
@ISA = qw(Exporter);

# The major version part indicates major API changes
$VERSION = '1.1';

# Set the FVWM search directories (used for non fully qualified file names)
$General::FileSystem::SAVE_FILE_DIR = $General::FileSystem::SAVE_FILE_DIR ||
	__PACKAGE__->userDataDir();
$General::FileSystem::LOAD_FILE_DIRS = $General::FileSystem::LOAD_FILE_DIRS ||
	[ __PACKAGE__->searchDirs() ];

sub internalDie ($$) {
	my $self = shift;
	my $msg = shift;
	$msg =~ s/([^\.!?])$/$1./;
	die $self->name . ": $msg Exiting.\n";
}

sub debug ($$;$) {
	my $self = shift;
	my $msg = shift;
	my $level = shift || 0;
	return if $self->{debug} < $level;
	$msg =~ s/\n$//s;
	print STDERR $self->name . ": $msg\n";
}

sub isEventExtended ($$) {
	my $self = shift;
	my $type = shift;
	return $type & M_EXTENDED_MSG? 1: 0;
}

sub new ($@) {
	my $class = shift;
	my %params = @_;
	my $self = {};

	(my $name = $0) =~ s|.*/||;
	$name = $params{'Name'} || $name;
	my $mask = $params{'Mask'} || 0;
	my $xmask = $params{'XMask'}? $params{'XMask'} | M_EXTENDED_MSG: 0;
	my $sync_mask = $params{'SyncMask'} || 0;
	my $sync_xmask = $params{'SyncXMask'}? $params{'SyncXMask'} | M_EXTENDED_MSG: 0;

	# initialize module from argv
	@ARGV >= 5 or die "$name should only be run by fvwm.\n";
	my ($outFd, $inFd, $rcFile, $winId, $context) = splice(@ARGV, 0, 5);

	if (@ARGV && $params{'EnableAlias'} && $ARGV[0] =~ /^\w[\w\d\.\/-]*/) {
		$name = shift @ARGV;
	}
	if (@ARGV && ref($params{'EnableOptions'}) eq 'HASH') {
		# save time by lazy loading Getopt::Long only if needed
		eval "use Getopt::Long;"; die "$name: $@" if $@;
		GetOptions(%{$params{'EnableOptions'}})
			or die "$name: Incorrect options given.\n";
	}
	my @argv = @ARGV;

	$self->{rcFile} = $rcFile;
	$self->{winId} = hex $winId;
	$self->{context} = $context;
	$self->{argv} = [@argv];

	# a module may need this
	autoflush STDOUT;
	autoflush STDERR;

	$self->{ostream} = new IO::File ">&$outFd"
		or die "$name: Can't write to file descriptor (&$outFd)\n";
	$self->{istream} = new IO::File "<&$inFd"
		or die "$name: Can't read from file descriptor (&$inFd)\n";
	$self->{ostream}->autoflush(1);
	$self->{istream}->autoflush(1);

	$self->{disconnected} = 0;
	$self->{debug} = $params{'Debug'} || 0;
	$self->{debug} = ${$self->{debug}} if ref($self->{debug}) eq 'SCALAR';
	$self->{lastPacket} = [];
	$self->{handlers} = {};
	$self->{shouldSendUnlock} = 0;
	$self->{shouldSendReady} = 1;

	# bless here, so die above does not run DESTROY
	bless $self, $class;
	$self->name($name);
	$self->mask($mask);
	$self->mask($xmask) if $xmask;
	$self->syncMask($sync_mask);
	$self->syncMask($sync_xmask) if $sync_xmask;
	$self->resetHandlers;
	$self->readConfigInfo unless $params{'NoConfigInfo'};
	return $self;
}

sub disconnect ($) {
	my $self = shift;

	# do nonrecoverable things, but do them only once
	return if $self->{disconnected};

	$self->{disconnected} = 1;
	$self->invokeHandler(new FVWM::Event(ON_EXIT));

	if (defined $self->{ostream} && $self->{ostream}->opened) {
		$self->send("Nop", 0, 0);
		close $self->{ostream};
	}
	if (defined $self->{istream} && $self->{istream}->opened) {
		close $self->{istream};
	}
}

sub DESTROY ($) {
	my $self = shift;
	$self->disconnect;
}

sub name ($;$) {
	my $self = shift;
	my $name = shift;
	$self->{name} = $name if defined $name;
	return $self->{name};
}

sub mask ($;$) {
	my $self = shift;
	my $mask = shift;
	if (defined $mask) {
		my $maskId = $self->isEventExtended($mask)? "xmask": "mask";
		my $oldMask = $self->{$maskId};
		return $oldMask
			if $mask == M_EXTENDED_MSG;
		$self->send("SET_MASK $mask")
			unless defined $oldMask && $oldMask == $mask;
		$self->{$maskId} = $mask;
		return $oldMask;
	}
	return $self->{mask};
}

sub syncMask ($;$) {
	my $self = shift;
	my $mask = shift;
	if (defined $mask) {
		my $maskId = $self->isEventExtended($mask)? "sync_xmask": "sync_mask";
		my $oldMask = $self->{$maskId};
		return $oldMask
			if $mask == M_EXTENDED_MSG;
		$self->send("SET_SYNC_MASK $mask")
			unless defined $oldMask && $oldMask == $mask;
		$self->{$maskId} = $mask;
		return $oldMask;
	}
	return $self->{sync_mask};
}

# by default the version of a module is the FVWM version
sub version ($) {
	my $self = shift;
	return "@VERSION@";
}

sub versionInfo ($) {
	my $self = shift;
	return "@VERSIONINFO@";
}

sub argv ($) {
	my $self = shift;
	return @{$self->{argv}};
}

sub resetHandlers ($) {
	my $self = shift;

	$self->{handlers}->{regular} = {};
	$self->{handlers}->{extended} = {};
	$self->{handlers}->{special} = {};
}

sub getHandlerCategory ($$) {
	my $self = shift;
	my $type = shift;
	return "special" if $type =~ /e/i;
	return "extended" if $self->isEventExtended($type);
	return "regular";
}

# params: text, [winId], [continue=0/1]
sub send ($$;$$) {
	my $self = shift;
	my $text = shift;
	my $winId = shift || 0;
	my $continue = @_? shift(): 1;

	$self->internalDie("send requires at least text param")
		unless defined $text;

	my @lines = split(/\n/s, $text);

	my $line;
	my $lastLine = "";
	for $line (@lines) {
		# support continuation lines
		$line = "$lastLine$line" if $lastLine ne "";
		if ($line =~ /^(.*)\\$/) {
			$lastLine = $1;
			next;
		} else {
			$lastLine = "";
		}
		next if $line =~ /^\s*$/;

		unless ($self->{ostream}->opened) {
			$self->debug("Can't send [$line]\n", 0);
			next;
		}
		$self->debug("sent: [$line]", 1);
		my $len = length $line;
		$self->{ostream}->print(
			pack("lla${len}l", $winId, $len, $line, $continue)
		);
	}
}

sub sendReady ($) {
	my $self = shift;
	$self->send(RESPONSE_READY) if $self->{shouldSendReady};
	$self->{shouldSendReady} = 0;
}

sub sendUnlock ($) {
	my $self = shift;
	$self->send(RESPONSE_UNLOCK) if $self->{shouldSendUnlock};
	$self->{shouldSendUnlock} = 0;
}

sub terminate ($;$) {
	my $self = shift;
	my $continue = shift || 0;
	die "!quit" if !$continue;
	die "!next";
}

sub readPacket ($) {
	my $self = shift;

	$self->{lastPacket} = [];

	my $header = "";
	my $packet = "";

	# header is sizeof(int) * HEADER_SIZE bytes long:
	my $got = sysread($self->{istream}, $header, INTSIZE * HEADER_SIZE);

	unless (defined $got and $got == (INTSIZE * HEADER_SIZE)) {
		# module killed or other read error
		return undef;
	}

	my ($magic, $type, $len, $timestamp) =
		unpack(sprintf("L%d", HEADER_SIZE), $header);
	$self->internalDie("Bad magic number $magic in packet")
		unless $magic == START_FLAG;

	# $len is number of words in packet, including header;
	# we need this as number of bytes.
	$len -= HEADER_SIZE;
	$len *= INTSIZE;

	if ($len > 0) {
		my $off = 0;
		while ($off < $len) {
			$got = sysread($self->{istream}, $packet, $len, $off);
			if (!defined $got) {
				$self->internalDie("sysread error: $!");
			}
			$off += $got;
		}
		$self->internalDie("Got packet len $off while expecting $len")
			if $off != $len;
	}

	$self->{lastPacket} = [$packet, $type];
	return ($packet, $type);
}

sub invokeHandler ($$) {
	my $self = shift;
	my $event = shift;
	my $type = $event->type;

	my $category = $self->getHandlerCategory($type);
	my @types = sort { $a <=> $b } keys %{$self->{handlers}->{$category}};
	foreach (@types) {
		if ($type eq $_ || $type & $_) {
			my $handler;
			for $handler (@{$self->{handlers}->{$category}->{$_}}) {
				last unless $event->propagationAllowed;
				next unless defined $handler;  # skip deleted ones

				eval { &$handler($self, $event); };

				if ($@) {
					return 0 if $@ =~ /^!quit/i;
					return 1 if $@ =~ /^!next/i;
					die $@;
				}
			}
		}
	}
	return 1;
}

sub processPacket ($;$$) {
	my $self = shift;
	my ($packet, $type) = @_;

	($packet, $type) = @{$self->{lastPacket}} unless defined $packet;
	return undef unless defined $packet;

	my $event = eval { new FVWM::Event($type, $packet); };
	$self->internalDie($@ || "Internal error") unless defined $event;

	if ($self->{debug}) {
		my $msg = "got " . $event->name;
		$msg .= " [" . $event->argValues->[-1] . "]"
			if @{$event->argTypes} && $event->argTypes->[-1] == FVWM::EventNames::string();
		$self->debug($msg, 1);
	}

	$self->{shouldSendUnlock} = 1 if $type &
		($self->isEventExtended($type)? $self->{sync_xmask}: $self->{sync_mask});

	my $continue = $self->invokeHandler($event);

	$self->sendUnlock if $self->{shouldSendUnlock};
	return $continue;
}

sub eventLoop ($) {
	my $self = shift;
	my $continue = 1;

	$self->sendReady;

	while (1) {
		# catch exceptions during read, for example from alarm() handler,
		# but don't catch errors (or die) in event handlers
		$self->processPacket(eval { $self->readPacket }) || last;
	}
	$self->disconnect;
}

sub addHandler ($$$) {
	my $self = shift;
	my $type = shift;
	my $handler = shift;

	$self->internalDie("addHandler: no handler type") unless defined $type;
	$self->internalDie("addHandler: no handler code") unless ref($handler) eq 'CODE';

	my $category = $self->getHandlerCategory($type);
	$self->{handlers}->{$category}->{$type} = []
		unless exists $self->{handlers}->{$category}->{$type};
	push @{$self->{handlers}->{$category}->{$type}}, $handler;
	my $index = @{$self->{handlers}->{$category}->{$type}} - 1;
	return [$type, $index];
}

sub deleteHandler ($$) {
	my $self = shift;
	my $id = shift;

	return 0 unless ref($id) eq 'ARRAY' && @$id == 2;
	my ($type, $index) = @$id;
	my $category = $self->getHandlerCategory($type);
	return 0 unless defined $self->{handlers}->{$category}->{$type}->[$index];

	$self->{handlers}->{$category}->{$type}->[$index] = undef;
	return 1;
}

sub addDefaultErrorHandler ($) {
	my $self = shift;

	$self->addHandler(M_ERROR, sub {
		my ($self, $type, @args) = @_;
		my $error = $args[3];
		print STDERR "[", $self->name, "]: got FVWM error: $error\n";
		#$self->terminate;
	});
}

sub readConfigInfo ($@) {
	my $self = shift;

	# not implemented yet
}

sub userDataDir ($) {
	return $ENV{FVWM_USERDIR} || (($ENV{HOME} || "") . "/.fvwm");
}

sub siteDataDir ($) {
	return "@FVWM_DATADIR@";
}

sub searchDirs ($) {
	my $this = shift;
	return ($this->userDataDir, $this->siteDataDir);
}

1;

__END__

=head1 NAME

FVWM::Module - the base class representing FVWM module

=head1 SYNOPSIS

  use lib `fvwm-perllib dir`;
  use FVWM::Module;

  my $module = new FVWM::Module(Mask => M_FOCUS_CHANGE);

  $module->send("Beep");

  # auto-raise all windows
  sub autoRaise { $_[0]->send("Raise", $_[1]->_win_id) };
  $module->addHandler(M_FOCUS_CHANGE, \&autoRaise);

  $module->eventLoop;

=head1 DESCRIPTION

An FVWM module is a separate program that communicates with the main I<fvwm>
process, receives a module configuration and events and sends commands back.
This class B<FVWM::Module> makes it easy to create FVWM modules in Perl.

If you are interested in all module protocol details that this class tries
to make invisible, visit the web page I<http://fvwm.org/modules.html>.
You will need an information about packet arguments anyway to be able to
write complex modules. This is however not obligatory for simple modules
that only send commands back when something happens.

A tipical FVWM module has an initialization part including setting event
handlers using B<addHandler> methods and entering an event loop using
B<eventLoop> method. Most of the work is done in the event handlers although
a module may define other execution ways, for example using C<$SIG{ALRM}>.

The following methods are available:

B<new>,
B<version>,
B<versionInfo>,
B<argv>,
B<send>,
B<sendReady>,
B<sendUnlock>,
B<terminate>,
B<eventLoop>,
B<resetHandlers>,
B<addHandler>,
B<deleteHandler>,
B<addDefaultErrorHandler>,
B<debug>

The following methods are a bit less useful, since they are called from
other methods above:

B<internalDie>,
B<name>,
B<mask>,
B<syncMask>,
B<disconnect>,
B<getHandlerCategory>,
B<readPacket>,
B<invokeHandler>,
B<processPacket>,
B<readConfigInfo>

These methods deal with a received packet (event):

B<isEventExtended>

These methods deal with configuration directories:

B<userDataDir>,
B<siteDataDir>,
B<searchDirs>

=head1 METHODS

=over 4

=item B<new> I<param-hash>

Creates a module object. Only one module instance may be created in the
program, since this object gets exclusive rights on communication with I<fvwm>.

The following parameters may be given in the constractor:

    Name          - used in module configuration and debugging
    Mask          - events a module is interested to receive
    XMask         - the same for extended events
    SyncMask      - events to lock on
    SyncXMask     - the same for extended events
    EnableAlias   - a module accepts an alias in command line
    EnableOptions - a module accepts options in command line
    Debug         - if set to 1, print sent and received data
    NoConfigInfo  - don't read module configuration on startup

Example:

    my $module = new FVWM::Module(
        Name => "FvwmPerlBasedWindowRearranger",
        Mask => M_CONFIGURE_WINDOW | M_END_WINDOWLIST,
        EnableOptions => { "animate" => \$a, "cascade" => \$c },
        Debug => 1,
    );

Event types needed for the 4 mask parameters are defined in B<FVWM::Constants>.

=item B<version>

Returns FVWM version string I<x.y.z>.

=item B<versionInfo>

Returns FVWM version info string, like " (from cvs)" or " (snap-YYYYMMDD)".
This string is usually empty for the final version.

=item B<argv>

Returns remaining module arguments (array ref) passed in the command line.
Arguments that are used for I<fvwm>-to-module communication are not included.
Arguments that are automatically parsed using I<EnableAlias> and/or
I<EnableOptions> specified in the constructor are not included.

=item B<send> I<command> [I<window-id>]

Sends I<command> back for execution. If the I<window-id> is specified this
command will be executed in this window context.

=item B<eventLoop>

The main event loop. A module should define some event handlers using
B<addHandler> before entering the event loop. When the event happens all
event handlers registered on this event are called, then a module returns
to the event loop awaiting for new events forever.

This method may be finished when one of the following happens. 1) Explicit
B<terminate> is called in one of the event handlers. 2) Signal handler
(system signals are independent from this event loop) decides to I<die>.
This is usually catched and a proper shutdown is done. 3) An event handler
I<die>d, in this case the module aborts, this is done on purpose to
encourage programmers to fix bugs. 4) Communication with I<fvwm> closed, for
example B<KillModule> called or the main I<fvwm> process exited.

In all these cases (except for the third one) I<ON_EXIT> event handlers are
called if defined and then B<disconnect> is called. So no communication is
available after this method is finished. If you need a communication before
the module exits, define an I<ON_EXIT> event handler.

=item B<sendReady>

This is automatically called (if needed) when a module enters B<eventLoop>,
but sometimes you may want to tell I<fvwm> that the module is fully ready
earlier. This only makes sence if the module was run using
B<ModuleSynchronous> command, in this case I<fvwm> gets locked until the module
sends the "ready" notification.

=item B<sendUnlock>

When an event was configured to be sent to a module synchronously using
I<SyncMask> and I<SyncXMask>, I<fvwm> gets locked until the module sends
the "unlock" notification. This is automatically sent (if needed) when a
handler is finished, but sometimes a handler should release I<fvwm> earlier.

=item B<terminate> [I<continue>]

This method is used for 2 purposed, usually in event handlers. To terminate
the entire event loop and to terminate only an execution of the current
handler if I<continue> is set.

=item B<resetHandlers>

This deletes all event handlers without exception.

=item B<addHandler> I<mask code>

Defines a handler (that is a I<code> subroutine) for the given I<mask> event
(or several events). Usually the event type is one of the FVWM I<M_*> or
I<MX_*> constants (see B<FVWM::Constants>), but it may also be I<ON_EXIT>,
this special event is called just before the event loop is terminated.

The I<mask> may include several events in the same category (the event types
are or-ed). In this case the handler will be called for every matching event.
Currently there are 3 categories: regular events (M_*), extended events (MX_*)
and special events (ON_EXIT). These 3 categories of events can't be mixed,
primary because of technical reasons.

The handler subroutine is called with these parameters:

    ($self, $event)

where C<$self> is a module object, C<$event> is B<FVWM::Event> object.

If the I<mask> includes more than one event type, use C<$event-E<gt>type>
to dispatch event types if needed.

The handler may call C<$self-E<gt>terminate> to terminate the event loop
completely or C<$self-E<gt>terminate("continue")> to terminate the current
event handler only. The second form is useful when the handler subroutine
calls other subroutines that need to terminate the primary one.

If several event handlers are added for the same event type, they are
executed in the added order. To forbid the further propagation of the
same event, an event handler may call C<$event-E<gt>propagationAllowed(0)>.

The return value from B<addHandler> is an identifier the only purpose of
which is to be passed to B<deleteHandler> in case the newly defined handler
should be deleted at some point.

=item B<deleteHandler> I<id>

Removes the handler specified by I<id>. The return value is 1 if the handler
is found and deleted, 0 otherwise.

=item B<addDefaultErrorHandler>

This adds the default handler for I<M_ERROR> event. This class simply prints
an error message to the standard error stream, but subclasses may define
another default handler by overwriting this method.

=item B<debug> I<msg> [I<level>]

Prints I<msg> to the standard error stream if I<level> is greater or equal to
the module debug level defined using I<Debug> in the constructor. The default
I<level> for this method is 0, the default module level is 0 as well, so
just calling this method with only one parameter normally results in printing
the message. Subclasses may overwrite this method and, for example, show
all debugging messages in a separate window.

This method is automatically called (with I<level> 1) to dump all incoming
and outgoing communication data in B<send> and B<processPacket>. Apparently
this data is only seen if I<Debug> is set to something positive.

=item B<internalDie> I<msg>

This may be used to end the module with the corresponding I<msg>.
For a clean module exit use B<debug> and B<terminate> instead.

=item B<name> [I<name>]

Sets or returns the module name. Called automatically from the constructor.

=item B<mask> [I<mask>]

Sets or returns the module mask. Called automatically from the constructor.
This method should be called twice for regular and extended packet types.
If I<M_EXTENDED_MSG> is given as a parameter the method returns extended
mask, all other mask parameters results in setting the mask.

The module only receives the packets matching these 2 module masks (regular
and extended).

=item B<syncMask> [I<mask>]

The same as B<mask>, but sets/returns the synchronization mask of the
module.

The module is synchronized with I<fvwm> on all packets matching these 2
module synchronization masks (regular and extended).

=item B<disconnect>

This method invokes I<ON_EXIT> handlers if any and closes communication.
It is called automatically from B<eventLoop> before finishing.
It is safe to call this method more than once.

This method may be called from signal handlers before I<exit>ing for the
proper shutdown.

=item B<getHandlerCategory> I<type>

Returns one of 3 string ids depending on the event handler I<type> that has
the same meaning as the corresponding packet type ("regular" or "extended")
with an addition of "special" category for I<ON_EXIT> handlers.

=item B<readPacket>

This is a blocking method that waits until there is a packet on the
communication end from I<fvwm>. Then it returns a list of 2 values,
packet type and packet data (packed).

=item B<invokeHandler> I<event>

Dispatches the apropos event handlers with the event data.
This method is called automatically, so you usually should not worry about it.

=item B<processPacket> [I<data type>]

This method constructs the event object from the packet data and calls
B<invokeHandler> with it. Prints debug info if requested. Finally calls
B<sendUnlock> if needed.

You should not really worry about this method, it is called automatically
from the event loop.

=item B<readConfigInfo>

Not implemented yet.

=item B<isEventExtended> I<type>

For technical reasons there are 2 categories of FVWM events, regular and
extended. This is done to enable more events. With introdution of the
extended event types (with the highest bit set) it is now possible to have
31+31=62 different event types rather than 32. This is a good point, the bad
point is that only event types of the same category may be masked (or-ed)
together. This method returns 1 or 0 depending on whether the event I<type>
is extended or not.

=item B<userDataDir>

Returns the user data directory, usually ~/.fvwm or set by $FVWM_USERDIR.

=item B<siteDataDir>

Returns the system-wide data directory, the one configured when FVWM is
installed. It is also returned by `fvwm-config --fvwm-datadir`.

=item B<searchDirs>

It is a good practice for a module to search for the given configuration
in one of 2 data directories, the user one and the system-wide. This method
returns a list of both directories in that order.

=back

=head1 BUGS

Awaiting for your reporting.

=head1 CAVEATS

In keeping with the UNIX philosophy, B<FVWM::Module> does not keep you from
doing stupid things, as that would also keep you from doing clever things.
What this means is that there are several areas with which you can hang your
module or even royally confuse your running I<fvwm> process. This is due to
flexibility, not bugs.

=head1 AUTHOR

Mikhael Goikhman <migo@homemail.com>.

=head1 THANKS TO

Randy J. Ray <randy@byz.org>.

=head1 SEE ALSO

For more information, see L<fvwm>, L<FVWM::Module::Gtk> and L<FVWM::Module::Tk>.

=cut
